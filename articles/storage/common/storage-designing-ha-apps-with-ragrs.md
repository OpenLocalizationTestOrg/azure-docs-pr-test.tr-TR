---
title: "Yüksek oranda kullanılabilir Azure okuma erişimli coğrafi olarak yedekli depolama (RA-GRS) kullanan uygulamalar tasarlama | Microsoft Docs"
description: "Azure RA-GRS depolama bir yüksek oranda kullanılabilir uygulama kesintiler işlemek için esnek mimari için nasıl kullanılacağını."
services: storage
documentationcenter: .net
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 8f040b0f-8926-4831-ac07-79f646f31926
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 1/19/2017
ms.author: robinsh
ms.openlocfilehash: adc7e23d8c9f869f2951490020e3d0f1a2b2e81c
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/29/2017
---
# <a name="designing-highly-available-applications-using-ra-grs"></a><span data-ttu-id="ab1e5-103">Yüksek oranda kullanılabilir RA-GRS kullanarak uygulamalar tasarlama</span><span class="sxs-lookup"><span data-stu-id="ab1e5-103">Designing Highly Available Applications using RA-GRS</span></span>

<span data-ttu-id="ab1e5-104">Bir ortak bulut tabanlı altyapılar uygulamalarını barındırmak için yüksek oranda kullanılabilir bir platform sağlar özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-104">A common feature of cloud-based infrastructures is that they provide a highly available platform for hosting applications.</span></span> <span data-ttu-id="ab1e5-105">Bulut tabanlı uygulaması geliştiricileri, kullanıcılar için yüksek oranda kullanılabilir uygulamalarını sunmak üzere bu platform yararlanmak nasıl dikkatle dikkate almanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-105">Developers of cloud-based applications must consider carefully how to leverage this platform to deliver highly available applications to their users.</span></span> <span data-ttu-id="ab1e5-106">Bu makalede, özellikle geliştiriciler Azure depolama okuma erişimi coğrafi olarak yedekli depolama (RA-GRS) uygulamalarını daha fazla kullanılabilir yapmak için nasıl kullanabileceğinizi üzerinde odaklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-106">This article focuses specifically on how developers can use the Azure Storage Read Access Geo Redundant Storage (RA-GRS) to make their applications more available.</span></span>

<span data-ttu-id="ab1e5-107">Artıklık – (yerel olarak yedekli depolama) LRS, ZRS (bölge olarak yedekli depolama), (coğrafi olarak yedekli depolama) GRS ve RA-GRS (coğrafi olarak yedekli depolamaya okuma erişimi) için dört seçeneğiniz vardır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-107">There are four choices for redundancy – LRS (Locally Redundant Storage), ZRS (Zone Redundant Storage), GRS (Geo-Redundant Storage), and RA-GRS (Read Access Geo-Redundant Storage).</span></span> <span data-ttu-id="ab1e5-108">Biz GRS ve RA-GRS bu makalede ele alınacaktır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-108">We are going to discuss GRS and RA-GRS in this article.</span></span> <span data-ttu-id="ab1e5-109">GRS ile depolama hesabı oluştururken seçtiğiniz birincil bölgede verilerinizin üç kopyasını tutulur.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-109">With GRS, three copies of your data are kept in the primary region you selected when setting up the storage account.</span></span> <span data-ttu-id="ab1e5-110">Üç ek kopya Azure tarafından belirtilen bir ikincil bölge içinde zaman uyumsuz olarak korunur.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-110">Three additional copies are maintained asynchronously in a secondary region specified by Azure.</span></span> <span data-ttu-id="ab1e5-111">İkincil kopya okuma erişimi olması dışında RA-GRS GRS olarak aynı şeydir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-111">RA-GRS is the same thing as GRS except that you have read access to the secondary copy.</span></span> <span data-ttu-id="ab1e5-112">Farklı Azure Storage artıklık seçenekleri hakkında daha fazla bilgi için bkz: [Azure Storage çoğaltma](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span><span class="sxs-lookup"><span data-stu-id="ab1e5-112">For more information about the different Azure Storage redundancy options, see [Azure Storage replication](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span></span> <span data-ttu-id="ab1e5-113">Çoğaltma makalede ayrıca birincil ve ikincil bölgeler eşleştirmeleri gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-113">The replication article also shows the pairings of the primary and secondary regions.</span></span>

<span data-ttu-id="ab1e5-114">Bu makalede ve tam bir örnek, indirin ve çalıştırın sonunda bağlantı dahil kod parçacıkları vardır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-114">There are code snippets included in this article, and a link to a complete sample at the end that you can download and run.</span></span>

## <a name="key-features-of-ra-grs"></a><span data-ttu-id="ab1e5-115">RA-GRS temel özellikleri</span><span class="sxs-lookup"><span data-stu-id="ab1e5-115">Key features of RA-GRS</span></span>

<span data-ttu-id="ab1e5-116">Şimdi biz RA-GRS depolama kullanma hakkında konuşun önce özelliklerini ve davranışı hakkında konuşun.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-116">Before we talk about how to use RA-GRS storage, let's talk about its properties and behavior.</span></span>

* <span data-ttu-id="ab1e5-117">Azure depolama ikincil bir bölgede birincil bölgenizde verileri salt okunur bir kopyasını tutar; Yukarıda belirtildiği gibi depolama birimi hizmeti ikincil bölge konumunu belirler.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-117">Azure Storage maintains a read-only copy of the data you store in your primary region in a secondary region; as noted above, the storage service determines the location of the secondary region.</span></span>

* <span data-ttu-id="ab1e5-118">Salt okunur kopyasıdır [sonuçta tutarlı](https://en.wikipedia.org/wiki/Eventual_consistency) birincil bölge verileri.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-118">The read-only copy is [eventually consistent](https://en.wikipedia.org/wiki/Eventual_consistency) with the data in the primary region.</span></span>

* <span data-ttu-id="ab1e5-119">BLOB'lar, tablolar ve Kuyruklar için ikincil bölge için Sorgulayabileceğiniz bir *son eşitleme zamanı* ikincil bölge son birincil çoğaltmayı gerçekleştiği belirten değer.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-119">For blobs, tables, and queues, you can query the secondary region for a *Last Sync Time* value that tells you when the last replication from the primary to the secondary region occurred.</span></span> <span data-ttu-id="ab1e5-120">(Bu RA-GRS artıklık şu anda yok Azure File storage için desteklenmiyor.)</span><span class="sxs-lookup"><span data-stu-id="ab1e5-120">(This is not supported for Azure File storage, which doesn't have RA-GRS redundancy at this time.)</span></span>

* <span data-ttu-id="ab1e5-121">Birincil veya ikincil bölge veri ile etkileşim kurmak için depolama istemci Kitaplığı'nı kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-121">You can use the Storage Client Library to interact with the data in either the primary or secondary region.</span></span> <span data-ttu-id="ab1e5-122">Ayrıca yönlendirebilirsiniz birincil bölge için Okuma isteği zaman aşımına uğrarsa istekleri otomatik olarak ikincil bölge okuyun.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-122">You can also redirect read requests automatically to the secondary region if a read request to the primary region times out.</span></span>

* <span data-ttu-id="ab1e5-123">Birincil bölge verilerde erişilebilirliğini etkileyen önemli bir sorun varsa, bir coğrafi hangi noktada birincil bölgesine işaret eden DNS girişlerini ikincil bölge'ye işaret edecek şekilde değiştirilecek yük devretme, Azure ekibi tetikleyebilir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-123">If there is a major issue affecting the accessibility of the data in the primary region, the Azure team may trigger a geo-failover, at which point the DNS entries pointing to the primary region will be changed to point to the secondary region.</span></span>

* <span data-ttu-id="ab1e5-124">Bir coğrafi yük devretme gerçekleşirse, Azure yeni bir ikincil konum seçin ve bu konum için veri çoğaltmak sonra ikincil DNS girişlerini üzerine.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-124">If a geo-failover occurs, Azure will select a new secondary location and replicate the data to that location, then point the secondary DNS entries to it.</span></span> <span data-ttu-id="ab1e5-125">Depolama hesabı çoğaltma tamamlanana kadar ikincil uç kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-125">The secondary endpoint will be unavailable until the storage account has finished replicating.</span></span> <span data-ttu-id="ab1e5-126">Daha fazla bilgi için lütfen bkz [bir Azure Storage kesinti oluşursa yapmanız gerekenler](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span><span class="sxs-lookup"><span data-stu-id="ab1e5-126">For more information, please see [What to do if an Azure Storage outage occurs](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span></span>

## <a name="application-design-considerations-when-using-ra-grs"></a><span data-ttu-id="ab1e5-127">RA-GRS kullanırken uygulama tasarım konuları</span><span class="sxs-lookup"><span data-stu-id="ab1e5-127">Application design considerations when using RA-GRS</span></span>

<span data-ttu-id="ab1e5-128">Bu makalenin ana amacı (içinde bir sınırlı kapasite ile birlikte) birincil veri merkezinde büyük bir felaket durumunda bile çalışmaya devam edecek bir uygulama tasarlamanızı nasıl Göster sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-128">The main purpose of this article is to show you how to design an application that will continue to function (albeit in a limited capacity) even in the event of a major disaster at the primary data center.</span></span> <span data-ttu-id="ab1e5-129">Bunun için bir sorun olmasa ikincil bölgesinden okumak için geçiş ve geri birincil bölge yeniden kullanılabilir olduğunda geçiş geçici veya uzun süre çalışan sorunlarını gidermek için uygulamanızın sağlayarak.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-129">You do this by having your application to handle transient or long-running issues by switching to read from the secondary region while there is a problem, and switching back when the primary region is available again.</span></span>

### <a name="using-eventually-consistent-data"></a><span data-ttu-id="ab1e5-130">Sonuçta tutarlı verileri kullanma</span><span class="sxs-lookup"><span data-stu-id="ab1e5-130">Using eventually consistent data</span></span>

<span data-ttu-id="ab1e5-131">Önerilen Bu çözüm, çağıran uygulama için eski veri olabilir dönmek Tamam olduğunu varsayar.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-131">This proposed solution assumes that it is okay to return what could be stale data to the calling application.</span></span> <span data-ttu-id="ab1e5-132">İkincil veri sonuçta tutarlı olduğundan, birincil veri yazılmıştır, ancak ikincil güncelleştirmeye birincil bölge erişilemez geçtiğinde, çoğaltma bitmedi mümkündür.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-132">Because the secondary data is eventually consistent, it is possible that the data was written to the primary but the update to the secondary had not finished replicating when the primary region became inaccessible.</span></span>

<span data-ttu-id="ab1e5-133">Örneğin, başarılı bir güncelleştirme müşteri gönderme yapılan ve güncelleştirme ikincil yayılmadan önce sonra birincil aşağı git.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-133">For example, your customer could submit an update that is successful, and then the primary could go down before the update is propagated to the secondary.</span></span> <span data-ttu-id="ab1e5-134">Bu durumda, müşteri sonra geri okumaya isterse, kendisinin güncelleştirilen verileri yerine eski veri alır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-134">In this case, if the customer then asks to read the data back, he receives the stale data instead of the updated data.</span></span> <span data-ttu-id="ab1e5-135">Müşteri ileti nasıl bu kabul edilebilir ise ve bu durumda, karar vermeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-135">You must decide if this is acceptable, and if so, how you will message the customer.</span></span> <span data-ttu-id="ab1e5-136">Son eşitleme ikincil güncel olup olmadığını görmek için zaman bu makalenin sonraki bölümlerinde ikincil veri üzerinde denetimi öğreneceksiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-136">You'll see how to check the Last Sync Time on the secondary data later in this article to see if the secondary is up-to-date.</span></span>

### <a name="handling-services-separately-or-all-together"></a><span data-ttu-id="ab1e5-137">Ayrı ayrı veya hepsini bir araya Hizmetleri işleme</span><span class="sxs-lookup"><span data-stu-id="ab1e5-137">Handling services separately or all together</span></span>

<span data-ttu-id="ab1e5-138">Olası değil, ancak diğer hizmetlerin hala tamamen işlevseldir, ancak kullanılamaz hale için bir hizmet için mümkündür.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-138">While not likely, it is possible for one service to become unavailable while the other services are still fully functional.</span></span> <span data-ttu-id="ab1e5-139">İşleyebilir yeniden deneme ve her biri için salt okunur modda hizmet ayrı olarak (BLOB, kuyruklar, tablolar) ya da yeniden deneme tüm depolama hizmetleri için genel birlikte işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-139">You can handle the retries and read-only mode for each service separately (blobs, queues, tables), or you can handle retries generically for all the storage services together.</span></span>

<span data-ttu-id="ab1e5-140">Örneğin, uygulamanızda kuyruklar ve BLOB'lar kullanırsanız, bunların her biri için yeniden denenebilir hataları işlemek için ayrı kodda almaya karar verebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-140">For example, if you use queues and blobs in your application, you may decide to put in separate code to handle retryable errors for each of these.</span></span> <span data-ttu-id="ab1e5-141">Daha sonra bir yeniden deneme blob hizmetinden Al, ancak sıra hizmeti hala çalıştığından, yalnızca parçası blobları işlediği uygulamanızı etkilenir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-141">Then if you get a retry from the blob service, but the queue service is still working, only the part of your application that handles blobs will be impacted.</span></span> <span data-ttu-id="ab1e5-142">Tüm depolama hizmeti yeniden deneme genel olarak işlemek karar verin ve yeniden denenebilir hata blob hizmetine yapılan bir çağrı döndürürse blob hizmeti ve sıra hizmeti isteklerine etkilenir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-142">If you decide to handle all storage service retries generically and a call to the blob service returns a retryable error, then requests to both the blob service and the queue service will be impacted.</span></span>

<span data-ttu-id="ab1e5-143">Sonuç olarak, bu, uygulamanızın karmaşıklığına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-143">Ultimately, this depends on the complexity of your application.</span></span> <span data-ttu-id="ab1e5-144">Hataları hizmeti tarafından değil işlemeye karar verebilirsiniz, ancak bunun yerine yönlendirmek için okuma istekleri ikincil bölge tüm depolama hizmetleri için birincil bölgesinde bulunan herhangi bir depolama hizmeti ile ilgili bir sorun algılandığında uygulamasını ve salt okunur modda çalıştırmak.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-144">You may decide not to handle the failures by service, but instead to redirect read requests for all storage services to the secondary region and run the application in read-only mode when you detect a problem with any storage service in the primary region.</span></span>

### <a name="other-considerations"></a><span data-ttu-id="ab1e5-145">Diğer konular</span><span class="sxs-lookup"><span data-stu-id="ab1e5-145">Other considerations</span></span>

<span data-ttu-id="ab1e5-146">Bu makalenin geri kalanında aşağıdakiler ele alınacaktır diğer konular şunlardır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-146">These are the other considerations we will discuss in the rest of this article.</span></span>

*   <span data-ttu-id="ab1e5-147">Yeniden deneme devre kesici desenini kullanarak okuma isteklerinin işlenmesi</span><span class="sxs-lookup"><span data-stu-id="ab1e5-147">Handling retries of read requests using the Circuit Breaker pattern</span></span>

*   <span data-ttu-id="ab1e5-148">Sonuçta tutarlı verileri ve son eşitleme zamanı</span><span class="sxs-lookup"><span data-stu-id="ab1e5-148">Eventually-consistent data and the Last Sync Time</span></span>

*   <span data-ttu-id="ab1e5-149">Test Etme</span><span class="sxs-lookup"><span data-stu-id="ab1e5-149">Testing</span></span>

## <a name="running-your-application-in-read-only-mode"></a><span data-ttu-id="ab1e5-150">Salt okunur modda da uygulamanızı çalıştırma</span><span class="sxs-lookup"><span data-stu-id="ab1e5-150">Running your application in read-only mode</span></span>

<span data-ttu-id="ab1e5-151">RA-GRS depolama kullanmak için her iki başarısız okuma isteklerini işlemek için olmalıdır ve güncelleştirme isteği başarısız oldu (Bu durumda eklemeleri anlamı update, güncelleştirmeleri ve silme ile).</span><span class="sxs-lookup"><span data-stu-id="ab1e5-151">To use RA-GRS storage, you must be able to handle both failed read requests and failed update requests (with update in this case meaning inserts, updates, and deletions).</span></span> <span data-ttu-id="ab1e5-152">Başarısız birincil veri merkezi, okuma ikincil veri merkezine yönlendirilebilir, ancak ikincil salt okunur olduğu için güncelleştirme isteklerinin edilemez ister.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-152">If the primary data center fails, read requests can be redirected to the secondary data center, but update requests cannot because the secondary is read only.</span></span> <span data-ttu-id="ab1e5-153">Bu nedenle, uygulamanızın salt okunur modda çalıştırmak için bazı yönteme ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-153">For this reason, you need some way to run your application in read-only mode.</span></span>

<span data-ttu-id="ab1e5-154">Örneğin, depolama birimi hizmeti herhangi bir güncelleştirme isteği göndermeden önce denetlenecek bayrağı ayarlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-154">For example, you can set a flag that will be checked before submitting any update requests to the storage service.</span></span> <span data-ttu-id="ab1e5-155">Bir güncelleştirme isteği geldiğinde, atlayın ve müşteri için uygun bir yanıt döndürür.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-155">When one of the update requests comes through, you can skip it and return an appropriate response to the customer.</span></span> <span data-ttu-id="ab1e5-156">Hatta belirli özellikler devre dışı bırakmak isteyebilirsiniz Sorun çözülene ve kullanıcılara bu özellikleri geçici olarak devre dışı olduğunu bildirmek kadar değerlerinin.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-156">You may even want to disable certain features altogether until the problem is resolved and notify users that those features are temporarily unavailable.</span></span>

<span data-ttu-id="ab1e5-157">Hataları her hizmet için ayrı ayrı işlemek karar verirseniz, uygulamanızın hizmeti tarafından salt okunur modda çalıştırma yeteneği işlemek gerekir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-157">If you decide to handle errors for each service separately, you will also need to handle the ability to run your application in read-only mode by service.</span></span> <span data-ttu-id="ab1e5-158">Salt okunur bayrakları, etkinleştirilebilir ve devre dışı ve uygun yerlerde kodunuzda uygun bayrağı işleyen her hizmet için olabilir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-158">You could have read-only flags for each service that can be enabled and disabled and handle the appropriate flag in the appropriate places in your code.</span></span>

<span data-ttu-id="ab1e5-159">Başka bir yan avantajına sahiptir, uygulamanızın salt okunur modda çalıştırmak için –, bir ana uygulama yükseltmesi sırasında sınırlı işlevsellik sağlamak için olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-159">Being able to run your application in read-only mode has another side benefit – it gives you the ability to ensure limited functionality during a major application upgrade.</span></span> <span data-ttu-id="ab1e5-160">Yükseltme yaparken hiç kimse birincil bölge verilere sağlayarak uygulamanızın salt okunur modda çalıştırmak ve ikincil veri merkezine noktası tetikleyebilir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-160">You can trigger your application to run in read-only mode and point to the secondary data center, ensuring nobody is accessing the data in the primary region while you're making upgrades.</span></span>

## <a name="handling-updates-when-running-in-read-only-mode"></a><span data-ttu-id="ab1e5-161">Güncelleştirmeler salt okunur modda çalışırken işleme</span><span class="sxs-lookup"><span data-stu-id="ab1e5-161">Handling updates when running in read-only mode</span></span>

<span data-ttu-id="ab1e5-162">Salt okunur modda çalışırken güncelleştirme isteklerini işlemek için birçok yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-162">There are many ways to handle update requests when running in read-only mode.</span></span> <span data-ttu-id="ab1e5-163">Biz bu kapsamlı kapak olmaz ancak genellikle birkaç düşündüğünüz desenleri vardır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-163">We won't cover this comprehensively, but generally, there are a couple of patterns that you consider.</span></span>

1.  <span data-ttu-id="ab1e5-164">Kullanıcınız için yanıt ve şu anda güncelleştirmeleri kabul ettiğiniz değil söyleyin.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-164">You can respond to your user and tell them you are not currently accepting updates.</span></span> <span data-ttu-id="ab1e5-165">Örneğin, bir kişi yönetim sistemi kişi bilgilerine erişmek, ancak güncelleştirmeleri olmamasını müşterilere sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-165">For example, a contact management system could enable customers to access contact information but not make updates.</span></span>

2.  <span data-ttu-id="ab1e5-166">Sıraya alma güncelleştirmelerinizi başka bir bölgede olabilir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-166">You can enqueue your updates in another region.</span></span> <span data-ttu-id="ab1e5-167">Bu durumda, farklı bir bölgeye sırada bekleyen güncelleştirme isteklerinizi yazmak ve birincil veri merkezi yeniden çevrimiçi olduktan sonra bu istekleri işlemek için bir yol olması.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-167">In this case, you would write your pending update requests to a queue in a different region, and then have a way to process those requests after the primary data center comes online again.</span></span> <span data-ttu-id="ab1e5-168">Bu senaryoda, istenen güncelleştirme daha sonra işlenmek üzere sıraya bilmeniz müşteri izin vermemelisiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-168">In this scenario, you should let the customer know that the update requested is queued for later processing.</span></span>

3.  <span data-ttu-id="ab1e5-169">Başka bir bölgede depolama hesabı güncelleştirmelerinizi yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-169">You can write your updates to a storage account in another region.</span></span> <span data-ttu-id="ab1e5-170">Birincil veri merkezi tekrar çevrimiçi olduğunda, birincil veri yapısı verilerin bağlı olarak bu güncelleştirmelerin birleştirmek için bir yol olabilir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-170">Then when the primary data center comes back online, you can have a way to merge those updates into the primary data, depending on the structure of the data.</span></span> <span data-ttu-id="ab1e5-171">Örneğin, adında bir tarih damgası ile ayrı dosyaları oluşturuyorsanız, bu dosyaları birincil bölgesine kopyalayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-171">For example, if you are creating separate files with a date/time stamp in the name, you can copy those files back to the primary region.</span></span> <span data-ttu-id="ab1e5-172">Bu günlüğe kaydetme ve IOT verileri gibi bazı iş yükleri için çalışır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-172">This works for some workloads such as logging and iOT data.</span></span>

## <a name="handling-retries"></a><span data-ttu-id="ab1e5-173">Yeniden deneme işleme</span><span class="sxs-lookup"><span data-stu-id="ab1e5-173">Handling retries</span></span>

<span data-ttu-id="ab1e5-174">Bunu nasıl hangi hataları yeniden denenebilir bilmeniz?</span><span class="sxs-lookup"><span data-stu-id="ab1e5-174">How do you know which errors are retryable?</span></span> <span data-ttu-id="ab1e5-175">Bu depolama istemcisi kitaplığı tarafından belirlenir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-175">This is determined by the storage client library.</span></span> <span data-ttu-id="ab1e5-176">Örneğin, onu yeniden deneniyor başarılı şekilde neden büyük olasılıkla olmadığından 404 hatası (kaynak bulunamadı) yeniden denenebilir değil.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-176">For example, a 404 error (resource not found) is not retryable because retrying it is not likely to result in success.</span></span> <span data-ttu-id="ab1e5-177">Öte yandan, bir 500 sunucu hatası olduğundan ve yalnızca geçici bir sorun olabilir yeniden denenebilir hatasıdır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-177">On the other hand, a 500 error is retryable because it is a server error, and it may simply be a transient issue.</span></span> <span data-ttu-id="ab1e5-178">Daha fazla ayrıntı için kullanıma [açık kaynak kodu ExponentialRetry sınıfı için](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) .NET depolama istemci Kitaplığı'nda.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-178">For more details, check out the [open source code for the ExponentialRetry class](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) in the .NET storage client library.</span></span> <span data-ttu-id="ab1e5-179">(ShouldRetry yöntemi arayın.)</span><span class="sxs-lookup"><span data-stu-id="ab1e5-179">(Look for the ShouldRetry method.)</span></span>

### <a name="read-requests"></a><span data-ttu-id="ab1e5-180">Okuma isteği</span><span class="sxs-lookup"><span data-stu-id="ab1e5-180">Read requests</span></span>

<span data-ttu-id="ab1e5-181">Birincil depolama ile ilgili bir sorun ise ikincil depolamaya Okuma isteği yönlendirilebilir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-181">Read requests can be redirected to secondary storage if there is a problem with primary storage.</span></span> <span data-ttu-id="ab1e5-182">İçinde yukarıda olarak belirtildiği [sonunda tutarlı verileri kullanarak](#using-eventually-consistent-data), potansiyel olarak eski verileri okumak, uygulamanız için kabul edilebilir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-182">As noted above in [Using Eventually Consistent Data](#using-eventually-consistent-data), it must be acceptable for your application to potentially read stale data.</span></span> <span data-ttu-id="ab1e5-183">RA-GRS verilere erişmek için depolama istemci kitaplığı kullanıyorsanız için bir değer ayarlayarak Okuma isteği yeniden deneme davranışını belirtebilirsiniz **LocationMode** özelliğini şunlardan biri:</span><span class="sxs-lookup"><span data-stu-id="ab1e5-183">If you are using the storage client library to access RA-GRS data, you can specify the retry behavior of a read request by setting a value for the **LocationMode** property to one of the following:</span></span>

*   <span data-ttu-id="ab1e5-184">**PrimaryOnly** (varsayılan)</span><span class="sxs-lookup"><span data-stu-id="ab1e5-184">**PrimaryOnly** (the default)</span></span>

*   <span data-ttu-id="ab1e5-185">**PrimaryThenSecondary**</span><span class="sxs-lookup"><span data-stu-id="ab1e5-185">**PrimaryThenSecondary**</span></span>

*   <span data-ttu-id="ab1e5-186">**SecondaryOnly**</span><span class="sxs-lookup"><span data-stu-id="ab1e5-186">**SecondaryOnly**</span></span>

*   <span data-ttu-id="ab1e5-187">**SecondaryThenPrimary**</span><span class="sxs-lookup"><span data-stu-id="ab1e5-187">**SecondaryThenPrimary**</span></span>

<span data-ttu-id="ab1e5-188">Ayarladığınızda **LocationMode** için **PrimaryThenSecondary**, istemci yeniden denenebilir bir hatasıyla birincil uç noktası başarısız ilk Okuma isteği ikincil uç noktasına başka bir okuma isteği otomatik olarak yapıyorsa.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-188">When you set the **LocationMode** to **PrimaryThenSecondary**, if the initial read request to the primary endpoint fails with a retryable error, the client automatically makes another read request to the secondary endpoint.</span></span> <span data-ttu-id="ab1e5-189">Bir sunucu zaman aşımı hatası ise, istemci hizmetinden yeniden denenebilir hata almadan önce süresi dolacak şekilde zaman aşımı beklemeniz gerekecektir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-189">If the error is a server timeout, then the client will have to wait for the timeout to expire before it receives a retryable error from the service.</span></span>

<span data-ttu-id="ab1e5-190">Temel olarak ne zaman yeniden denenebilir hata isteklerine nasıl karar verirken dikkate alınması gereken iki senaryo vardır:</span><span class="sxs-lookup"><span data-stu-id="ab1e5-190">There are basically two scenarios to consider when you are deciding how to respond to a retryable error:</span></span>

*   <span data-ttu-id="ab1e5-191">Bu yalıtılmış bir sorundur ve birincil uç noktası için sonraki istekleri yeniden denenebilir hata döndürmez.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-191">This is an isolated problem and subsequent requests to the primary endpoint will not return a retryable error.</span></span> <span data-ttu-id="ab1e5-192">Geçici ağ hatası olduğunda, bu durum oluşabilir bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-192">An example of where this might happen is when there is a transient network error.</span></span>

    <span data-ttu-id="ab1e5-193">Bu senaryoda, yoktur önemli performansta düşme olmaz elde etmeyle **LocationMode** kümesine **PrimaryThenSecondary** yalnızca seyrek böyle gibi.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-193">In this scenario, there is no significant performance penalty in having **LocationMode** set to **PrimaryThenSecondary** as this only happens infrequently.</span></span>

*   <span data-ttu-id="ab1e5-194">Bu en az bir birincil bölge içinde depolama hizmetleri ile ilgili bir sorun ve tüm istekler o hizmet birincil bölgede bir süre için yeniden denenebilir hata döndürüyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-194">This is a problem with at least one of the storage services in the primary region and all subsequent requests to that service in the primary region are likely to return retryable errors for a period of time.</span></span> <span data-ttu-id="ab1e5-195">Bu birincil bölge tamamen erişilemez örneğidir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-195">An example of this is if the primary region is completely inaccessible.</span></span>

    <span data-ttu-id="ab1e5-196">Bu senaryoda, bulunmaktadır performans tüm okuma istekleri birincil endpoint ilk deneyin, bekleme zaman aşımı süresi sonra ikincil uç noktasına geçiş için.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-196">In this scenario, there is a performance penalty because all your read requests will try the primary endpoint first, wait for the timeout to expire, then switch to the secondary endpoint.</span></span>

<span data-ttu-id="ab1e5-197">Bu senaryolarda, bunları olmadığını birincil uç noktası ile devam eden bir sorundur ve ayarlayarak isteklerini doğrudan ikincil uç noktaya okuma gönderme tanımlamanız gerekir **LocationMode** özelliğine **SecondaryOnly**.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-197">For these scenarios, you should identify that there is an ongoing issue with the primary endpoint and send all read requests directly to the secondary endpoint by setting the **LocationMode** property to **SecondaryOnly**.</span></span> <span data-ttu-id="ab1e5-198">Şu anda salt okunur modda çalıştırmak için uygulama aynı zamanda değiştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-198">At this time, you should also change the application to run in read-only mode.</span></span> <span data-ttu-id="ab1e5-199">Bu yaklaşım olarak bilinen [devre kesici düzeni](https://msdn.microsoft.com/library/dn589784.aspx).</span><span class="sxs-lookup"><span data-stu-id="ab1e5-199">This approach is known as the [Circuit Breaker Pattern](https://msdn.microsoft.com/library/dn589784.aspx).</span></span>

### <a name="update-requests"></a><span data-ttu-id="ab1e5-200">Güncelleştirme isteği</span><span class="sxs-lookup"><span data-stu-id="ab1e5-200">Update requests</span></span>

<span data-ttu-id="ab1e5-201">Devre kesici düzeni, ayrıca güncelleştirme isteklerinin uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-201">The Circuit Breaker pattern can also be applied to update requests.</span></span> <span data-ttu-id="ab1e5-202">Ancak, güncelleştirme isteklerinin salt okunur ikincil depolama yönlendirilemez.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-202">However, update requests cannot be redirected to secondary storage, which is read-only.</span></span> <span data-ttu-id="ab1e5-203">Bu istekler için bırakmanız **LocationMode** özelliğini **PrimaryOnly** (varsayılan).</span><span class="sxs-lookup"><span data-stu-id="ab1e5-203">For these requests, you should leave the **LocationMode** property set to **PrimaryOnly** (the default).</span></span> <span data-ttu-id="ab1e5-204">Bu hataları işlemek için bu istekleri – bir satırda – 10 hataları gibi bir ölçümü uygulamak ve, eşiğine ulaşıldığında salt okunur modda uygulamasına geçiş yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-204">To handle these errors, you can apply a metric to these requests – such as 10 failures in a row – and when your threshold is met, switch the application into read-only mode.</span></span> <span data-ttu-id="ab1e5-205">Aynı yöntemleri döndürmek için bu aşağıda devre kesici desen hakkında sonraki bölümde açıklanan şekilde modu güncelleştirmek için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-205">You can use the same methods for returning to update mode as those described below in the next section about the Circuit Breaker pattern.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="ab1e5-206">Devre kesici düzeni</span><span class="sxs-lookup"><span data-stu-id="ab1e5-206">Circuit Breaker pattern</span></span>

<span data-ttu-id="ab1e5-207">Devre kesici düzeni uygulamanızda kullanarak büyük olasılıkla art arda başarısız olan işlem yeniden deneniyor engelleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-207">Using the Circuit Breaker pattern in your application can prevent it from retrying an operation that is likely to fail repeatedly.</span></span> <span data-ttu-id="ab1e5-208">Uygulama çalışmaya devam etmesini sağlar yapmak yerine alma işlemi sırasında süresini üstel olarak denenir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-208">It allows the application to continue to run rather than taking up time while the operation is retried exponentially.</span></span> <span data-ttu-id="ab1e5-209">Hataya sabit olduğunda, aynı zamanda uygulama işlemi yeniden deneyebilirsiniz de algılar.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-209">It also detects when the fault has been fixed, at which time the application can try the operation again.</span></span>

### <a name="how-to-implement-the-circuit-breaker-pattern"></a><span data-ttu-id="ab1e5-210">Devre kesici düzeni uygulama</span><span class="sxs-lookup"><span data-stu-id="ab1e5-210">How to implement the circuit breaker pattern</span></span>

<span data-ttu-id="ab1e5-211">Birincil bir uç noktası ile devam eden bir sorun olduğunu belirlemek için ne sıklıkta istemci yeniden denenebilir hatayla karşılaştığında izleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-211">To identify that there is an ongoing problem with a primary endpoint, you can monitor how frequently the client encounters retryable errors.</span></span> <span data-ttu-id="ab1e5-212">Her durumda farklı olduğundan, ikincil uç noktasına geçin ve salt okunur modda uygulamayı çalıştırmak için kararı için kullanmak istediğiniz eşik karar vermeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-212">Because each case is different, you have to decide on the threshold you want to use for the decision to switch to the secondary endpoint and run the application in read-only mode.</span></span> <span data-ttu-id="ab1e5-213">Örneğin, bir satırda hiçbir başarı ile 10 hata varsa, geçişi gerçekleştirmek karar.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-213">For example, you could decide to perform the switch if there are 10 failures in a row with no successes.</span></span> <span data-ttu-id="ab1e5-214">2 dakikalık bir süre içinde istekleri % 90'ını başarısız olursa geçiş başka bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-214">Another example is to switch if 90% of the requests in a 2-minute period fail.</span></span>

<span data-ttu-id="ab1e5-215">İlk senaryo için yalnızca başarısızlık sayısı tutmak ve varsa bir başarı maksimum ulaşmadan önce sayısı sıfır olarak ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-215">For the first scenario, you can simply keep a count of the failures, and if there is a success before reaching the maximum, set the count back to zero.</span></span> <span data-ttu-id="ab1e5-216">İkinci senaryo için uygulamak için bir yol MemoryCache nesnesi (.NET) kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-216">For the second scenario, one way to implement it is to use the MemoryCache object (in .NET).</span></span> <span data-ttu-id="ab1e5-217">Her istek için bir CacheItem önbelleğine ekleme değeri (1) başarılı durumuna ayarlayın veya (0) başarısız ve sona erme zamanı şimdi (veya ne olursa olsun, zaman sınırlaması) 2 dakika olarak ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-217">For each request, add a CacheItem to the cache, set the value to success (1) or fail (0), and set the expiration time to 2 minutes from now (or whatever your time constraint is).</span></span> <span data-ttu-id="ab1e5-218">Bir girdi sona erme süresine ulaşıldığında, giriş otomatik olarak kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-218">When an entry's expiration time is reached, the entry is automatically removed.</span></span> <span data-ttu-id="ab1e5-219">Bu bir çalışırken 2 dakikalık penceresi verir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-219">This will give you a rolling 2-minute window.</span></span> <span data-ttu-id="ab1e5-220">Depolama hizmetine bir istek yaptığınızda, ilk LINQ sorgusu MemoryCache nesne boyunca yüzde başarı değerlerin toplamını ve bazında sayı bölen tarafından hesaplamak için kullanın.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-220">Each time you make a request to the storage service, you first use a Linq query across the MemoryCache object to calculate the percent success by summing the values and dividing by the count.</span></span> <span data-ttu-id="ab1e5-221">Yüzde başarı (örneğin, % 10) bazı eşiğin altına düştüğünde ayarlamak **LocationMode** özelliği okuma isteklerini **SecondaryOnly** ve devam etmeden önce salt okunur modda uygulamasına geçin.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-221">When the percent success drops below some threshold (such as 10%), set the **LocationMode** property for read requests to **SecondaryOnly** and switch the application into read-only mode before continuing.</span></span>

<span data-ttu-id="ab1e5-222">Yapılandırılabilir parametreler yapmadan dikkate almanız gereken şekilde geçiş yapmak ne zaman belirlemek için kullanılan hataları eşiğinin uygulamanızda, hizmetten hizmete farklılık gösterebilir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-222">The threshold of errors used to determine when to make the switch may vary from service to service in your application, so you should consider making them configurable parameters.</span></span> <span data-ttu-id="ab1e5-223">Bu aynı zamanda her hizmetinden yeniden denenebilir hataları ayrı ayrı işlemek karar burada olup ya da bir, daha önce bahsedildiği gibi olarak.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-223">This is also where you decide to handle retryable errors from each service separately or as one, as discussed previously.</span></span>

<span data-ttu-id="ab1e5-224">Bir uygulama birden çok örneğini nasıl ele alınacağını ve her örnek yeniden denenebilir hata algılamak ne yapacakları bunun başka bir konudur.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-224">Another consideration is how to handle multiple instances of an application, and what to do when you detect retryable errors in each instance.</span></span> <span data-ttu-id="ab1e5-225">Örneğin, 20 VM'ler yüklenen uygulamayla çalışıyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-225">For example, you may have 20 VMs running with the same application loaded.</span></span> <span data-ttu-id="ab1e5-226">Her örneği ayrı ayrı işlemek?</span><span class="sxs-lookup"><span data-stu-id="ab1e5-226">Do you handle each instance separately?</span></span> <span data-ttu-id="ab1e5-227">Bir örnek bir sorun olduğunda sorunlarınız bir örneğini başlatır, örneğine yanıt olarak yalnızca bir sınırlamak istediğiniz ya da sahip denemek istiyor musunuz tüm örnekleri aynı şekilde yanıt?</span><span class="sxs-lookup"><span data-stu-id="ab1e5-227">If one instance starts having problems, do you want to limit the response to just that one instance, or do you want to try to have all instances respond in the same way when one instance has a problem?</span></span> <span data-ttu-id="ab1e5-228">Ayrı ayrı örnekleri işleme yanıtı koordine etmek çalışırken daha çok daha kolaydır, ancak bunu nasıl yapacağınız uygulamanızın mimarisine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-228">Handling the instances separately is much simpler than trying to coordinate the response across them, but how you do this depends on your application's architecture.</span></span>

### <a name="options-for-monitoring-the-error-frequency"></a><span data-ttu-id="ab1e5-229">Hata sıklığı izleme seçenekleri</span><span class="sxs-lookup"><span data-stu-id="ab1e5-229">Options for monitoring the error frequency</span></span>

<span data-ttu-id="ab1e5-230">İkincil bölge'ye geçiş yapın ve uygulamayı salt okunur modunda çalışacak şekilde değiştirmek ne zaman belirlemek üzere birincil bölge içinde yeniden deneme sıklığını izleme için üç ana seçeneğiniz vardır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-230">You have three main options for monitoring the frequency of retries in the primary region in order to determine when to switch over to the secondary region and change the application to run in read-only mode.</span></span>

*   <span data-ttu-id="ab1e5-231">İçin bir işleyici ekleyin [ **yeniden deneniyor** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) olayda [ **OperationContext** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) depolama alanınızın geçirdiğiniz nesne istekleri – bu makalede gösterilen ve eşlik eden örnekte kullanılan yöntem budur.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-231">Add a handler for the [**Retrying**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) event on the [**OperationContext**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) object you pass to your storage requests – this is the method displayed in this article and used in the accompanying sample.</span></span> <span data-ttu-id="ab1e5-232">İstemci ne sıklıkta istemci birincil bir uç noktada yeniden denenebilir hatayla karşılaştığında izlemenizi sağlayan bir isteği yeniden deneme zaman bu olayları kov.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-232">These events fire whenever the client retries a request, enabling you to track how often the client encounters retryable errors on a primary endpoint.</span></span>

    ```csharp 
    operationContext.Retrying += (sender, arguments) =>
    {
        // Retrying in the primary region
        if (arguments.Request.Host == primaryhostname)
            ...
    };
    ```

*   <span data-ttu-id="ab1e5-233">İçinde [ **değerlendir** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) yöntemi bir özel yeniden deneme İlkesi'nde çalıştırabilirsiniz özel kod her bir yeniden deneme gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-233">In the [**Evaluate**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) method in a custom retry policy, you can run custom code whenever a retry takes place.</span></span> <span data-ttu-id="ab1e5-234">Yeniden deneme zaman kaydı yanı sıra olur, bu da, yeniden deneme davranışı değiştirme olanağı sağlar.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-234">In addition to recording when a retry happens, this also gives you the opportunity to modify your retry behavior.</span></span>

    ```csharp 
    public RetryInfo Evaluate(RetryContext retryContext,
    OperationContext operationContext)
    {
        var statusCode = retryContext.LastRequestResult.HttpStatusCode;
        if (retryContext.CurrentRetryCount >= this.maximumAttempts
        || ((statusCode &gt;= 300 && statusCode &lt; 500 && statusCode != 408)
        || statusCode == 501 // Not Implemented
        || statusCode == 505 // Version Not Supported
            ))
        {
        // Do not retry
            return null;
        }

        // Monitor retries in the primary location
        ...

        // Determine RetryInterval and TargetLocation
        RetryInfo info =
            CreateRetryInfo(retryContext.CurrentRetryCount);

        return info;
    }
    ```

*   <span data-ttu-id="ab1e5-235">Birincil storage uç noktanız okuma (örneğin, küçük bir blob okuma) istekleri kukla ile sürekli olarak ping atar uygulamanızda özel bir izleme bileşeni uygulamak için üçüncü yaklaşımdır, sistem durumunu belirlemek için.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-235">The third approach is to implement a custom monitoring component in your application that continually pings your primary storage endpoint with dummy read requests (such as reading a small blob) to determine its health.</span></span> <span data-ttu-id="ab1e5-236">Bu, bazı kaynaklar ancak önemli ölçüde kalırsınız.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-236">This would take up some resources, but not a significant amount.</span></span> <span data-ttu-id="ab1e5-237">Ardından, eşiğe ulaştığında bir sorun algılandığında anahtara gerçekleştireceği **SecondaryOnly** ve salt okunur modda.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-237">When a problem is discovered that reaches your threshold, you would then perform the switch to **SecondaryOnly** and read-only mode.</span></span>

<span data-ttu-id="ab1e5-238">Belirli bir noktada geri kullanan birincil uç noktasını ve güncelleştirmelere izin için geçiş yapmak istersiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-238">At some point, you will want to switch back to using the primary endpoint and allowing updates.</span></span> <span data-ttu-id="ab1e5-239">Rasgele seçilen bir zaman miktarı veya işlemlerinin sayısı gerçekleştirildikten sonra yukarıda listelenen ilk iki yöntemden birini kullanıyorsanız, yalnızca birincil endpoint ve güncelleştirme modunu etkinleştirmek için geçiş.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-239">If using one of the first two methods listed above, you could simply switch back to the primary endpoint and enable update mode after an arbitrarily selected amount of time or number of operations has been performed.</span></span> <span data-ttu-id="ab1e5-240">Ardından, yeniden deneme mantığı yeniden Git izin verebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-240">You can then let it go through the retry logic again.</span></span> <span data-ttu-id="ab1e5-241">Sorunun giderilmiş, birincil uç noktası kullan ve güncelleştirmelere izin vermek devam eder.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-241">If the problem has been fixed, it will continue to use the primary endpoint and allow updates.</span></span> <span data-ttu-id="ab1e5-242">Hala bir sorun varsa, bu kez daha ikincil uç noktaya ve salt okunur modda için ayarladığınız ölçütleri başarısız sonra geçiş yapar.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-242">If there is still a problem, it will once more switch back to the secondary endpoint and read-only mode after failing the criteria you've set.</span></span>

<span data-ttu-id="ab1e5-243">Üçüncü senaryo için birincil depolama endpoint ping yeniden başarılı olduğunda anahtar tetikleyebilir geri **PrimaryOnly** ve güncelleştirmelere izin devam edin.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-243">For the third scenario, when pinging the primary storage endpoint becomes successful again, you can trigger the switch back to **PrimaryOnly** and continue allowing updates.</span></span>

## <a name="handling-eventually-consistent-data"></a><span data-ttu-id="ab1e5-244">Sonuçta tutarlı verileri işleme</span><span class="sxs-lookup"><span data-stu-id="ab1e5-244">Handling eventually consistent data</span></span>

<span data-ttu-id="ab1e5-245">RA-GRS işlemleri birincil sunucudan ikincil bölge'ye yineleyerek çalışır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-245">RA-GRS works by replicating transactions from the primary to the secondary region.</span></span> <span data-ttu-id="ab1e5-246">Bu çoğaltma işlemi ikincil bölge verilerde olduğunu garanti *sonuçta tutarlı*.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-246">This replication process guarantees that the data in the secondary region is *eventually consistent*.</span></span> <span data-ttu-id="ab1e5-247">Birincil bölge içinde tüm işlemlerin sonunda ikincil bölge'de görünür, ancak bunlar ilk olarak birincil bölgede uygulanan aynı sırada ikincil bölgede olabileceğini bir gecikme göründükleri önce ve işlemleri garantisi yoktur gelmesini bu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-247">This means that all the transactions in the primary region will eventually appear in the secondary region, but that there may be a lag before they appear, and that there is no guarantee the transactions arrive in the secondary region in the same order as that in which they were originally applied in the primary region.</span></span> <span data-ttu-id="ab1e5-248">İşlemlerinizi sırasıyla dışında ikincil bölgede ulaşırsa, *olabilir* hizmet arayı kapatıncaya kadar tutarsız bir durumda olmasını ikincil bölge verilerinizi göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-248">If your transactions arrive in the secondary region out of order, you *may* consider your data in the secondary region to be in an inconsistent state until the service catches up.</span></span>

<span data-ttu-id="ab1e5-249">Aşağıdaki tabloda her bir üyesi yapmak için bir çalışan ayrıntılarını güncelleştirdiğinizde ne gerçekleşebilir örneği gösterilmektedir *Yöneticiler* rol.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-249">The following table shows an example of what might happen when you update the details of an employee to make her a member of the *administrators* role.</span></span> <span data-ttu-id="ab1e5-250">Bu örnek amacıyla, bu güncelleştirme gerektirir **çalışan** varlık ve güncelleştirme bir **Yönetici rolü** varlık ile yöneticiler sayısı toplam sayısı.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-250">For the sake of this example, this requires you update the **employee** entity and update an **administrator role** entity with a count of the total number of administrators.</span></span> <span data-ttu-id="ab1e5-251">Nasıl güncelleştirmeleri bozuk ikincil bölge'de uygulandığını dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-251">Notice how the updates are applied out of order in the secondary region.</span></span>

| <span data-ttu-id="ab1e5-252">**Saat**</span><span class="sxs-lookup"><span data-stu-id="ab1e5-252">**Time**</span></span> | <span data-ttu-id="ab1e5-253">**İşlem**</span><span class="sxs-lookup"><span data-stu-id="ab1e5-253">**Transaction**</span></span>                                            | <span data-ttu-id="ab1e5-254">**Çoğaltma**</span><span class="sxs-lookup"><span data-stu-id="ab1e5-254">**Replication**</span></span>                       | <span data-ttu-id="ab1e5-255">**Son eşitleme zamanı**</span><span class="sxs-lookup"><span data-stu-id="ab1e5-255">**Last Sync Time**</span></span> | <span data-ttu-id="ab1e5-256">**Sonuç**</span><span class="sxs-lookup"><span data-stu-id="ab1e5-256">**Result**</span></span> |
|----------|------------------------------------------------------------|---------------------------------------|--------------------|------------| 
| <span data-ttu-id="ab1e5-257">T0</span><span class="sxs-lookup"><span data-stu-id="ab1e5-257">T0</span></span>       | <span data-ttu-id="ab1e5-258">İşlem A:</span><span class="sxs-lookup"><span data-stu-id="ab1e5-258">Transaction A:</span></span> <br> <span data-ttu-id="ab1e5-259">Çalışanı Ekle</span><span class="sxs-lookup"><span data-stu-id="ab1e5-259">Insert employee</span></span> <br> <span data-ttu-id="ab1e5-260">birincil varlık</span><span class="sxs-lookup"><span data-stu-id="ab1e5-260">entity in primary</span></span> |                                   |                    | <span data-ttu-id="ab1e5-261">Birincil olarak eklenen bir işlem,</span><span class="sxs-lookup"><span data-stu-id="ab1e5-261">Transaction A inserted to primary,</span></span><br> <span data-ttu-id="ab1e5-262">henüz çoğaltılmamış.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-262">not replicated yet.</span></span> |
| <span data-ttu-id="ab1e5-263">T1</span><span class="sxs-lookup"><span data-stu-id="ab1e5-263">T1</span></span>       |                                                            | <span data-ttu-id="ab1e5-264">İşlem A</span><span class="sxs-lookup"><span data-stu-id="ab1e5-264">Transaction A</span></span> <br> <span data-ttu-id="ab1e5-265">Çoğaltılan</span><span class="sxs-lookup"><span data-stu-id="ab1e5-265">replicated to</span></span><br> <span data-ttu-id="ab1e5-266">İkincil</span><span class="sxs-lookup"><span data-stu-id="ab1e5-266">secondary</span></span> | <span data-ttu-id="ab1e5-267">T1</span><span class="sxs-lookup"><span data-stu-id="ab1e5-267">T1</span></span> | <span data-ttu-id="ab1e5-268">İşlem bir ikincil yinelenmiş.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-268">Transaction A replicated to secondary.</span></span> <br><span data-ttu-id="ab1e5-269">Son eşitleme zamanı güncelleştirildi.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-269">Last Sync Time updated.</span></span>    |
| <span data-ttu-id="ab1e5-270">T2</span><span class="sxs-lookup"><span data-stu-id="ab1e5-270">T2</span></span>       | <span data-ttu-id="ab1e5-271">İşlem B:</span><span class="sxs-lookup"><span data-stu-id="ab1e5-271">Transaction B:</span></span><br><span data-ttu-id="ab1e5-272">Güncelleştirme</span><span class="sxs-lookup"><span data-stu-id="ab1e5-272">Update</span></span><br> <span data-ttu-id="ab1e5-273">çalışan varlık</span><span class="sxs-lookup"><span data-stu-id="ab1e5-273">employee entity</span></span><br> <span data-ttu-id="ab1e5-274">birincil</span><span class="sxs-lookup"><span data-stu-id="ab1e5-274">in primary</span></span>  |                                | <span data-ttu-id="ab1e5-275">T1</span><span class="sxs-lookup"><span data-stu-id="ab1e5-275">T1</span></span>                 | <span data-ttu-id="ab1e5-276">İşlem için birincil yazılmış B,</span><span class="sxs-lookup"><span data-stu-id="ab1e5-276">Transaction B written to primary,</span></span><br> <span data-ttu-id="ab1e5-277">henüz çoğaltılmamış.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-277">not replicated yet.</span></span>  |
| <span data-ttu-id="ab1e5-278">T3</span><span class="sxs-lookup"><span data-stu-id="ab1e5-278">T3</span></span>       | <span data-ttu-id="ab1e5-279">İşlem C:</span><span class="sxs-lookup"><span data-stu-id="ab1e5-279">Transaction C:</span></span><br> <span data-ttu-id="ab1e5-280">Güncelleştirme</span><span class="sxs-lookup"><span data-stu-id="ab1e5-280">Update</span></span> <br><span data-ttu-id="ab1e5-281">Yönetici</span><span class="sxs-lookup"><span data-stu-id="ab1e5-281">administrator</span></span><br><span data-ttu-id="ab1e5-282">Rol varlığı</span><span class="sxs-lookup"><span data-stu-id="ab1e5-282">role entity in</span></span><br><span data-ttu-id="ab1e5-283">birincil</span><span class="sxs-lookup"><span data-stu-id="ab1e5-283">primary</span></span> |                    | <span data-ttu-id="ab1e5-284">T1</span><span class="sxs-lookup"><span data-stu-id="ab1e5-284">T1</span></span>                 | <span data-ttu-id="ab1e5-285">İşlem için birincil yazılmış C,</span><span class="sxs-lookup"><span data-stu-id="ab1e5-285">Transaction C written to primary,</span></span><br> <span data-ttu-id="ab1e5-286">henüz çoğaltılmamış.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-286">not replicated yet.</span></span>  |
| <span data-ttu-id="ab1e5-287">*T4*</span><span class="sxs-lookup"><span data-stu-id="ab1e5-287">*T4*</span></span>     |                                                       | <span data-ttu-id="ab1e5-288">İşlem C</span><span class="sxs-lookup"><span data-stu-id="ab1e5-288">Transaction C</span></span> <br><span data-ttu-id="ab1e5-289">Çoğaltılan</span><span class="sxs-lookup"><span data-stu-id="ab1e5-289">replicated to</span></span><br> <span data-ttu-id="ab1e5-290">İkincil</span><span class="sxs-lookup"><span data-stu-id="ab1e5-290">secondary</span></span> | <span data-ttu-id="ab1e5-291">T1</span><span class="sxs-lookup"><span data-stu-id="ab1e5-291">T1</span></span>         | <span data-ttu-id="ab1e5-292">İşlem için ikincil çoğaltılan C.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-292">Transaction C replicated to secondary.</span></span><br><span data-ttu-id="ab1e5-293">Olduğundan güncelleştirilmedi LastSyncTime</span><span class="sxs-lookup"><span data-stu-id="ab1e5-293">LastSyncTime not updated because</span></span> <br><span data-ttu-id="ab1e5-294">işlem B henüz çoğaltılmamış.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-294">transaction B has not been replicated yet.</span></span>|
| <span data-ttu-id="ab1e5-295">*T5*</span><span class="sxs-lookup"><span data-stu-id="ab1e5-295">*T5*</span></span>     | <span data-ttu-id="ab1e5-296">Varlıkların okuma</span><span class="sxs-lookup"><span data-stu-id="ab1e5-296">Read entities</span></span> <br><span data-ttu-id="ab1e5-297">İkincil</span><span class="sxs-lookup"><span data-stu-id="ab1e5-297">from secondary</span></span>                           |                                  | <span data-ttu-id="ab1e5-298">T1</span><span class="sxs-lookup"><span data-stu-id="ab1e5-298">T1</span></span>                 | <span data-ttu-id="ab1e5-299">Çalışanın eski değer alma</span><span class="sxs-lookup"><span data-stu-id="ab1e5-299">You get the stale value for employee</span></span> <br> <span data-ttu-id="ab1e5-300">Varlık işlem B kurmadı çünkü</span><span class="sxs-lookup"><span data-stu-id="ab1e5-300">entity because transaction B hasn't</span></span> <br> <span data-ttu-id="ab1e5-301">henüz çoğaltılan.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-301">replicated yet.</span></span> <span data-ttu-id="ab1e5-302">Yeni değerini alın</span><span class="sxs-lookup"><span data-stu-id="ab1e5-302">You get the new value for</span></span><br> <span data-ttu-id="ab1e5-303">Yönetici rolü varlığı C olduğundan</span><span class="sxs-lookup"><span data-stu-id="ab1e5-303">administrator role entity because C has</span></span><br> <span data-ttu-id="ab1e5-304">Çoğaltılan.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-304">replicated.</span></span> <span data-ttu-id="ab1e5-305">Son eşitleme zamanı hala tamamlanmamış</span><span class="sxs-lookup"><span data-stu-id="ab1e5-305">Last Sync Time still hasn't</span></span><br> <span data-ttu-id="ab1e5-306">Silinmiş olduğundan güncelleştirilmiş işlem B</span><span class="sxs-lookup"><span data-stu-id="ab1e5-306">been updated because transaction B</span></span><br> <span data-ttu-id="ab1e5-307">Çoğaltılan kurmadı.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-307">hasn't replicated.</span></span> <span data-ttu-id="ab1e5-308">Size söyleyebilir</span><span class="sxs-lookup"><span data-stu-id="ab1e5-308">You can tell the</span></span><br><span data-ttu-id="ab1e5-309">Yönetici rolü varlığı tutarsız.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-309">administrator role entity is inconsistent</span></span> <br><span data-ttu-id="ab1e5-310">Varlık tarih/saat sonra olduğundan</span><span class="sxs-lookup"><span data-stu-id="ab1e5-310">because the entity date/time is after</span></span> <br><span data-ttu-id="ab1e5-311">Son eşitleme zamanı.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-311">the Last Sync Time.</span></span> |
| <span data-ttu-id="ab1e5-312">*T6*</span><span class="sxs-lookup"><span data-stu-id="ab1e5-312">*T6*</span></span>     |                                                      | <span data-ttu-id="ab1e5-313">İşlem B</span><span class="sxs-lookup"><span data-stu-id="ab1e5-313">Transaction B</span></span><br> <span data-ttu-id="ab1e5-314">Çoğaltılan</span><span class="sxs-lookup"><span data-stu-id="ab1e5-314">replicated to</span></span><br> <span data-ttu-id="ab1e5-315">İkincil</span><span class="sxs-lookup"><span data-stu-id="ab1e5-315">secondary</span></span> | <span data-ttu-id="ab1e5-316">T6</span><span class="sxs-lookup"><span data-stu-id="ab1e5-316">T6</span></span>                 | <span data-ttu-id="ab1e5-317">*T6* – C aracılığıyla tüm işlemlerin</span><span class="sxs-lookup"><span data-stu-id="ab1e5-317">*T6* – All transactions through C have</span></span> <br><span data-ttu-id="ab1e5-318">edilmiş çoğaltılan, son eşitleme zamanı</span><span class="sxs-lookup"><span data-stu-id="ab1e5-318">been replicated, Last Sync Time</span></span><br> <span data-ttu-id="ab1e5-319">güncelleştirilir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-319">is updated.</span></span> |

<span data-ttu-id="ab1e5-320">Bu örnekte, istemci T5 konumunda ikincil bölgesinden okunurken geçer varsayalım.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-320">In this example, assume the client switches to reading from the secondary region at T5.</span></span> <span data-ttu-id="ab1e5-321">Başarıyla okuyabilirsiniz **Yönetici rolü** varlık şu anda, ancak varlık sayısı ile tutarlı değil yöneticiler sayısı için bir değer içeriyorsa **çalışan** şu anda ikincil bölge yöneticileri olarak işaretlenmiş varlıklar.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-321">It can successfully read the **administrator role** entity at this time, but the entity contains a value for the count of administrators that is not consistent with the number of **employee** entities that are marked as administrators in the secondary region at this time.</span></span> <span data-ttu-id="ab1e5-322">İstemci, yalnızca bu değerle tutarsız bilgiler olduğunu risk görüntüleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-322">Your client could simply display this value, with the risk that it is inconsistent information.</span></span> <span data-ttu-id="ab1e5-323">Alternatif olarak, istemci belirleyen yararlanmaya **Yönetici rolü** güncelleştirmeleri sıralama dışında gerçekleşen ve sonra bu olgu kullanıcı bildirmeniz büyük olasılıkla tutarsız bir durumda olduğundan.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-323">Alternatively, the client could attempt to determine that the **administrator role** is in a potentially inconsistent state because the updates have happened out of order, and then inform the user of this fact.</span></span>

<span data-ttu-id="ab1e5-324">Büyük olasılıkla tutarsız veri sahipse, istemci değerini kullanabilir tanımak için *son eşitleme zamanı* herhangi bir anda bir depolama birimi hizmeti sorgulayarak alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-324">To recognize that it has potentially inconsistent data, the client can use the value of the *Last Sync Time* that you can get at any time by querying a storage service.</span></span> <span data-ttu-id="ab1e5-325">Bu, ikincil bölge verilerinde son zaman bildirir tutarlı ve ne zaman hizmeti uygulanan o noktadan önce tüm işlemlerin süre.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-325">This tells you the time when the data in the secondary region was last consistent and when the service had applied all the transactions prior to that point in time.</span></span> <span data-ttu-id="ab1e5-326">Hizmet ekledikten sonra yukarıda gösterilen örnekte **çalışan** ikincil bölge, son eşitleme zamanı varlık ayarlanmış *T1*.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-326">In the example shown above, after the service inserts the **employee** entity in the secondary region, the last sync time is set to *T1*.</span></span> <span data-ttu-id="ab1e5-327">Kalır *T1* hizmet güncelleştirmeleri kadar **çalışan** ayarlandığında ikincil bölge varlık *T6*.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-327">It remains at *T1* until the service updates the **employee** entity in the secondary region when it is set to *T6*.</span></span> <span data-ttu-id="ab1e5-328">İstemci varlıkta, okur, son eşitleme zamanı alır, *T5*, bu varlık üzerinde damgasıyla karşılaştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-328">If the client retrieves the last sync time when it reads the entity at *T5*, it can compare it with the timestamp on the entity.</span></span> <span data-ttu-id="ab1e5-329">Varlık zaman damgasını son eşitleme zamanından daha sonra ise, varlık büyük olasılıkla tutarsız bir durumda ise ve ne olursa olsun, uygulamanız için uygun eylemi gerçekleştirin.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-329">If the timestamp on the entity is later than the last sync time, then the entity is in a potentially inconsistent state, and you can take whatever is the appropriate action for your application.</span></span> <span data-ttu-id="ab1e5-330">Bu alanı kullanarak birincil son güncelleştirmeyi tamamlandığı bilmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-330">Using this field requires that you know when the last update to the primary was completed.</span></span>

## <a name="testing"></a><span data-ttu-id="ab1e5-331">Test Etme</span><span class="sxs-lookup"><span data-stu-id="ab1e5-331">Testing</span></span>

<span data-ttu-id="ab1e5-332">Uygulamanızı yeniden denenebilir hatalarla karşılaştığında beklendiği gibi davranır test etmek önemlidir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-332">It's important to test that your application behaves as expected when it encounters retryable errors.</span></span> <span data-ttu-id="ab1e5-333">Örneğin, birincil bölge yeniden kullanılabilir duruma geldiğinde uygulama ikincil ve bir sorun algılar ve anahtarları salt okunur moduna geçiş yapar, test gerekir.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-333">For example, you need to test that the application switches to the secondary and into read-only mode when it detects a problem, and switches back when the primary region becomes available again.</span></span> <span data-ttu-id="ab1e5-334">Bunu yapmak için yeniden denenebilir hata ve oluşma sıklığını denetim benzetimini yapmak için bir yönteme ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-334">To do this, you need a way to simulate retryable errors and control how often they occur.</span></span>

<span data-ttu-id="ab1e5-335">Kullanabileceğiniz [Fiddler](http://www.telerik.com/fiddler) kesecek ve HTTP yanıtını bir betik içinde değiştirin.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-335">You can use [Fiddler](http://www.telerik.com/fiddler) to intercept and modify HTTP responses in a script.</span></span> <span data-ttu-id="ab1e5-336">Bu komut dosyasını birincil uç noktasından gelen yanıtları tanımlamak ve depolama istemci kitaplığı yeniden denenebilir hata olarak tanıdığı bir HTTP durum kodu değiştirin.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-336">This script can identify responses that come from your primary endpoint and change the HTTP status code to one that the Storage Client Library recognizes as a retryable error.</span></span> <span data-ttu-id="ab1e5-337">Bu kod parçacığını karşı Okunan isteklere yanıt karşılar Fiddler komut basit bir örnek gösterilmektedir **employeedata** tablo 502 durumuna döndürmek için:</span><span class="sxs-lookup"><span data-stu-id="ab1e5-337">This code snippet shows a simple example of a Fiddler script that intercepts responses to read requests against the **employeedata** table to return a 502 status:</span></span>

```java
static function OnBeforeResponse(oSession: Session) {
    ...
    if ((oSession.hostname == "\[yourstorageaccount\].table.core.windows.net")
      && (oSession.PathAndQuery.StartsWith("/employeedata?$filter"))) {
        oSession.responseCode = 502;
    }
}
```

<span data-ttu-id="ab1e5-338">Bu örnek, geniş bir istekleri kesecek ve yalnızca değiştirme genişletebilirsiniz **yanıt kodu** bazı bunları gerçek dünya senaryoları daha iyi benzetmek için.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-338">You could extend this example to intercept a wider range of requests and only change the **responseCode** on some of them to better simulate a real-world scenario.</span></span> <span data-ttu-id="ab1e5-339">Fiddler betikleri özelleştirme hakkında daha fazla bilgi için bkz: [bir istek veya yanıt değiştirme](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) Fiddler belgelerinde.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-339">For more information about customizing Fiddler scripts, see [Modifying a Request or Response](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) in the Fiddler documentation.</span></span>

<span data-ttu-id="ab1e5-340">Salt okunur modda yapılandırılabilir uygulamanıza geçiş yapmak için eşikler yaptıysanız, üretim dışı işlem birimleri ile davranışı test etmek daha kolay olacaktır.</span><span class="sxs-lookup"><span data-stu-id="ab1e5-340">If you have made the thresholds for switching your application to read-only mode configurable, it will be easier to test the behavior with non-production transaction volumes.</span></span>

## <a name="next-steps"></a><span data-ttu-id="ab1e5-341">Sonraki Adımlar</span><span class="sxs-lookup"><span data-stu-id="ab1e5-341">Next Steps</span></span>

* <span data-ttu-id="ab1e5-342">Başka bir örneği LastSyncTime ayarlanma dahil olmak üzere ilgili okuma erişimi coğrafi Yedeklilik daha fazla bilgi için lütfen bkz [Windows Azure Depolama artıklık seçenekleri ve okuma erişimli coğrafi olarak yedekli depolama](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span><span class="sxs-lookup"><span data-stu-id="ab1e5-342">For more information about Read Access Geo-Redundancy, including another example of how the LastSyncTime is set, please see [Windows Azure Storage Redundancy Options and Read Access Geo Redundant Storage](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span></span>

* <span data-ttu-id="ab1e5-343">İleri ve geri birincil ve ikincil uç noktalar arasında geçiş yapmak nasıl gösteren tam bir örnek için lütfen bkz. [devre kesici desen ile RA-GRS depolama kullanan Azure örnekler –](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span><span class="sxs-lookup"><span data-stu-id="ab1e5-343">For a complete sample showing how to make the switch back and forth between the Primary and Secondary endpoints, please see [Azure Samples – Using the Circuit Breaker Pattern with RA-GRS storage](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span></span>
