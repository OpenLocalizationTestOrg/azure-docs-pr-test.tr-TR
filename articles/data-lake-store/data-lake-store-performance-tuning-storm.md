---
title: "Azure Data Lake Store Storm performans yönergeleri ayarlama | Microsoft Docs"
description: "Azure Data Lake Store Storm performans kuralları ayarlama"
services: data-lake-store
documentationcenter: 
author: stewu
manager: amitkul
editor: stewu
ms.assetid: ebde7b9f-2e51-4d43-b7ab-566417221335
ms.service: data-lake-store
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: big-data
ms.date: 12/19/2016
ms.author: stewu
ms.openlocfilehash: 1dfa93643f45a96ded3fd022aa8b1c71d487acb4
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/11/2017
---
# <a name="performance-tuning-guidance-for-storm-on-hdinsight-and-azure-data-lake-store"></a><span data-ttu-id="51d38-103">Performans Kılavuzu Hdınsight ve Azure Data Lake Store üzerinde Storm için ayarlama</span><span class="sxs-lookup"><span data-stu-id="51d38-103">Performance tuning guidance for Storm on HDInsight and Azure Data Lake Store</span></span>

<span data-ttu-id="51d38-104">Bir Azure Storm topolojisinin performansı ayarlamak zaman düşünülmesi gereken faktörler anlayın.</span><span class="sxs-lookup"><span data-stu-id="51d38-104">Understand the factors that should be considered when you tune the performance of an Azure Storm topology.</span></span> <span data-ttu-id="51d38-105">Örneğin, spout'lar ve (iş g/ç yoğun olup) Cıvatalar tarafından yapılan iş özelliklerini anlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="51d38-105">For example, it's important to understand the characteristics of the work done by the spouts and the bolts (whether the work is I/O or memory intensive).</span></span> <span data-ttu-id="51d38-106">Bu makalede, performans ayarlama yönergeleri, ortak sorunları da dahil olmak üzere çeşitli yer almaktadır.</span><span class="sxs-lookup"><span data-stu-id="51d38-106">This article covers a range of performance tuning guidelines, including troubleshooting common issues.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="51d38-107">Ön koşullar</span><span class="sxs-lookup"><span data-stu-id="51d38-107">Prerequisites</span></span>

* <span data-ttu-id="51d38-108">**Bir Azure aboneliği**.</span><span class="sxs-lookup"><span data-stu-id="51d38-108">**An Azure subscription**.</span></span> <span data-ttu-id="51d38-109">Bkz. [Azure ücretsiz deneme sürümü alma](https://azure.microsoft.com/pricing/free-trial/).</span><span class="sxs-lookup"><span data-stu-id="51d38-109">See [Get Azure free trial](https://azure.microsoft.com/pricing/free-trial/).</span></span>
* <span data-ttu-id="51d38-110">**Bir Azure Data Lake Store hesabı**.</span><span class="sxs-lookup"><span data-stu-id="51d38-110">**An Azure Data Lake Store account**.</span></span> <span data-ttu-id="51d38-111">Bir oluşturma hakkında yönergeler için bkz: [Azure Data Lake Store ile çalışmaya başlama](data-lake-store-get-started-portal.md).</span><span class="sxs-lookup"><span data-stu-id="51d38-111">For instructions on how to create one, see [Get started with Azure Data Lake Store](data-lake-store-get-started-portal.md).</span></span>
* <span data-ttu-id="51d38-112">**Azure Hdınsight kümesi** bir Data Lake Store hesabına erişim.</span><span class="sxs-lookup"><span data-stu-id="51d38-112">**An Azure HDInsight cluster** with access to a Data Lake Store account.</span></span> <span data-ttu-id="51d38-113">Bkz: [Data Lake Store ile bir Hdınsight kümesi oluşturmayı](data-lake-store-hdinsight-hadoop-use-portal.md).</span><span class="sxs-lookup"><span data-stu-id="51d38-113">See [Create an HDInsight cluster with Data Lake Store](data-lake-store-hdinsight-hadoop-use-portal.md).</span></span> <span data-ttu-id="51d38-114">Küme için Uzak Masaüstü etkinleştirdiğinizden emin olun.</span><span class="sxs-lookup"><span data-stu-id="51d38-114">Make sure you enable Remote Desktop for the cluster.</span></span>
* <span data-ttu-id="51d38-115">**Data Lake Store üzerinde Storm kümesi çalıştıran**.</span><span class="sxs-lookup"><span data-stu-id="51d38-115">**Running a Storm cluster on Data Lake Store**.</span></span> <span data-ttu-id="51d38-116">Daha fazla bilgi için bkz: [Hdınsight üzerinde Storm](https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-storm-overview).</span><span class="sxs-lookup"><span data-stu-id="51d38-116">For more information, see [Storm on HDInsight](https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-storm-overview).</span></span>
* <span data-ttu-id="51d38-117">**Performans ayarlama yönergeleri Data Lake Store üzerinde**.</span><span class="sxs-lookup"><span data-stu-id="51d38-117">**Performance tuning guidelines on Data Lake Store**.</span></span>  <span data-ttu-id="51d38-118">Genel performans için bkz [Data Lake deposu performans ayarlama Kılavuzu](https://docs.microsoft.com/en-us/azure/data-lake-store/data-lake-store-performance-tuning-guidance).</span><span class="sxs-lookup"><span data-stu-id="51d38-118">For general performance concepts, see [Data Lake Store Performance Tuning Guidance](https://docs.microsoft.com/en-us/azure/data-lake-store/data-lake-store-performance-tuning-guidance).</span></span>  

## <a name="tune-the-parallelism-of-the-topology"></a><span data-ttu-id="51d38-119">Topoloji paralellik ayarlama</span><span class="sxs-lookup"><span data-stu-id="51d38-119">Tune the parallelism of the topology</span></span>

<span data-ttu-id="51d38-120">G/ç için ve Data Lake Store eşzamanlılığı artırarak performansı mümkün olabilir.</span><span class="sxs-lookup"><span data-stu-id="51d38-120">You might be able to improve performance by increasing the concurrency of the I/O to and from Data Lake Store.</span></span> <span data-ttu-id="51d38-121">Bir Storm topolojisinin paralellik belirlemek yapılandırmaları kümesi vardır:</span><span class="sxs-lookup"><span data-stu-id="51d38-121">A Storm topology has a set of configurations that determine the parallelism:</span></span>
* <span data-ttu-id="51d38-122">(VM'ler üzerindeki çalışanları olacak şekilde eşit dağıtılır) çalışan işlem sayısı.</span><span class="sxs-lookup"><span data-stu-id="51d38-122">Number of worker processes (the workers are evenly distributed across the VMs).</span></span>
* <span data-ttu-id="51d38-123">Spout Yürütücü örneği sayısı.</span><span class="sxs-lookup"><span data-stu-id="51d38-123">Number of spout executor instances.</span></span>
* <span data-ttu-id="51d38-124">Cıvata Yürütücü örneği sayısı.</span><span class="sxs-lookup"><span data-stu-id="51d38-124">Number of bolt executor instances.</span></span>
* <span data-ttu-id="51d38-125">Spout görev sayısı.</span><span class="sxs-lookup"><span data-stu-id="51d38-125">Number of spout tasks.</span></span>
* <span data-ttu-id="51d38-126">Cıvata görev sayısı.</span><span class="sxs-lookup"><span data-stu-id="51d38-126">Number of bolt tasks.</span></span>

<span data-ttu-id="51d38-127">Örneğin, 4 VM'ler ve 4 çalışan işlemleri, 32 spout yürütücüler 32 spout görevleri ve 256 Cıvata yürütücüler ve 512 Cıvata görevleri ile bir kümede aşağıdakileri dikkate alın:</span><span class="sxs-lookup"><span data-stu-id="51d38-127">For example, on a cluster with 4 VMs and 4 worker processes, 32 spout executors and 32 spout tasks, and 256 bolt executors and 512 bolt tasks, consider the following:</span></span>

<span data-ttu-id="51d38-128">Çalışan düğümüne olan her yönetici tek bir çalışan Java sanal makine (JVM) işlemi vardır.</span><span class="sxs-lookup"><span data-stu-id="51d38-128">Each supervisor, which is a worker node, has a single worker Java virtual machine (JVM) process.</span></span> <span data-ttu-id="51d38-129">Bu JVM işlem 4 spout iş parçacıkları ve 64 Cıvata iş parçacığı yönetir.</span><span class="sxs-lookup"><span data-stu-id="51d38-129">This JVM process manages 4 spout threads and 64 bolt threads.</span></span> <span data-ttu-id="51d38-130">Her iş parçacığı içinde görevleri sırayla çalışır.</span><span class="sxs-lookup"><span data-stu-id="51d38-130">Within each thread, tasks are run sequentially.</span></span> <span data-ttu-id="51d38-131">Önceki yapılandırmayla 1 görev her spout iş parçacığı vardır ve 2 görevleri her Cıvata iş parçacığı vardır.</span><span class="sxs-lookup"><span data-stu-id="51d38-131">With the preceding configuration, each spout thread has 1 task, and each bolt thread has 2 tasks.</span></span>

<span data-ttu-id="51d38-132">Storm, söz konusu çeşitli bileşenleri şunlardır ve sahip olduğunuz paralellik düzeyini nasıl etkilediklerini:</span><span class="sxs-lookup"><span data-stu-id="51d38-132">In Storm, here are the various components involved, and how they affect the level of parallelism you have:</span></span>
* <span data-ttu-id="51d38-133">(Nimbus Storm denir) baş düğümü göndermek ve işlerini yönetmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="51d38-133">The head node (called Nimbus in Storm) is used to submit and manage jobs.</span></span> <span data-ttu-id="51d38-134">Bu düğümler paralellik derecesini bir etkisi yoktur.</span><span class="sxs-lookup"><span data-stu-id="51d38-134">These nodes have no impact on the degree of parallelism.</span></span>
* <span data-ttu-id="51d38-135">Yönetici düğümleri.</span><span class="sxs-lookup"><span data-stu-id="51d38-135">The supervisor nodes.</span></span> <span data-ttu-id="51d38-136">Hdınsight'ta, bu çalışan düğümüne Azure VM karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="51d38-136">In HDInsight, this corresponds to a worker node Azure VM.</span></span>
* <span data-ttu-id="51d38-137">Vm'lerde çalışan Storm işlemler çalışan görevlerdir.</span><span class="sxs-lookup"><span data-stu-id="51d38-137">The worker tasks are Storm processes running in the VMs.</span></span> <span data-ttu-id="51d38-138">Her çalışan görev JVM örneğine karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="51d38-138">Each worker task corresponds to a JVM instance.</span></span> <span data-ttu-id="51d38-139">Storm çalışan düğümlerine mümkün olduğunca eşit belirttiğiniz çalışan işlem sayısı dağıtır.</span><span class="sxs-lookup"><span data-stu-id="51d38-139">Storm distributes the number of worker processes you specify to the worker nodes as evenly as possible.</span></span>
* <span data-ttu-id="51d38-140">Spout ve yürütücü örnekleri Cıvata.</span><span class="sxs-lookup"><span data-stu-id="51d38-140">Spout and bolt executor instances.</span></span> <span data-ttu-id="51d38-141">Her bir yürütücü örneği çalışanları (JVMs) içinde çalışan iş parçacığı karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="51d38-141">Each executor instance corresponds to a thread running within the workers (JVMs).</span></span>
* <span data-ttu-id="51d38-142">Storm görevler.</span><span class="sxs-lookup"><span data-stu-id="51d38-142">Storm tasks.</span></span> <span data-ttu-id="51d38-143">Bunların her birini Çalıştır iş parçacıkları mantıksal görevlerdir.</span><span class="sxs-lookup"><span data-stu-id="51d38-143">These are logical tasks that each of these threads run.</span></span> <span data-ttu-id="51d38-144">Yürütücü başına birden çok görev veya gerekiyorsa değerlendirmelidir şekilde bu paralellik, düzeyini değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="51d38-144">This does not change the level of parallelism, so you should evaluate if you need multiple tasks per executor or not.</span></span>

### <a name="get-the-best-performance-from-data-lake-store"></a><span data-ttu-id="51d38-145">Data Lake Deposu'ndan veri en iyi performansı elde</span><span class="sxs-lookup"><span data-stu-id="51d38-145">Get the best performance from Data Lake Store</span></span>

<span data-ttu-id="51d38-146">Aşağıdakileri, Data Lake Store ile çalışırken en iyi performansı elde:</span><span class="sxs-lookup"><span data-stu-id="51d38-146">When working with Data Lake Store, you get the best performance if you do the following:</span></span>
* <span data-ttu-id="51d38-147">Birleşim küçük ve büyük boyutları (İdeal olarak 4 MB) ekler.</span><span class="sxs-lookup"><span data-stu-id="51d38-147">Coalesce your small appends into larger sizes (ideally 4 MB).</span></span>
* <span data-ttu-id="51d38-148">Mümkün olduğu kadar eşzamanlı istek yapın.</span><span class="sxs-lookup"><span data-stu-id="51d38-148">Do as many concurrent requests as you can.</span></span> <span data-ttu-id="51d38-149">Her Cıvata iş parçacığı engelleme okuma yapmak için herhangi bir yerde çekirdek başına 8-12 iş parçacığı aralığında istiyorsanız.</span><span class="sxs-lookup"><span data-stu-id="51d38-149">Because each bolt thread is doing blocking reads, you want to have somewhere in the range of 8-12 threads per core.</span></span> <span data-ttu-id="51d38-150">Bu, NIC ve iyi kullanılan CPU tutar.</span><span class="sxs-lookup"><span data-stu-id="51d38-150">This keeps the NIC and the CPU well utilized.</span></span> <span data-ttu-id="51d38-151">Daha büyük bir VM daha fazla istek sağlar.</span><span class="sxs-lookup"><span data-stu-id="51d38-151">A larger VM enables more concurrent requests.</span></span>  

### <a name="example-topology"></a><span data-ttu-id="51d38-152">Örnek topoloji</span><span class="sxs-lookup"><span data-stu-id="51d38-152">Example topology</span></span>

<span data-ttu-id="51d38-153">Bir 8 çalışan düğümü küme D13v2 Azure VM ile sahip varsayalım.</span><span class="sxs-lookup"><span data-stu-id="51d38-153">Let’s assume you have an 8 worker node cluster with a D13v2 Azure VM.</span></span> <span data-ttu-id="51d38-154">Bu VM 8 sahip Çekirdek nedenle 8 çalışan düğümleri arasında 64 toplam çekirdeğe sahip.</span><span class="sxs-lookup"><span data-stu-id="51d38-154">This VM has 8 cores, so among the 8 worker nodes, you have 64 total cores.</span></span>

<span data-ttu-id="51d38-155">Biz çekirdek başına 8 Cıvata iş parçacığı yapmak varsayalım.</span><span class="sxs-lookup"><span data-stu-id="51d38-155">Let’s say we do 8 bolt threads per core.</span></span> <span data-ttu-id="51d38-156">64 çekirdek, 512 toplam Cıvata Yürütücü örnekleri (diğer bir deyişle, iş parçacıkları) istiyoruz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="51d38-156">Given 64 cores, that means we want 512 total bolt executor instances (that is, threads).</span></span> <span data-ttu-id="51d38-157">Bu durumda, biz VM başına bir JVM başlayın ve çoğunlukla eşzamanlılık elde etmek için iş parçacığı eşzamanlılık JVM içinde kullanmak varsayalım.</span><span class="sxs-lookup"><span data-stu-id="51d38-157">In this case, let’s say we start with one JVM per VM, and mainly use the thread concurrency within the JVM to achieve concurrency.</span></span> <span data-ttu-id="51d38-158">8 çalışan görevler (Azure VM başına bir tane) ve 512 Cıvata yürütücüler ihtiyacımız anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="51d38-158">That means we need 8 worker tasks (one per Azure VM), and 512 bolt executors.</span></span> <span data-ttu-id="51d38-159">Bu yapılandırma verildiğinde, her bir çalışan düğümünün 1 vermiş çalışanları çalışan düğümleri (olarak da bilinen yönetici düğümler), arasında eşit olarak dağıtmak Storm çalışır JVM.</span><span class="sxs-lookup"><span data-stu-id="51d38-159">Given this configuration, Storm tries to distribute the workers evenly across worker nodes (also known as supervisor nodes), giving each worker node 1 JVM.</span></span> <span data-ttu-id="51d38-160">Yürütücüler denetçiler arasında eşit olarak dağıtmak Storm denetçiler içinde çalışır artık her yönetici (diğer bir deyişle, JVM) vermiş 8 her iş parçacıkları.</span><span class="sxs-lookup"><span data-stu-id="51d38-160">Now within the supervisors, Storm tries to distribute the executors evenly between supervisors, giving each supervisor (that is, JVM) 8 threads each.</span></span>

## <a name="tune-additional-parameters"></a><span data-ttu-id="51d38-161">Ek parametrelerini ayarlama</span><span class="sxs-lookup"><span data-stu-id="51d38-161">Tune additional parameters</span></span>
<span data-ttu-id="51d38-162">Temel topoloji aldıktan sonra parametrelerinden herhangi birini ince ayar isteyip istemediğinizi düşünebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="51d38-162">After you have the basic topology, you can consider whether you want to tweak any of the parameters:</span></span>
* <span data-ttu-id="51d38-163">**Çalışan düğüm başına JVMs sayısı.**</span><span class="sxs-lookup"><span data-stu-id="51d38-163">**Number of JVMs per worker node.**</span></span> <span data-ttu-id="51d38-164">Büyük veri yapısı (örneğin, bir arama tablosu) varsa, barındıran bellekte her JVM ayrı bir kopyasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="51d38-164">If you have a large data structure (for example, a lookup table) that you host in memory, each JVM requires a separate copy.</span></span> <span data-ttu-id="51d38-165">Alternatif olarak, daha az JVMs varsa birçok iş parçacıkları arasında veri yapısı kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="51d38-165">Alternatively, you can use the data structure across many threads if you have fewer JVMs.</span></span> <span data-ttu-id="51d38-166">Cıvata 's g/ç JVMs sayısı kadar bu JVMs eklenen iş parçacığı sayısı olarak farkının yapmaz.</span><span class="sxs-lookup"><span data-stu-id="51d38-166">For the bolt’s I/O, the number of JVMs does not make as much of a difference as the number of threads added across those JVMs.</span></span> <span data-ttu-id="51d38-167">Kolaylık olması için çalışan her bir JVM sağlamak için bir fikirdir.</span><span class="sxs-lookup"><span data-stu-id="51d38-167">For simplicity, it's a good idea to have one JVM per worker.</span></span> <span data-ttu-id="51d38-168">Bu numarayı değiştirmeniz gerekebilir rağmen Cıvata yaptıklarını veya hangi uygulama, işleme bağlı olarak, gerektirir.</span><span class="sxs-lookup"><span data-stu-id="51d38-168">Depending on what your bolt is doing or what application processing you require, though, you may need to change this number.</span></span>
* <span data-ttu-id="51d38-169">**Spout yürütücüler sayısı.**</span><span class="sxs-lookup"><span data-stu-id="51d38-169">**Number of spout executors.**</span></span> <span data-ttu-id="51d38-170">Önceki örnekte, Data Lake Store'a yazmak için Cıvatalar kullandığından, spout'lar sayısı Cıvata performansı doğrudan ilgili değildir.</span><span class="sxs-lookup"><span data-stu-id="51d38-170">Because the preceding example uses bolts for writing to Data Lake Store, the number of spouts is not directly relevant to the bolt performance.</span></span> <span data-ttu-id="51d38-171">Ancak, işleme veya spout gerçekleştiği g/ç miktarına bağlı olarak, en iyi performans için spout'lar ayarlamak için iyi bir fikir değil.</span><span class="sxs-lookup"><span data-stu-id="51d38-171">However, depending on the amount of processing or I/O happening in the spout, it's a good idea to tune the spouts for best performance.</span></span> <span data-ttu-id="51d38-172">Cıvatalar meşgul devam edebilmek için yeterli spout'lar olduğundan emin olun.</span><span class="sxs-lookup"><span data-stu-id="51d38-172">Ensure that you have enough spouts to be able to keep the bolts busy.</span></span> <span data-ttu-id="51d38-173">Spout'lar çıkış oranlarda Cıvatalar verimini eşleşmelidir.</span><span class="sxs-lookup"><span data-stu-id="51d38-173">The output rates of the spouts should match the throughput of the bolts.</span></span> <span data-ttu-id="51d38-174">Spout üzerinde gerçek yapılandırmasına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="51d38-174">The actual configuration depends on the spout.</span></span>
* <span data-ttu-id="51d38-175">**Görev sayısı.**</span><span class="sxs-lookup"><span data-stu-id="51d38-175">**Number of tasks.**</span></span> <span data-ttu-id="51d38-176">Her Cıvata tek bir iş parçacığı çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="51d38-176">Each bolt runs as a single thread.</span></span> <span data-ttu-id="51d38-177">Ek görevler Cıvata başına herhangi bir ek eşzamanlılık sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="51d38-177">Additional tasks per bolt don't provide any additional concurrency.</span></span> <span data-ttu-id="51d38-178">Tuple aktarımının, işlemi Cıvata yürütme süresi büyük bir kısmının alır, yararı oldukları yalnızca zamanı gelmiştir.</span><span class="sxs-lookup"><span data-stu-id="51d38-178">The only time they are of benefit is if your process of acknowledging the tuple takes a large proportion of your bolt execution time.</span></span> <span data-ttu-id="51d38-179">Bu Cıvata onay göndermeden önce birçok başlıkları daha geniş bir içine ekleme bir gruba fikirdir.</span><span class="sxs-lookup"><span data-stu-id="51d38-179">It's a good idea to group many tuples into a larger append before you send an acknowledgement from the bolt.</span></span> <span data-ttu-id="51d38-180">Bu nedenle, çoğu durumda, birden çok görevler ek fayda sağlar.</span><span class="sxs-lookup"><span data-stu-id="51d38-180">So, in most cases, multiple tasks provide no additional benefit.</span></span>
* <span data-ttu-id="51d38-181">**Yerel veya karışık gruplandırma.**</span><span class="sxs-lookup"><span data-stu-id="51d38-181">**Local or shuffle grouping.**</span></span> <span data-ttu-id="51d38-182">Bu ayar etkinleştirildiğinde, tanımlama grupları aynı çalışan işlemi içinde Cıvatalar gönderilir.</span><span class="sxs-lookup"><span data-stu-id="51d38-182">When this setting is enabled, tuples are sent to bolts within the same worker process.</span></span> <span data-ttu-id="51d38-183">Bu işlemler arası iletişim ve ağ çağrıları azaltır.</span><span class="sxs-lookup"><span data-stu-id="51d38-183">This reduces inter-process communication and network calls.</span></span> <span data-ttu-id="51d38-184">Bu, çoğu Topolojileri için önerilir.</span><span class="sxs-lookup"><span data-stu-id="51d38-184">This is recommended for most topologies.</span></span>

<span data-ttu-id="51d38-185">Bu temel senaryo iyi bir başlangıç noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="51d38-185">This basic scenario is a good starting point.</span></span> <span data-ttu-id="51d38-186">En iyi performans elde etmek için önceki parametreleri ince ayar yapma kendi verilerinizle sınayın.</span><span class="sxs-lookup"><span data-stu-id="51d38-186">Test with your own data to tweak the preceding parameters to achieve optimal performance.</span></span>

## <a name="tune-the-spout"></a><span data-ttu-id="51d38-187">Spout ayarlama</span><span class="sxs-lookup"><span data-stu-id="51d38-187">Tune the spout</span></span>

<span data-ttu-id="51d38-188">Spout ayarlamak için aşağıdaki ayarları değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="51d38-188">You can modify the following settings to tune the spout.</span></span>

- <span data-ttu-id="51d38-189">**Tuple zaman aşımı: topology.message.timeout.secs**.</span><span class="sxs-lookup"><span data-stu-id="51d38-189">**Tuple timeout: topology.message.timeout.secs**.</span></span> <span data-ttu-id="51d38-190">Bu ayarı tamamlamak ve onay, almak için bir ileti gereken süre miktarını belirler başarısız kabul edilmeden önce.</span><span class="sxs-lookup"><span data-stu-id="51d38-190">This setting determines the amount of time a message takes to complete, and receive acknowledgement, before it is considered failed.</span></span>

- <span data-ttu-id="51d38-191">**Çalışan işlemi başına maksimum bellek: worker.childopts**.</span><span class="sxs-lookup"><span data-stu-id="51d38-191">**Max memory per worker process: worker.childopts**.</span></span> <span data-ttu-id="51d38-192">Bu ayar Java çalışanları için ek komut satırı parametreleri belirtmenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="51d38-192">This setting lets you specify additional command-line parameters to the Java workers.</span></span> <span data-ttu-id="51d38-193">En yaygın kullanılan ayar burada JVM'ın yığın için ayrılan maksimum bellek belirler XmX'dir.</span><span class="sxs-lookup"><span data-stu-id="51d38-193">The most commonly used setting here is XmX, which determines the maximum memory allocated to a JVM’s heap.</span></span>

- <span data-ttu-id="51d38-194">**Max spout bekleyen: topology.max.spout.pending**.</span><span class="sxs-lookup"><span data-stu-id="51d38-194">**Max spout pending: topology.max.spout.pending**.</span></span> <span data-ttu-id="51d38-195">Bu ayar (henüz onaylanan da topolojideki tüm düğümlerde) uçuş spout iş parçacığı başına herhangi bir zamanda buna olabilir başlıkların sayısını belirler.</span><span class="sxs-lookup"><span data-stu-id="51d38-195">This setting determines the number of tuples that can in be flight (not yet acknowledged at all nodes in the topology) per spout thread at any time.</span></span>

 <span data-ttu-id="51d38-196">Yapmak için iyi bir hesaplama her, başlık boyutunu tahmin etmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="51d38-196">A good calculation to do is to estimate the size of each of your tuples.</span></span> <span data-ttu-id="51d38-197">Sonra ne kadar bellek bir spout iş parçacığı olduğunu göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="51d38-197">Then figure out how much memory one spout thread has.</span></span> <span data-ttu-id="51d38-198">Bu değer ile ayrılmış bir iş parçacığı için ayrılan toplam bellek parametresi bekleyen max spout için üst sınır vermesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="51d38-198">The total memory allocated to a thread, divided by this value, should give you the upper bound for the max spout pending parameter.</span></span>

## <a name="tune-the-bolt"></a><span data-ttu-id="51d38-199">Cıvata ayarlama</span><span class="sxs-lookup"><span data-stu-id="51d38-199">Tune the bolt</span></span>
<span data-ttu-id="51d38-200">Data Lake Store'a yazarken boyutu eşitleme ilkesi (istemci tarafı arabelleği) 4 MB olarak ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="51d38-200">When you're writing to Data Lake Store, set a size sync policy (buffer on the client side) to 4 MB.</span></span> <span data-ttu-id="51d38-201">Arabellek boyutu olduğunda bir temizleme veya hsync() sonra gerçekleştirilen bu değerde.</span><span class="sxs-lookup"><span data-stu-id="51d38-201">A flushing or hsync() is then performed only when the buffer size is the at this value.</span></span> <span data-ttu-id="51d38-202">Açıkça bir hsync() gerçekleştirmediğiniz sürece çalışan VM Data Lake Store sürücüsünde bu arabelleğe alma, otomatik olarak yapar.</span><span class="sxs-lookup"><span data-stu-id="51d38-202">The Data Lake Store driver on the worker VM automatically does this buffering, unless you explicitly perform an hsync().</span></span>

<span data-ttu-id="51d38-203">Varsayılan Data Lake deposu Storm Cıvata bu parametreyi ayarlamak için kullanılan bir boyutu eşitleme ilkesi parametre (fileBufferSize) içeriyor.</span><span class="sxs-lookup"><span data-stu-id="51d38-203">The default Data Lake Store Storm bolt has a size sync policy parameter (fileBufferSize) that can be used to tune this parameter.</span></span>

<span data-ttu-id="51d38-204">G/Ç kullanımı yoğun topolojide kendi dosyasına yazma her Cıvata iş parçacığı vardır ve bir dosya döndürme İlkesi (fileRotationSize) ayarlamak için iyi bir fikir değil.</span><span class="sxs-lookup"><span data-stu-id="51d38-204">In I/O-intensive topologies, it's a good idea to have each bolt thread write to its own file, and to set a file rotation policy (fileRotationSize).</span></span> <span data-ttu-id="51d38-205">Dosya belirli bir boyuta ulaştığında, akış otomatik olarak Temizlenen ve yeni bir dosya yazılır.</span><span class="sxs-lookup"><span data-stu-id="51d38-205">When the file reaches a certain size, the stream is automatically flushed and a new file is written to.</span></span> <span data-ttu-id="51d38-206">Döndürme için önerilen dosya boyutu 1 GB'tır.</span><span class="sxs-lookup"><span data-stu-id="51d38-206">The recommended file size for rotation is 1 GB.</span></span>

### <a name="handle-tuple-data"></a><span data-ttu-id="51d38-207">Tuple veri işleme</span><span class="sxs-lookup"><span data-stu-id="51d38-207">Handle tuple data</span></span>

<span data-ttu-id="51d38-208">Açıkça Cıvata tarafından onaylanan kadar Storm bir spout bir tanımlama grubu tutan.</span><span class="sxs-lookup"><span data-stu-id="51d38-208">In Storm, a spout holds on to a tuple until it is explicitly acknowledged by the bolt.</span></span> <span data-ttu-id="51d38-209">Bir tanımlama grubu Cıvata tarafından okunabilir ancak henüz onaylanan değil, Data Lake Store arka uç spout kalıcı.</span><span class="sxs-lookup"><span data-stu-id="51d38-209">If a tuple has been read by the bolt but has not been acknowledged yet, the spout might not have persisted into Data Lake Store back end.</span></span> <span data-ttu-id="51d38-210">Bir tanımlama grubu kabul edildikten sonra spout Cıvata tarafından Kalıcılık güvence altına alınabilir ve veri kaynağını içinden okuma ne olursa olsun kaynağından sonra silebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="51d38-210">After a tuple is acknowledged, the spout can be guaranteed persistence by the bolt, and can then delete the source data from whatever source it is reading from.</span></span>  

<span data-ttu-id="51d38-211">Data Lake Store üzerinde en iyi performans için Cıvata sahip 4 MB tanımlama grubu veri arabellek.</span><span class="sxs-lookup"><span data-stu-id="51d38-211">For best performance on Data Lake Store, have the bolt buffer 4 MB of tuple data.</span></span> <span data-ttu-id="51d38-212">Ardından Data Lake Store'a geri son bir 4 MB yazma.</span><span class="sxs-lookup"><span data-stu-id="51d38-212">Then write to the Data Lake Store back end as one 4-MB write.</span></span> <span data-ttu-id="51d38-213">Veri deposuna başarıyla yazıldıktan sonra (arama hflush()) tarafından Cıvata veri spout kabul.</span><span class="sxs-lookup"><span data-stu-id="51d38-213">After the data has been successfully written to the store (by calling hflush()), the bolt can acknowledge the data back to the spout.</span></span> <span data-ttu-id="51d38-214">Burada sağlanan örnek Cıvata yaptığı budur.</span><span class="sxs-lookup"><span data-stu-id="51d38-214">This is what the example bolt supplied here does.</span></span> <span data-ttu-id="51d38-215">Çok sayıda hflush() çağrısı yapılmadan önce tanımlama grupları ve onaylanan diziler tutmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="51d38-215">It is also acceptable to hold a larger number of tuples before the hflush() call is made and the tuples acknowledged.</span></span> <span data-ttu-id="51d38-216">Ancak, bu tutmak spout gerekir ve bu nedenle, bellek miktarı arttıkça JVM gerekir yürütülen başlıkların sayısını artırır.</span><span class="sxs-lookup"><span data-stu-id="51d38-216">However, this increases the number of tuples in flight that the spout needs to hold, and therefore increases the amount of memory required per JVM.</span></span>

> [!NOTE]
<span data-ttu-id="51d38-217">Uygulamalar, diziler daha sık (adresindeki veri boyutları MB'den küçük 4) diğer olmayan performans nedenleriyle onaylamak için bir gereksinim olabilir.</span><span class="sxs-lookup"><span data-stu-id="51d38-217">Applications might have a requirement to acknowledge tuples more frequently (at data sizes less than 4 MB) for other non-performance reasons.</span></span> <span data-ttu-id="51d38-218">Ancak, depolama arka ucu için g/ç işleme etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="51d38-218">However, that might affect the I/O throughput to the storage back end.</span></span> <span data-ttu-id="51d38-219">Bu kolaylığını Cıvata 's g/ç performansı karşı dikkatle tartmanız.</span><span class="sxs-lookup"><span data-stu-id="51d38-219">Carefully weigh this tradeoff against the bolt’s I/O performance.</span></span>

<span data-ttu-id="51d38-220">4 MB arabelleği doldurmak için uzun süren şekilde diziler Geliş hızından değil, yüksekse, bu azaltıcı göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="51d38-220">If the incoming rate of tuples is not high, so the 4-MB buffer takes a long time to fill, consider mitigating this by:</span></span>
* <span data-ttu-id="51d38-221">Cıvatalar sayısının azaltılması, bu nedenle vardır doldurmak için daha az arabellek.</span><span class="sxs-lookup"><span data-stu-id="51d38-221">Reducing the number of bolts, so there are fewer buffers to fill.</span></span>
* <span data-ttu-id="51d38-222">Bir hflush() olduğu bir saat veya sayısı tabanlı ilke sahip her Boşaltılma x veya her y milisaniye tetiklenir ve o ana kadarki birikmiş başlıklar geri onaylanır.</span><span class="sxs-lookup"><span data-stu-id="51d38-222">Having a time-based or count-based policy, where an hflush() is triggered every x flushes or every y milliseconds, and the tuples accumulated so far are acknowledged back.</span></span>

<span data-ttu-id="51d38-223">Verimlilik bu durumda düşüktür, ancak olayları yavaş oranı ile en yüksek verimlilik büyük hedefi yine de değil unutmayın.</span><span class="sxs-lookup"><span data-stu-id="51d38-223">Note that the throughput in this case is lower, but with a slow rate of events, maximum throughput is not the biggest objective anyway.</span></span> <span data-ttu-id="51d38-224">Bu Azaltıcı Etkenler deposuna akışına bir tanımlama grubu geçen toplam süreyi azaltmak yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="51d38-224">These mitigations help you reduce the total time that it takes for a tuple to flow through to the store.</span></span> <span data-ttu-id="51d38-225">Düşük olay hızı bile ile gerçek zamanlı bir işlem hattı istiyorsanız bu önemli.</span><span class="sxs-lookup"><span data-stu-id="51d38-225">This might matter if you want a real-time pipeline even with a low event rate.</span></span> <span data-ttu-id="51d38-226">Ayrıca, gelen tanımlama grubu hızı düşükse, bunlar alma sırasında zaman aşımı başlıklar olmayan şekilde, topology.message.timeout_secs parametresi olarak ayarlaması gerektiğini unutmayın arabelleğe veya işlenen.</span><span class="sxs-lookup"><span data-stu-id="51d38-226">Also note that if your incoming tuple rate is low, you should adjust the topology.message.timeout_secs parameter, so the tuples don’t time out while they are getting buffered or processed.</span></span>

## <a name="monitor-your-topology-in-storm"></a><span data-ttu-id="51d38-227">Topolojiniz Storm içindeki izleme</span><span class="sxs-lookup"><span data-stu-id="51d38-227">Monitor your topology in Storm</span></span>  
<span data-ttu-id="51d38-228">Topolojiniz çalışıyorken Storm kullanıcı arabiriminde izleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="51d38-228">While your topology is running, you can monitor it in the Storm user interface.</span></span> <span data-ttu-id="51d38-229">Bakmak için ana Parametreler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="51d38-229">Here are the main parameters to look at:</span></span>

* <span data-ttu-id="51d38-230">**Toplam işlem yürütme gecikme süresi.**</span><span class="sxs-lookup"><span data-stu-id="51d38-230">**Total process execution latency.**</span></span> <span data-ttu-id="51d38-231">Bir tanımlama grubu spout'un yayılan Cıvata tarafından işlenir ve onaylanan için geçen ortalama süreyi budur.</span><span class="sxs-lookup"><span data-stu-id="51d38-231">This is the average time one tuple takes to be emitted by the spout, processed by the bolt, and acknowledged.</span></span>

* <span data-ttu-id="51d38-232">**Toplam Cıvata işlem gecikme süresi.**</span><span class="sxs-lookup"><span data-stu-id="51d38-232">**Total bolt process latency.**</span></span> <span data-ttu-id="51d38-233">Bir bildirim alıncaya kadar Cıvata konumunda yer alan tanımlama grubu tarafından harcanan ortalama süre budur.</span><span class="sxs-lookup"><span data-stu-id="51d38-233">This is the average time spent by the tuple at the bolt until it receives an acknowledgement.</span></span>

* <span data-ttu-id="51d38-234">**Toplam Cıvata gecikme yürütün.**</span><span class="sxs-lookup"><span data-stu-id="51d38-234">**Total bolt execute latency.**</span></span> <span data-ttu-id="51d38-235">Execute yöntemi Cıvata tarafından harcanan ortalama süre budur.</span><span class="sxs-lookup"><span data-stu-id="51d38-235">This is the average time spent by the bolt in the execute method.</span></span>

* <span data-ttu-id="51d38-236">**Başarısızlık sayısı.**</span><span class="sxs-lookup"><span data-stu-id="51d38-236">**Number of failures.**</span></span> <span data-ttu-id="51d38-237">Bu, zaman aşımına uğramadan önce tam olarak işlenmesi başarısız oldu başlıkların sayısını ifade eder.</span><span class="sxs-lookup"><span data-stu-id="51d38-237">This refers to the number of tuples that failed to be fully processed before they timed out.</span></span>

* <span data-ttu-id="51d38-238">**Kapasitesi.**</span><span class="sxs-lookup"><span data-stu-id="51d38-238">**Capacity.**</span></span> <span data-ttu-id="51d38-239">Bu, sisteminizi ne kadar meşgul olduğundan bir ölçüsüdür.</span><span class="sxs-lookup"><span data-stu-id="51d38-239">This is a measure of how busy your system is.</span></span> <span data-ttu-id="51d38-240">Bu sayı 1 ise, Cıvatalar yapabilir kadar hızlı çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="51d38-240">If this number is 1, your bolts are working as fast as they can.</span></span> <span data-ttu-id="51d38-241">1'den küçük, paralellik artırın.</span><span class="sxs-lookup"><span data-stu-id="51d38-241">If it is less than 1, increase the parallelism.</span></span> <span data-ttu-id="51d38-242">1'den büyükse, paralellik azaltın.</span><span class="sxs-lookup"><span data-stu-id="51d38-242">If it is greater than 1, reduce the parallelism.</span></span>

## <a name="troubleshoot-common-problems"></a><span data-ttu-id="51d38-243">Sık karşılaşılan sorunları giderme</span><span class="sxs-lookup"><span data-stu-id="51d38-243">Troubleshoot common problems</span></span>
<span data-ttu-id="51d38-244">Birkaç genel sorun giderme senaryoları şunlardır.</span><span class="sxs-lookup"><span data-stu-id="51d38-244">Here are a few common troubleshooting scenarios.</span></span>
* <span data-ttu-id="51d38-245">**Birçok diziler zaman aşımına uğruyor.**</span><span class="sxs-lookup"><span data-stu-id="51d38-245">**Many tuples are timing out.**</span></span> <span data-ttu-id="51d38-246">Her düğüm sıkışıklık olduğu belirlemek için topolojideki bakın.</span><span class="sxs-lookup"><span data-stu-id="51d38-246">Look at each node in the topology to determine where the bottleneck is.</span></span> <span data-ttu-id="51d38-247">Bunun en yaygın nedeni Cıvatalar ile spout'lar takip edin mümkün olmamasıdır.</span><span class="sxs-lookup"><span data-stu-id="51d38-247">The most common reason for this is that the bolts are not able to keep up with the spouts.</span></span> <span data-ttu-id="51d38-248">Bu, işlenmeyi bekleyen iç arabelleklerini tıkamasını diziler neden olmaktadır.</span><span class="sxs-lookup"><span data-stu-id="51d38-248">This leads to tuples clogging the internal buffers while waiting to be processed.</span></span> <span data-ttu-id="51d38-249">Zaman aşımı değerini artırmayı veya max spout bekleyen azaltarak göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="51d38-249">Consider increasing the timeout value or decreasing the max spout pending.</span></span>

* <span data-ttu-id="51d38-250">**Yüksek toplam işlem yürütme gecikmesi, ancak düşük Cıvata işlem gecikme yoktur.**</span><span class="sxs-lookup"><span data-stu-id="51d38-250">**There is a high total process execution latency, but a low bolt process latency.**</span></span> <span data-ttu-id="51d38-251">Bu durumda, başlıklar yeterince hızlı alınıyor değil, mümkündür.</span><span class="sxs-lookup"><span data-stu-id="51d38-251">In this case, it is possible that the tuples are not being acknowledged fast enough.</span></span> <span data-ttu-id="51d38-252">Acknowledgers yeterli sayıda olup olmadığını denetleyin.</span><span class="sxs-lookup"><span data-stu-id="51d38-252">Check that there are a sufficient number of acknowledgers.</span></span> <span data-ttu-id="51d38-253">Başka bir olasılık işlemeden Cıvatalar başlamadan önce bunlar için çok uzun süre sırada bekleyen emin olabilir.</span><span class="sxs-lookup"><span data-stu-id="51d38-253">Another possibility is that they are waiting in the queue for too long before the bolts start processing them.</span></span> <span data-ttu-id="51d38-254">Bekleyen max spout azaltın.</span><span class="sxs-lookup"><span data-stu-id="51d38-254">Decrease the max spout pending.</span></span>

* <span data-ttu-id="51d38-255">**Yüksek Cıvata yürütme gecikme süresi yok.**</span><span class="sxs-lookup"><span data-stu-id="51d38-255">**There is a high bolt execute latency.**</span></span> <span data-ttu-id="51d38-256">Başka bir deyişle, Cıvata execute() yöntemiyle çok uzun sürüyor.</span><span class="sxs-lookup"><span data-stu-id="51d38-256">This means that the execute() method of your bolt is taking too long.</span></span> <span data-ttu-id="51d38-257">Kodu en iyi duruma veya yazma boyutlarda görünüş ve davranışı temizleme.</span><span class="sxs-lookup"><span data-stu-id="51d38-257">Optimize the code, or look at write sizes and flush behavior.</span></span>

### <a name="data-lake-store-throttling"></a><span data-ttu-id="51d38-258">Data Lake Store azaltma</span><span class="sxs-lookup"><span data-stu-id="51d38-258">Data Lake Store throttling</span></span>
<span data-ttu-id="51d38-259">Data Lake Store tarafından sağlanan bant genişliği sınırına ulaşıp görev hataları görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="51d38-259">If you hit the limits of bandwidth provided by Data Lake Store, you might see task failures.</span></span> <span data-ttu-id="51d38-260">Hataları azaltma için görev günlüklerini denetleyin.</span><span class="sxs-lookup"><span data-stu-id="51d38-260">Check task logs for throttling errors.</span></span> <span data-ttu-id="51d38-261">Kapsayıcı boyutu artırarak paralellik düşürebilir.</span><span class="sxs-lookup"><span data-stu-id="51d38-261">You can decrease the parallelism by increasing container size.</span></span>    

<span data-ttu-id="51d38-262">Kısıtlanan denetlemek için hata ayıklama istemci tarafında günlüğü etkinleştir:</span><span class="sxs-lookup"><span data-stu-id="51d38-262">To check if you are getting throttled, enable the debug logging on the client side:</span></span>

1. <span data-ttu-id="51d38-263">İçinde **Ambari** > **Storm** > **Config** > **storm çalışan log4j Gelişmiş**, değiştirme  **&lt;kök düzeyi "bilgi" =&gt;**  için  **&lt;kök düzeyinde "hata ayıklama" =&gt;**.</span><span class="sxs-lookup"><span data-stu-id="51d38-263">In **Ambari** > **Storm** > **Config** > **Advanced storm-worker-log4j**, change **&lt;root level="info"&gt;** to **&lt;root level=”debug”&gt;**.</span></span> <span data-ttu-id="51d38-264">Tüm düğümleri/hizmet yapılandırmasının etkili olması yeniden başlatın.</span><span class="sxs-lookup"><span data-stu-id="51d38-264">Restart all the nodes/service for the configuration to take effect.</span></span>
2. <span data-ttu-id="51d38-265">Storm topolojisini günlüklerini çalışan düğümlerine İzleyicisi (/var/log/storm/worker-artifacts altında /&lt;TopologyName&gt;/&lt;bağlantı noktası&gt;/worker.log) özel durumları azaltma Data Lake Store için.</span><span class="sxs-lookup"><span data-stu-id="51d38-265">Monitor the Storm topology logs on worker nodes (under /var/log/storm/worker-artifacts/&lt;TopologyName&gt;/&lt;port&gt;/worker.log) for Data Lake Store throttling exceptions.</span></span>

## <a name="next-steps"></a><span data-ttu-id="51d38-266">Sonraki adımlar</span><span class="sxs-lookup"><span data-stu-id="51d38-266">Next steps</span></span>
<span data-ttu-id="51d38-267">Storm olarak başvurulabilir için ek performans ayarlaması [bu blog](https://blogs.msdn.microsoft.com/shanyu/2015/05/14/performance-tuning-for-hdinsight-storm-and-microsoft-azure-eventhubs/).</span><span class="sxs-lookup"><span data-stu-id="51d38-267">Additional performance tuning for Storm can be referenced in [this blog](https://blogs.msdn.microsoft.com/shanyu/2015/05/14/performance-tuning-for-hdinsight-storm-and-microsoft-azure-eventhubs/).</span></span>

<span data-ttu-id="51d38-268">Çalıştırmak ek örnek için bkz: [github'daki bu bir](https://github.com/hdinsight/storm-performance-automation).</span><span class="sxs-lookup"><span data-stu-id="51d38-268">For an additional example to run, see [this one on GitHub](https://github.com/hdinsight/storm-performance-automation).</span></span>
