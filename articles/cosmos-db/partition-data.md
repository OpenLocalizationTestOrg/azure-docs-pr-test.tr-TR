---
title: "aaaPartitioning ve yatay Azure Cosmos DB'de ölçeklendirme | Microsoft Docs"
description: "Azure Cosmos veritabanı bölümleme nasıl çalıştığı hakkında tooconfigure bölümlendirme ve bölüm anahtarlarını ve toopick hello sağ nasıl nasıl bölüm anahtarı, uygulamanız için öğrenin."
services: cosmos-db
author: arramac
manager: jhubbard
editor: monicar
documentationcenter: 
ms.assetid: cac9a8cd-b5a3-4827-8505-d40bb61b2416
ms.service: cosmos-db
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 05/10/2017
ms.author: arramac
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: 87d56db8c4ccc6b94b1650baff0fcfb3db6d1777
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/06/2017
---
# <a name="how-toopartition-and-scale-in-azure-cosmos-db"></a><span data-ttu-id="49510-103">Nasıl toopartition ve ölçek Azure Cosmos veritabanı</span><span class="sxs-lookup"><span data-stu-id="49510-103">How toopartition and scale in Azure Cosmos DB</span></span>

<span data-ttu-id="49510-104">[Microsoft Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) ulaşmanıza hızlı ve tahmin edilebilir performansı ve ölçeği sorunsuz bir şekilde uygulamanızı yanı sıra, büyüdükçe Genel dağıtılmış, birden çok model veritabanı tasarlanan hizmet toohelp değil.</span><span class="sxs-lookup"><span data-stu-id="49510-104">[Microsoft Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) is a global distributed, multi-model database service designed toohelp you achieve fast, predictable performance and scale seamlessly along with your application as it grows.</span></span> <span data-ttu-id="49510-105">Bu makalede nasıl çalıştığı tüm hello veriler için bölümleme Azure Cosmos DB'de modeller ve uygulamalarınızı Azure Cosmos DB kapsayıcıları tooeffectively ölçek nasıl yapılandırabileceğiniz anlatılmaktadır genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="49510-105">This article provides an overview of how partitioning works for all hello data models in Azure Cosmos DB, and describes how you can configure Azure Cosmos DB containers tooeffectively scale your applications.</span></span>

<span data-ttu-id="49510-106">Ayrıca bölümleme ve bölüm anahtarlarını bu Azure Cuma Scott Hanselman ve Azure Cosmos DB sorumlu mühendislik Yöneticisi, Shireesh Thota ile video ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="49510-106">Partitioning and partition keys are also covered in this Azure Friday video with Scott Hanselman and Azure Cosmos DB Principal Engineering Manager, Shireesh Thota.</span></span>

> [!VIDEO https://channel9.msdn.com/Shows/Azure-Friday/Azure-DocumentDB-Elastic-Scale-Partitioning/player]
> 

## <a name="partitioning-in-azure-cosmos-db"></a><span data-ttu-id="49510-107">Azure Cosmos DB bölümlendirme</span><span class="sxs-lookup"><span data-stu-id="49510-107">Partitioning in Azure Cosmos DB</span></span>
<span data-ttu-id="49510-108">Azure Cosmos DB'de depolamak ve herhangi bir ölçekte milisaniyelik sipariş yanıt süreleri ile şema daha az veri sorgulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="49510-108">In Azure Cosmos DB, you can store and query schema-less data with order-of-millisecond response times at any scale.</span></span> <span data-ttu-id="49510-109">Cosmos DB veri depolama adı verilen kapsayıcıları sağlar **(belge için) koleksiyonlar, grafikleri veya tabloları**.</span><span class="sxs-lookup"><span data-stu-id="49510-109">Cosmos DB provides containers for storing data called **collections (for document), graphs, or tables**.</span></span> <span data-ttu-id="49510-110">Kapsayıcıları mantıksal kaynaklar ve bir veya daha fazla fiziksel bölümleri veya sunucuları yayılabilir.</span><span class="sxs-lookup"><span data-stu-id="49510-110">Containers are logical resources and can span one or more physical partitions or servers.</span></span> <span data-ttu-id="49510-111">bölüm sayısı Hello Cosmos hello depolama boyutu ve hello kapsayıcısının hello sağlanan işleme dayalı DB tarafından belirlenir.</span><span class="sxs-lookup"><span data-stu-id="49510-111">hello number of partitions is determined by Cosmos DB based on hello storage size and hello provisioned throughput of hello container.</span></span> <span data-ttu-id="49510-112">Cosmos DB her bölümün SSD yedekli depolama ilişkili sabit bir tutar sahiptir ve yüksek kullanılabilirlik için çoğaltılır.</span><span class="sxs-lookup"><span data-stu-id="49510-112">Every partition in Cosmos DB has a fixed amount of SSD-backed storage associated with it, and is replicated for high availability.</span></span> <span data-ttu-id="49510-113">Bölüm yönetimi tam olarak Azure Cosmos DB tarafından yönetilen ve değil toowrite karmaşık koda sahip veya, bölümlerini yönetin.</span><span class="sxs-lookup"><span data-stu-id="49510-113">Partition management is fully managed by Azure Cosmos DB, and you do not have toowrite complex code or manage your partitions.</span></span> <span data-ttu-id="49510-114">Cosmos DB depolama ve işleme açısından sınırsız kapsayıcılardır.</span><span class="sxs-lookup"><span data-stu-id="49510-114">Cosmos DB containers are unlimited in terms of storage and throughput.</span></span> 

![Yatay](./media/introduction/azure-cosmos-db-partitioning.png) 

<span data-ttu-id="49510-116">Bölümleme saydam tooyour uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="49510-116">Partitioning is transparent tooyour application.</span></span> <span data-ttu-id="49510-117">Cosmos DB hızlı okuma ve yazma, sorguları, işlem mantığı, tutarlılık düzeyleri ve ayrıntılı erişim denetimi yöntemlerini/API'leri tooa tek kapsayıcı kaynağa yoluyla destekler.</span><span class="sxs-lookup"><span data-stu-id="49510-117">Cosmos DB supports fast reads and writes, queries, transactional logic, consistency levels, and fine-grained access control via methods/APIs tooa single container resource.</span></span> <span data-ttu-id="49510-118">Merhaba hizmet bölüm ve yönlendirme sorgu istekleri toohello sağ bölüm arasında dağıtma verileri işler.</span><span class="sxs-lookup"><span data-stu-id="49510-118">hello service handles distributing data across partitions and routing query requests toohello right partition.</span></span> 

<span data-ttu-id="49510-119">Bölümleme nasıl çalışır?</span><span class="sxs-lookup"><span data-stu-id="49510-119">How does partitioning work?</span></span> <span data-ttu-id="49510-120">Her bir öğeyi benzersiz olarak tanımlamak bölüm anahtarı ve bir satır anahtarı olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="49510-120">Each item must have a partition key and a row key, which uniquely identify it.</span></span> <span data-ttu-id="49510-121">Bölüm anahtarı, verileriniz için bir mantıksal bölüm görevi görür ve bölümler veri dağıtılmasında Cosmos DB ile doğal bir sınır sağlar.</span><span class="sxs-lookup"><span data-stu-id="49510-121">Your partition key acts as a logical partition for your data, and provides Cosmos DB with a natural boundary for distributing data across partitions.</span></span> <span data-ttu-id="49510-122">Kısaca, işte Azure Cosmos DB'de bölümleme nasıl çalışır:</span><span class="sxs-lookup"><span data-stu-id="49510-122">In brief, here is how partitioning works in Azure Cosmos DB:</span></span>

* <span data-ttu-id="49510-123">Cosmos DB kapsayıcıyla sağlamak `T` İsteği/sn üretilen iş</span><span class="sxs-lookup"><span data-stu-id="49510-123">You provision a Cosmos DB container with `T` requests/s throughput</span></span>
* <span data-ttu-id="49510-124">Merhaba arka planda Cosmos DB hükümleri bölümleri tooserve gerekli `T` İsteği/sn.</span><span class="sxs-lookup"><span data-stu-id="49510-124">Behind hello scenes, Cosmos DB provisions partitions needed tooserve `T` requests/s.</span></span> <span data-ttu-id="49510-125">Varsa `T` bölüm başına en fazla üretilen hello daha yüksek `t`, ardından Cosmos DB hükümleri `N`  =  `T/t` bölümleri</span><span class="sxs-lookup"><span data-stu-id="49510-125">If `T` is higher than hello maximum throughput per partition `t`, then Cosmos DB provisions `N` = `T/t` partitions</span></span>
* <span data-ttu-id="49510-126">Cosmos DB ayırır hello anahtar alanı bölümünün anahtar karmaları eşit hello arasında `N` bölümler.</span><span class="sxs-lookup"><span data-stu-id="49510-126">Cosmos DB allocates hello key space of partition key hashes evenly across hello `N` partitions.</span></span> <span data-ttu-id="49510-127">Bu nedenle, her bölüm (fiziksel bölüm) 1-N bölüm anahtarı değerlerini (mantıksal bölümler) barındırır</span><span class="sxs-lookup"><span data-stu-id="49510-127">So, each partition (physical partition) hosts 1-N partition key values (logical partitions)</span></span>
* <span data-ttu-id="49510-128">Fiziksel bir bölüm olduğunda `p` Cosmos DB, depolama sınırına sorunsuz bir şekilde böler ulaştığında `p` iki yeni bölümlere `p1` ve `p2` ve tooroughly yarım hello anahtarları tooeach Merhaba, karşılık gelen değerleri dağıtır bölüm.</span><span class="sxs-lookup"><span data-stu-id="49510-128">When a physical partition `p` reaches its storage limit, Cosmos DB seamlessly splits `p` into two new partitions `p1` and `p2` and distributes values corresponding tooroughly half hello keys tooeach of hello partitions.</span></span> <span data-ttu-id="49510-129">Bu işlemi bölünmüş görünmez tooyour uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="49510-129">This split operation is invisible tooyour application.</span></span>
* <span data-ttu-id="49510-130">Benzer şekilde, ne zaman sağlamanız daha yüksek verimlilik `t*N` verimlilik, Cosmos DB böler bir veya daha fazla, bölümler toosupport hello daha yüksek verimlilik</span><span class="sxs-lookup"><span data-stu-id="49510-130">Similarly, when you provision throughput higher than `t*N` throughput, Cosmos DB splits one or more of your partitions toosupport hello higher throughput</span></span>

<span data-ttu-id="49510-131">bölüm anahtarlarını Hello anlamları hello aşağıdaki tabloda gösterildiği gibi her API biraz farklı toomatch hello semantiği şunlardır:</span><span class="sxs-lookup"><span data-stu-id="49510-131">hello semantics for partition keys are slightly different toomatch hello semantics of each API, as shown in hello following table:</span></span>

| <span data-ttu-id="49510-132">API</span><span class="sxs-lookup"><span data-stu-id="49510-132">API</span></span> | <span data-ttu-id="49510-133">Bölüm anahtarı</span><span class="sxs-lookup"><span data-stu-id="49510-133">Partition Key</span></span> | <span data-ttu-id="49510-134">Satır anahtarı</span><span class="sxs-lookup"><span data-stu-id="49510-134">Row Key</span></span> |
| --- | --- | --- |
| <span data-ttu-id="49510-135">DocumentDB</span><span class="sxs-lookup"><span data-stu-id="49510-135">DocumentDB</span></span> | <span data-ttu-id="49510-136">Özel bölüm anahtar yolu</span><span class="sxs-lookup"><span data-stu-id="49510-136">custom partition key path</span></span> | <span data-ttu-id="49510-137">Sabit`id`</span><span class="sxs-lookup"><span data-stu-id="49510-137">fixed `id`</span></span> | 
| <span data-ttu-id="49510-138">MongoDB</span><span class="sxs-lookup"><span data-stu-id="49510-138">MongoDB</span></span> | <span data-ttu-id="49510-139">özel parça anahtarı</span><span class="sxs-lookup"><span data-stu-id="49510-139">custom shard key</span></span>  | <span data-ttu-id="49510-140">Sabit`_id`</span><span class="sxs-lookup"><span data-stu-id="49510-140">fixed `_id`</span></span> | 
| <span data-ttu-id="49510-141">Graph</span><span class="sxs-lookup"><span data-stu-id="49510-141">Graph</span></span> | <span data-ttu-id="49510-142">Özel bölüm anahtar özelliği</span><span class="sxs-lookup"><span data-stu-id="49510-142">custom partition key property</span></span> | <span data-ttu-id="49510-143">Sabit`id`</span><span class="sxs-lookup"><span data-stu-id="49510-143">fixed `id`</span></span> | 
| <span data-ttu-id="49510-144">Tablo</span><span class="sxs-lookup"><span data-stu-id="49510-144">Table</span></span> | <span data-ttu-id="49510-145">Sabit`PartitionKey`</span><span class="sxs-lookup"><span data-stu-id="49510-145">fixed `PartitionKey`</span></span> | <span data-ttu-id="49510-146">Sabit`RowKey`</span><span class="sxs-lookup"><span data-stu-id="49510-146">fixed `RowKey`</span></span> | 

<span data-ttu-id="49510-147">Cosmos DB karma tabanlı bölümleme kullanır.</span><span class="sxs-lookup"><span data-stu-id="49510-147">Cosmos DB uses hash-based partitioning.</span></span> <span data-ttu-id="49510-148">Bir öğe yazdığınızda, Cosmos DB hello bölüm anahtarı değerini karma hale getirir ve kullanım hello sonuç toodetermine hangi bölüm toostore hello öğesinde karma.</span><span class="sxs-lookup"><span data-stu-id="49510-148">When you write an item, Cosmos DB hashes hello partition key value and use hello hashed result toodetermine which partition toostore hello item in.</span></span> <span data-ttu-id="49510-149">Tüm öğeleri aynı bölüm anahtarı hello cosmos DB depoları aynı fiziksel bölümünde hello.</span><span class="sxs-lookup"><span data-stu-id="49510-149">Cosmos DB stores all items with hello same partition key in hello same physical partition.</span></span> <span data-ttu-id="49510-150">Merhaba hello bölüm anahtarı tasarım zamanında toomake sahip bir önemli karar seçimdir.</span><span class="sxs-lookup"><span data-stu-id="49510-150">hello choice of hello partition key is an important decision that you have toomake at design time.</span></span> <span data-ttu-id="49510-151">Çok çeşitli değerleri ve hatta erişim desenlerini sahip bir özellik adı seçmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="49510-151">You must pick a property name that has a wide range of values and has even access patterns.</span></span>

> [!NOTE]
> <span data-ttu-id="49510-152">En iyi yöntem toohave bir bölüm anahtarı birçok farklı değerleri (100 s-1000'lik bloklar en az) sahip olur.</span><span class="sxs-lookup"><span data-stu-id="49510-152">It is a best practice toohave a partition key with many distinct values (100s-1000s at a minimum).</span></span>
>

<span data-ttu-id="49510-153">Azure Cosmos DB kapsayıcıları "sabit" veya "sınırsız." oluşturulabilir</span><span class="sxs-lookup"><span data-stu-id="49510-153">Azure Cosmos DB containers can be created as "fixed" or "unlimited."</span></span> <span data-ttu-id="49510-154">Sabit boyutlu kapsayıcıları 10 GB ve 10. 000'ru / s işleme üst sınırına sahip.</span><span class="sxs-lookup"><span data-stu-id="49510-154">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="49510-155">Bazı API'ler hello bölüm anahtarı toobe sabit boyutlu kapsayıcıları için atlanmış izin verir.</span><span class="sxs-lookup"><span data-stu-id="49510-155">Some APIs allow hello partition key toobe omitted for fixed-size containers.</span></span> <span data-ttu-id="49510-156">toocreate kapsayıcı sınırsız olarak, en düşük işleme 2500 RU/s belirtmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="49510-156">toocreate a container as unlimited, you must specify a minimum throughput of 2500 RU/s.</span></span>

## <a name="partitioning-and-provisioned-throughput"></a><span data-ttu-id="49510-157">Bölümlendirme ve sağlanan işleme</span><span class="sxs-lookup"><span data-stu-id="49510-157">Partitioning and provisioned throughput</span></span>
<span data-ttu-id="49510-158">Cosmos DB tahmin edilebilir performans için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="49510-158">Cosmos DB is designed for predictable performance.</span></span> <span data-ttu-id="49510-159">Bir kapsayıcı oluşturduğunuzda, üretilen iş açısından, yedek  **[istek birimleri](request-units.md) (RU) RU için olası eklentisinin dakika başına saniyede**.</span><span class="sxs-lookup"><span data-stu-id="49510-159">When you create a container, you reserve throughput in terms of **[request units](request-units.md) (RU) per second with a potential add-on for RU per minute**.</span></span> <span data-ttu-id="49510-160">Her istek ile orantılı toohello miktarı CPU, bellek ve g/ç hello işlemi tarafından tüketilen gibi sistem kaynaklarının bir istek birimi ücret atanır.</span><span class="sxs-lookup"><span data-stu-id="49510-160">Each request is assigned a request unit charge that is proportionate toohello amount of system resources like CPU, Memory, and IO consumed by hello operation.</span></span> <span data-ttu-id="49510-161">Oturum tutarlılığı 1 KB belgeyle okuma bir istek birimi tüketir.</span><span class="sxs-lookup"><span data-stu-id="49510-161">A read of a 1-KB document with Session consistency consumes one request unit.</span></span> <span data-ttu-id="49510-162">Okuma 1. öğe sayısı hello bakılmaksızın RU depolanır veya hello hello çalıştıran eşzamanlı istek sayısı aynı anda.</span><span class="sxs-lookup"><span data-stu-id="49510-162">A read is 1 RU regardless of hello number of items stored or hello number of concurrent requests running at hello same time.</span></span> <span data-ttu-id="49510-163">Daha büyük öğelerin hello boyutuna bağlı olarak daha yüksek istek birimleri gerektirir.</span><span class="sxs-lookup"><span data-stu-id="49510-163">Larger items require higher request units depending on hello size.</span></span> <span data-ttu-id="49510-164">Varlıklarınızı hello boyutunu bildiğiniz ve okuma sayısını hello toosupport uygulamanız için gereken, uygulamanızın ihtiyaçlarını okuma için gereken işleme hello miktarda sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="49510-164">If you know hello size of your entities and hello number of reads you need toosupport for your application, you can provision hello exact amount of throughput required for your application's read needs.</span></span> 

> [!NOTE]
> <span data-ttu-id="49510-165">Merhaba kapsayıcısının tooachieve hello tam verimlilik, tooevenly sağlayan bir bölüm anahtarı isteklerini bazı farklı bölüm anahtarı değerleri arasında dağıtmak seçmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="49510-165">tooachieve hello full throughput of hello container, you must choose a partition key that allows you tooevenly distribute requests among some distinct partition key values.</span></span>
> 
> 

<a name="designing-for-partitioning"></a>
## <a name="working-with-hello-azure-cosmos-db-apis"></a><span data-ttu-id="49510-166">Hello Azure Cosmos DB API'leri ile çalışma</span><span class="sxs-lookup"><span data-stu-id="49510-166">Working with hello Azure Cosmos DB APIs</span></span>
<span data-ttu-id="49510-167">Hello Azure portalında veya Azure CLI toocreate kapsayıcıların kullanılması ve herhangi bir zamanda ölçeklendirin.</span><span class="sxs-lookup"><span data-stu-id="49510-167">You can use hello Azure portal or Azure CLI toocreate containers and scale them at any time.</span></span> <span data-ttu-id="49510-168">Bu bölümde gösterilmiştir nasıl toocreate kapsayıcıları ve hello üretilen iş ve bölüm anahtar tanımında her hello desteklenen API'ları belirtin.</span><span class="sxs-lookup"><span data-stu-id="49510-168">This section shows how toocreate containers and specify hello throughput and partition key definition in each of hello supported APIs.</span></span>

### <a name="documentdb-api"></a><span data-ttu-id="49510-169">DocumentDB API’si</span><span class="sxs-lookup"><span data-stu-id="49510-169">DocumentDB API</span></span>
<span data-ttu-id="49510-170">Aşağıdaki örnek hello nasıl bir kapsayıcı (toplama) kullanılarak toocreate hello DocumentDB API gösterir.</span><span class="sxs-lookup"><span data-stu-id="49510-170">hello following sample shows how toocreate a container (collection) using hello DocumentDB API.</span></span> <span data-ttu-id="49510-171">Daha ayrıntılı bilgi bulabilirsiniz [DocumentDB API'si ile bölümleme](partition-data.md).</span><span class="sxs-lookup"><span data-stu-id="49510-171">You can find more details in [Partitioning with DocumentDB API](partition-data.md).</span></span>

```csharp
DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);
await client.CreateDatabaseAsync(new Database { Id = "db" });

DocumentCollection myCollection = new DocumentCollection();
myCollection.Id = "coll";
myCollection.PartitionKey.Paths.Add("/deviceId");

await client.CreateDocumentCollectionAsync(
    UriFactory.CreateDatabaseUri("db"),
    myCollection,
    new RequestOptions { OfferThroughput = 20000 });
```

<span data-ttu-id="49510-172">Hello kullanarak bir öğe (belge) okuyabilir `GET` yöntemi hello REST API veya kullanılarak `ReadDocumentAsync` hello SDK'ları birinde.</span><span class="sxs-lookup"><span data-stu-id="49510-172">You can read an item (document) using hello `GET` method in hello REST API or using `ReadDocumentAsync` in one of hello SDKs.</span></span>

```csharp
// Read document. Needs hello partition key and hello ID toobe specified
DeviceReading document = await client.ReadDocumentAsync<DeviceReading>(
  UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
  new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });
```

### <a name="mongodb-api"></a><span data-ttu-id="49510-173">MongoDB API’si</span><span class="sxs-lookup"><span data-stu-id="49510-173">MongoDB API</span></span>
<span data-ttu-id="49510-174">Merhaba MongoDB API ile sık kullanılan aracı, sürücü veya SDK aracılığıyla parçalı bir koleksiyon oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="49510-174">With hello MongoDB API, you can create a sharded collection through your favorite tool, driver, or SDK.</span></span> <span data-ttu-id="49510-175">Bu örnekte, hello koleksiyonu oluşturmak için hello Mongo kabuğunu kullanırız.</span><span class="sxs-lookup"><span data-stu-id="49510-175">In this example, we use hello Mongo Shell for hello collection creation.</span></span>

<span data-ttu-id="49510-176">Merhaba Mongo kabuğunu:</span><span class="sxs-lookup"><span data-stu-id="49510-176">In hello Mongo Shell:</span></span>

```
db.runCommand( { shardCollection: "admin.people", key: { region: "hashed" } } )
```
    
<span data-ttu-id="49510-177">Sonuçları:</span><span class="sxs-lookup"><span data-stu-id="49510-177">Results:</span></span>

```JSON
{
    "_t" : "ShardCollectionResponse",
    "ok" : 1,
    "collectionsharded" : "admin.people"
}
```

### <a name="table-api"></a><span data-ttu-id="49510-178">Tablo API’si</span><span class="sxs-lookup"><span data-stu-id="49510-178">Table API</span></span>

<span data-ttu-id="49510-179">Merhaba tablo API hello verimlilik tablolar için uygulamanız için hello appSettings yapılandırmasında belirtin:</span><span class="sxs-lookup"><span data-stu-id="49510-179">With hello Table API, you specify hello throughput for tables in hello appSettings configuration for your application:</span></span>

```xml
<configuration>
    <appSettings>
      <!--Table creation options -->
      <add key="TableThroughput" value="700"/>
    </appSettings>
</configuration>
```

<span data-ttu-id="49510-180">Ardından hello Azure Table depolama SDK'sını kullanarak bir tablo oluşturun.</span><span class="sxs-lookup"><span data-stu-id="49510-180">Then you create a table using hello Azure Table storage SDK.</span></span> <span data-ttu-id="49510-181">Merhaba bölüm anahtarı hello örtük olarak oluşturulmuş `PartitionKey` değeri.</span><span class="sxs-lookup"><span data-stu-id="49510-181">hello partition key is implicitly created as hello `PartitionKey` value.</span></span> 

```csharp
CloudTableClient tableClient = storageAccount.CreateCloudTableClient();

CloudTable table = tableClient.GetTableReference("people");
table.CreateIfNotExists();
```

<span data-ttu-id="49510-182">Aşağıdaki kod parçacığında hello kullanarak tek bir varlık alabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="49510-182">You can retrieve a single entity using hello following snippet:</span></span>

```csharp
// Create a retrieve operation that takes a customer entity.
TableOperation retrieveOperation = TableOperation.Retrieve<CustomerEntity>("Smith", "Ben");

// Execute hello retrieve operation.
TableResult retrievedResult = table.Execute(retrieveOperation);
```
<span data-ttu-id="49510-183">Bkz: [hello tablo API ile geliştirme](tutorial-develop-table-dotnet.md) daha fazla ayrıntı için.</span><span class="sxs-lookup"><span data-stu-id="49510-183">See [Developing with hello Table API](tutorial-develop-table-dotnet.md) for more details.</span></span>

### <a name="graph-api"></a><span data-ttu-id="49510-184">Graph API</span><span class="sxs-lookup"><span data-stu-id="49510-184">Graph API</span></span>

<span data-ttu-id="49510-185">Merhaba grafik API'si hello Azure portal veya CLI toocreate kapsayıcıları kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="49510-185">With hello Graph API, you must use hello Azure portal or CLI toocreate containers.</span></span> <span data-ttu-id="49510-186">Alternatif olarak, Azure Cosmos DB çok model olduğundan başka modellerinin toocreate hello birini kullanın ve grafik kapsayıcı ölçeklendirin.</span><span class="sxs-lookup"><span data-stu-id="49510-186">Alternatively, since Azure Cosmos DB is multi-model, you can use one of hello other models toocreate and scale your graph container.</span></span>

<span data-ttu-id="49510-187">Herhangi bir köşe veya hello bölüm anahtarı ve kimliği içinde Gremlin kullanarak kenar okuyabilir.</span><span class="sxs-lookup"><span data-stu-id="49510-187">You can read any vertex or edge using hello partition key and id in Gremlin.</span></span> <span data-ttu-id="49510-188">Örneğin, hello bölüm anahtarı olarak ve "Seattle" Merhaba satır anahtarı olarak bölgesi ("ABD") ile bir grafik için sözdizimi aşağıdaki hello kullanarak köşe bulabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="49510-188">For example, for a graph with region ("USA") as hello partition key, and "Seattle" as hello row key, you can find a vertex using hello following syntax:</span></span>

```
g.V(['USA', 'Seattle'])
```

<span data-ttu-id="49510-189">Aynı kenarları hello bölüm anahtarı ve satır anahtarı kullanarak bir sınır başvuruda bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="49510-189">Same with edges, you can reference an edge using hello partition key and row key.</span></span>

```
g.E(['USA', 'I5'])
```

<span data-ttu-id="49510-190">Bkz: [Cosmos DB Gremlin desteği](gremlin-support.md) daha fazla ayrıntı için.</span><span class="sxs-lookup"><span data-stu-id="49510-190">See [Gremlin support for Cosmos DB](gremlin-support.md) for more details.</span></span>


<a name="designing-for-partitioning"></a>
## <a name="designing-for-partitioning"></a><span data-ttu-id="49510-191">Bölümleme için tasarlama</span><span class="sxs-lookup"><span data-stu-id="49510-191">Designing for partitioning</span></span>
<span data-ttu-id="49510-192">kapsayıcı oluşturduğunuzda tooscale etkili bir şekilde Azure Cosmos DB ile toopick iyi bir bölüm anahtarı gerekir.</span><span class="sxs-lookup"><span data-stu-id="49510-192">tooscale effectively with Azure Cosmos DB, you need toopick a good partition key when you create your container.</span></span> <span data-ttu-id="49510-193">Bölüm anahtarı seçmeye yönelik iki önemli noktalar şunlardır:</span><span class="sxs-lookup"><span data-stu-id="49510-193">There are two key considerations for choosing a partition key:</span></span>

* <span data-ttu-id="49510-194">**Sorgu ve işlemler için sınır**: seçiminizi bölüm anahtarı hello gerek tooenable hello kullan hello gereksinim toodistribute karşı hareketlerinin varlıklarınızı birden çok bölüm anahtarlarını tooensure ölçeklenebilir bir çözüm arasında dengelemeniz.</span><span class="sxs-lookup"><span data-stu-id="49510-194">**Boundary for query and transactions**: Your choice of partition key should balance hello need tooenable hello use of transactions against hello requirement toodistribute your entities across multiple partition keys tooensure a scalable solution.</span></span> <span data-ttu-id="49510-195">Bir uçta hello ayarlayabilirsiniz aynı bölüm anahtarı tüm öğeler, ancak bunun için çözümünüzün hello ölçeklenebilirlik sınırlayabilir.</span><span class="sxs-lookup"><span data-stu-id="49510-195">At one extreme, you could set hello same partition key for all your items, but this may limit hello scalability of your solution.</span></span> <span data-ttu-id="49510-196">Merhaba diğer uç yüksek düzeyde ölçeklenebilir kalır ancak saklı yordamları ve Tetikleyicileri aracılığıyla çapraz belge işlemleri kullanmasını önler her öğe için bir benzersiz bir bölüm anahtarı atayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="49510-196">At hello other extreme, you could assign a unique partition key for each item, which would be highly scalable but would prevent you from using cross document transactions via stored procedures and triggers.</span></span> <span data-ttu-id="49510-197">İdeal bölüm anahtarı, toouse verimli sorguları sağlar ve yeterli kardinalite sahip biridir tooensure çözümünüzü ölçeklenebilir.</span><span class="sxs-lookup"><span data-stu-id="49510-197">An ideal partition key is one that enables you toouse efficient queries and that has sufficient cardinality tooensure your solution is scalable.</span></span> 
* <span data-ttu-id="49510-198">**Hiçbir depolama ve performans sorunlarını**: toopick sağlayan bir özellik Yazar çeşitli farklı değerleri arasında dağıtılmış toobe önemlidir.</span><span class="sxs-lookup"><span data-stu-id="49510-198">**No storage and performance bottlenecks**: It is important toopick a property that allows writes toobe distributed across various distinct values.</span></span> <span data-ttu-id="49510-199">Aynı bölüm anahtarı tek bir bölüm hello verimini aşamaz ve kısıtlanan istekleri toohello.</span><span class="sxs-lookup"><span data-stu-id="49510-199">Requests toohello same partition key cannot exceed hello throughput of a single partition, and are throttled.</span></span> <span data-ttu-id="49510-200">Bu nedenle önemli toopick, uygulamanızda "etkin nokta" sonuçlanmaz bir bölüm anahtarı olur.</span><span class="sxs-lookup"><span data-stu-id="49510-200">So it is important toopick a partition key that does not result in "hot spots" within your application.</span></span> <span data-ttu-id="49510-201">Tek bölüm anahtarı bölüm içinde depolanması için tüm hello veriler ayrıca yüksek miktarda veriyi hello için sahip tooavoid bölüm anahtarlarını önerilir aynı değeri.</span><span class="sxs-lookup"><span data-stu-id="49510-201">Since all hello data for a single partition key must be stored within a partition, it is also recommended tooavoid partition keys that have high volumes of data for hello same value.</span></span> 

<span data-ttu-id="49510-202">Birkaç gerçek dünya senaryoları ve iyi bölüm anahtarlarının her biri için bakalım:</span><span class="sxs-lookup"><span data-stu-id="49510-202">Let's look at a few real-world scenarios, and good partition keys for each:</span></span>
* <span data-ttu-id="49510-203">Bir kullanıcı profili arka uç uyguluyorsanız hello kullanıcı kimliği bölüm anahtarı için iyi bir seçimdir değil.</span><span class="sxs-lookup"><span data-stu-id="49510-203">If you’re implementing a user profile backend, then hello user ID is a good choice for partition key.</span></span>
* <span data-ttu-id="49510-204">Örneğin, Aygıt durumu IOT veri depoluyorsanız bir cihaz kimliği bölüm anahtarı için iyi bir seçimdir.</span><span class="sxs-lookup"><span data-stu-id="49510-204">If you’re storing IoT data for example, device state, a device ID is a good choice for partition key.</span></span>
* <span data-ttu-id="49510-205">Zaman serisi veri günlük kaydı için Azure Cosmos DB kullanıyorsanız, ana bilgisayar adı hello veya işlem kimliği bölüm anahtarı için iyi bir seçimdir.</span><span class="sxs-lookup"><span data-stu-id="49510-205">If you’re using Azure Cosmos DB for logging time-series data, then hello hostname or process ID is a good choice for partition key.</span></span>
* <span data-ttu-id="49510-206">Çok kiracılı mimari varsa, hello Kiracı kimliği bölüm anahtarı için iyi bir seçimdir.</span><span class="sxs-lookup"><span data-stu-id="49510-206">If you have a multi-tenant architecture, hello tenant ID is a good choice for partition key.</span></span>

<span data-ttu-id="49510-207">IOT gibi bazı durumlarda kullanım ve kullanıcı profilleri, hello bölüm anahtarı olması hello aynı kimliği (belge anahtar).</span><span class="sxs-lookup"><span data-stu-id="49510-207">In some use cases like IoT and user profiles, hello partition key might be hello same as your id (document key).</span></span> <span data-ttu-id="49510-208">Bazı durumlarda hello zaman serisi veri gibi hello kimliğinden farklı bir bölüm anahtarı olabilir.</span><span class="sxs-lookup"><span data-stu-id="49510-208">In others like hello time series data, you might have a partition key that’s different than hello id.</span></span>

### <a name="partitioning-and-loggingtime-series-data"></a><span data-ttu-id="49510-209">Bölümlendirme ve zaman/günlüğü-serisi veri</span><span class="sxs-lookup"><span data-stu-id="49510-209">Partitioning and logging/time-series data</span></span>
<span data-ttu-id="49510-210">Merhaba ortak kullanım durumları Cosmos DB'nin günlüğe kaydetme ve telemetri biridir.</span><span class="sxs-lookup"><span data-stu-id="49510-210">One of hello common use cases of Cosmos DB is for logging and telemetry.</span></span> <span data-ttu-id="49510-211">Büyük miktarda veriyi tooread/yazma gerekebilecek olduğundan önemli toopick iyi bir bölüm anahtarı kalır.</span><span class="sxs-lookup"><span data-stu-id="49510-211">It is important toopick a good partition key since you might need tooread/write vast volumes of data.</span></span> <span data-ttu-id="49510-212">Merhaba seçim, okuma ve yazma hızları ve tür toorun beklediğiniz sorgular bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="49510-212">hello choice depends on your read and write rates and kinds of queries you expect toorun.</span></span> <span data-ttu-id="49510-213">Bazı ipuçları nasıl toochoose iyi bir bölüm anahtarı.</span><span class="sxs-lookup"><span data-stu-id="49510-213">Here are some tips on how toochoose a good partition key.</span></span>

* <span data-ttu-id="49510-214">Kullanım örneği küçük oranını içeriyorsa zaman damgaları ve diğer filtreleri aralıklarına göre süresi gereksinimini tooquery ve uzun süre biriktirme hello zaman damgası, örneğin, dökümü kullanarak tarih sonra iyi bir yaklaşım bölüm anahtarı olarak yazar.</span><span class="sxs-lookup"><span data-stu-id="49510-214">If your use case involves a small rate of writes accumulating over a long period of time, and need tooquery by ranges of timestamps and other filters, then using a rollup of hello timestamp, for example,  date as a partition key is a good approach.</span></span> <span data-ttu-id="49510-215">Bu, tooquery tüm hello verileri tek bir bölüm tarihinden sağlar.</span><span class="sxs-lookup"><span data-stu-id="49510-215">This allows you tooquery over all hello data for a date from a single partition.</span></span> 
* <span data-ttu-id="49510-216">İş yükünüzün daha yaygın bir durumdur, ağır yazılmışsa zaman damgasını dayalı olmayan ve böylece Cosmos DB yazma eşit çeşitli bölümler dağıtabilirsiniz bölüm anahtarı kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="49510-216">If your workload is written heavy, which is more common, you should use a partition key that’s not based on timestamp so that Cosmos DB can distribute writes evenly across various partitions.</span></span> <span data-ttu-id="49510-217">Burada bir ana bilgisayar adı, işlem kimliği, etkinlik kimliği veya başka bir özelliği yüksek önem düzeyi ile iyi bir seçimdir.</span><span class="sxs-lookup"><span data-stu-id="49510-217">Here a hostname, process ID, activity ID, or another property with high cardinality is a good choice.</span></span> 
* <span data-ttu-id="49510-218">Burada her gün/ay için birden çok kapsayıcı sahip ve hello bölüm anahtarı ana bilgisayar adı gibi ayrıntılı bir özelliği bir karma bir buna üçüncü bir yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="49510-218">A third approach is a hybrid one where you have multiple containers, one for each day/month and hello partition key is a granular property like hostname.</span></span> <span data-ttu-id="49510-219">Bu, farklı verimlilik üzerinde hello zaman penceresi göre ayarlayabilirsiniz hello avantajına sahiptir, okuma ve yazma işlemleri, gördüğünden bu yana üretilen iş ile önceki ay alt ancak gibi hello kapsayıcı hello geçerli ay için daha yüksek işleme ile sağlanır Bunlar yalnızca okuma hizmet.</span><span class="sxs-lookup"><span data-stu-id="49510-219">This has hello benefit that you can set different throughput based on hello time window, for example, hello container for hello current month is provisioned with higher throughput since it serves reads and writes, whereas previous months with lower throughput since they only serve reads.</span></span>

### <a name="partitioning-and-multi-tenancy"></a><span data-ttu-id="49510-220">Bölümlendirme ve çoklu kiracı</span><span class="sxs-lookup"><span data-stu-id="49510-220">Partitioning and multi-tenancy</span></span>
<span data-ttu-id="49510-221">Cosmos DB kullanarak çok kiracılı uygulama uyguluyorsanız, iki popüler desenleri – Kiracı başına bir bölüm anahtarı ve Kiracı başına bir kapsayıcı vardır.</span><span class="sxs-lookup"><span data-stu-id="49510-221">If you are implementing a multi-tenant application using Cosmos DB, there are two popular patterns – one partition key per tenant, and one container per tenant.</span></span> <span data-ttu-id="49510-222">Merhaba Artıları ve eksileri her şunlardır:</span><span class="sxs-lookup"><span data-stu-id="49510-222">Here are hello pros and cons for each:</span></span>

* <span data-ttu-id="49510-223">Kiracı başına bir bölüm anahtarı: tek bir kapsayıcıda birlikte bu modelde, kiracılar.</span><span class="sxs-lookup"><span data-stu-id="49510-223">One Partition Key per tenant: In this model, tenants are collocated within a single container.</span></span> <span data-ttu-id="49510-224">Ancak, sorgular ve eklemeleri tek bir kiracı içinde öğeleri için tek bir bölüm karşı gerçekleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="49510-224">But queries and inserts for items within a single tenant can be performed against a single partition.</span></span> <span data-ttu-id="49510-225">İşlem mantığı, bir kiracı içindeki tüm öğeler arasında de uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="49510-225">You can also implement transactional logic across all items within a tenant.</span></span> <span data-ttu-id="49510-226">Birden çok kiracıya bir kapsayıcı paylaşmak olduğundan, her bir kiracı için ek boş alan sağlama yerine tek bir kapsayıcıdaki kiracılar için kaynak havuzu tarafından depolama ve işleme maliyetleri kaydedebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="49510-226">Since multiple tenants share a container, you can save storage and throughput costs by pooling resources for tenants within a single container rather than provisioning extra headroom for each tenant.</span></span> <span data-ttu-id="49510-227">Merhaba dezavantajı, performans yalıtımı Kiracı başına yok ' dir.</span><span class="sxs-lookup"><span data-stu-id="49510-227">hello drawback is that you do not have performance isolation per tenant.</span></span> <span data-ttu-id="49510-228">Performans/verimliliği artırır toohello kapsayıcının tamamı hedeflenen vs artar kiracılar için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="49510-228">Performance/throughput increases apply toohello entire container vs targeted increases for tenants.</span></span>
* <span data-ttu-id="49510-229">Kiracı başına bir kapsayıcı: her bir kiracı kendi kapsayıcı vardır.</span><span class="sxs-lookup"><span data-stu-id="49510-229">One Container per tenant: Each tenant has its own container.</span></span> <span data-ttu-id="49510-230">Bu modelde, Kiracı başına performans ayırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="49510-230">In this model, you can reserve performance per tenant.</span></span> <span data-ttu-id="49510-231">Cosmos DB'ın yeni fiyatlandırma modeli sağlamada bu birkaç kiracılarla çok kiracılı uygulamalar için daha uygun maliyetli modelidir.</span><span class="sxs-lookup"><span data-stu-id="49510-231">With Cosmos DB's new provisioning pricing model, this model is more cost-effective for multi-tenant applications with a few tenants.</span></span>

<span data-ttu-id="49510-232">Ayrıca, küçük kiracılar collocates ve büyük kiracılar tootheir kendi kapsayıcı Geçiren birleşimi ve katmanlı bir yaklaşım kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="49510-232">You can also use a combination/tiered approach that collocates small tenants and migrates larger tenants tootheir own container.</span></span>

## <a name="next-steps"></a><span data-ttu-id="49510-233">Sonraki adımlar</span><span class="sxs-lookup"><span data-stu-id="49510-233">Next steps</span></span>
<span data-ttu-id="49510-234">Bu makalede, bir genel bakış, kavramlar ve tüm Azure Cosmos DB API'si ile bölümleme için en iyi uygulamalar için genel bir bakış sağlanan.</span><span class="sxs-lookup"><span data-stu-id="49510-234">In this article, we provided an overview for an overview of concepts and best practices for partitioning with any Azure Cosmos DB API.</span></span> 

* <span data-ttu-id="49510-235">Hakkında bilgi edinin [Azure Cosmos veritabanı sağlanan işleme](request-units.md)</span><span class="sxs-lookup"><span data-stu-id="49510-235">Learn about [provisioned throughput in Azure Cosmos DB](request-units.md)</span></span>
* <span data-ttu-id="49510-236">Hakkında bilgi edinin [Azure Cosmos veritabanı genel dağıtım](distribute-data-globally.md)</span><span class="sxs-lookup"><span data-stu-id="49510-236">Learn about [global distribution in Azure Cosmos DB](distribute-data-globally.md)</span></span>



