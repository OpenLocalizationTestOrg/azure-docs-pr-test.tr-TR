---
title: "Azure Service Bus kuyruklarını kullanan uygulamalar yazma | Microsoft Docs"
description: "Azure Service Bus kullanan bir basit sıra tabanlı uygulamasının nasıl yazılacağını."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 754d91b3-1426-405e-84b4-fd36d65b114a
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/07/2017
ms.author: sethm
ms.openlocfilehash: 419caff7e8ceeb419c89a2ef9a6614c1accf3e52
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/18/2017
---
# <a name="create-applications-that-use-service-bus-queues"></a><span data-ttu-id="4dba4-103">Hizmet Veri Yolu kuyrukları kullanan uygulamalar oluşturma</span><span class="sxs-lookup"><span data-stu-id="4dba4-103">Create applications that use Service Bus queues</span></span>
<span data-ttu-id="4dba4-104">Bu konu, Service Bus kuyruklarını açıklar ve Service Bus kullanan bir basit sıra tabanlı uygulamasının nasıl yazılacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-104">This topic describes Service Bus queues and shows how to write a simple queue-based application that uses Service Bus.</span></span>

<span data-ttu-id="4dba4-105">Perakende satış verilerinden ayrı Point-of-Sale (POS) Terminal yenilenecek hisse sahip olduğunda belirlemek için veri kullanan bir stok yönetim sisteminin yönlendirilmesi gereken dünyadan bir senaryo düşünün.</span><span class="sxs-lookup"><span data-stu-id="4dba4-105">Consider a scenario from the world of retail in which sales data from individual Point-of-Sale (POS) terminals must be routed to an inventory management system that uses the data to determine when stock has to be replenished.</span></span> <span data-ttu-id="4dba4-106">Bu çözüm aşağıdaki resimde gösterildiği gibi Terminal ve stok yönetim sistemi arasındaki iletişim için Service Bus Mesajlaşma kullanır:</span><span class="sxs-lookup"><span data-stu-id="4dba4-106">This solution uses Service Bus messaging for the communication between the terminals and the inventory management system, as illustrated in the following figure:</span></span>

![Service Bus kuyrukları görüntü 1](./media/service-bus-create-queues/IC657161.gif)

<span data-ttu-id="4dba4-108">İletiler göndererek satış verilerini her POS terminal raporları **DataCollectionQueue**.</span><span class="sxs-lookup"><span data-stu-id="4dba4-108">Each POS terminal reports its sales data by sending messages to the **DataCollectionQueue**.</span></span> <span data-ttu-id="4dba4-109">Stok yönetim sistemi tarafından alınana kadar bu iletiler bu sırada kalır.</span><span class="sxs-lookup"><span data-stu-id="4dba4-109">These messages remain in this queue until they are retrieved by the inventory management system.</span></span> <span data-ttu-id="4dba4-110">Bu desen genellikle adlandırılır *zaman uyumsuz Mesajlaşma*, POS terminal işleme devam etmek için Stok yönetim sisteminin yanıt beklemesi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="4dba4-110">This pattern is often termed *asynchronous messaging*, because the POS terminal does not have to wait for a reply from the inventory management system to continue processing.</span></span>

## <a name="why-queuing"></a><span data-ttu-id="4dba4-111">Queuing neden?</span><span class="sxs-lookup"><span data-stu-id="4dba4-111">Why queuing?</span></span>
<span data-ttu-id="4dba4-112">Bu uygulamayı kurmak için gerekli kod ele önce POS Terminal sahip olmak yerine bu senaryoda bir sıra kullanmanın yararları konuşun doğrudan göz önünde bulundurun (zaman uyumlu olarak) Stok yönetim sistemine.</span><span class="sxs-lookup"><span data-stu-id="4dba4-112">Before we look at the code that is required to set up this application, consider the advantages of using a queue in this scenario instead of having the POS terminals talk directly (synchronously) to the inventory management system.</span></span>

### <a name="temporal-decoupling"></a><span data-ttu-id="4dba4-113">Zamana bağlı ayırma</span><span class="sxs-lookup"><span data-stu-id="4dba4-113">Temporal decoupling</span></span>
<span data-ttu-id="4dba4-114">Zaman uyumsuz Mesajlaşma düzeni sayesinde üreticilerin ve tüketicilerin aynı anda çevrimiçi olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="4dba4-114">With the asynchronous messaging pattern, producers and consumers do not have to be online at the same time.</span></span> <span data-ttu-id="4dba4-115">Kullanıcı tarafı almaya hazır olana kadar ileti altyapısı iletileri güvenilir bir şekilde depolar.</span><span class="sxs-lookup"><span data-stu-id="4dba4-115">The messaging infrastructure reliably stores messages until the consuming party is ready to receive them.</span></span> <span data-ttu-id="4dba4-116">Bu dağıtılmış uygulamanın bileşenleri, ya da gönüllü kesilebilir anlamına gelir; Örneğin, bakım için veya bir bileşen çökmesinden dolayı olmadan tüm sisteme etkileyen.</span><span class="sxs-lookup"><span data-stu-id="4dba4-116">This means the components of the distributed application can be disconnected, either voluntarily; for example, for maintenance, or due to a component crash, without affecting the whole system.</span></span> <span data-ttu-id="4dba4-117">Ayrıca, kullanıcı uygulamanın yalnızca günün belirli zamanlarında çevrimiçi olması gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-117">Furthermore, the consuming application may only have to be online during certain times of the day.</span></span> <span data-ttu-id="4dba4-118">Örneğin, bu perakende senaryoda Stok yönetim sisteminin sadece iş günü sonunda çevrimiçi olması gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-118">For example, in this retail scenario, the inventory management system may only have to come online after the end of the business day.</span></span>

### <a name="load-leveling"></a><span data-ttu-id="4dba4-119">Yük Dengeleme</span><span class="sxs-lookup"><span data-stu-id="4dba4-119">Load leveling</span></span>
<span data-ttu-id="4dba4-120">Her iş birimi için gereken işleme süresi genellikle sabit iken birçok uygulamada sistem yükü zaman içinde değişir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-120">In many applications system load varies over time, whereas the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="4dba4-121">Aracılığıyla ileti üreticileri ve tüketicileri bir kuyruk, kullanıcı uygulama (çalışan) yalnızca yoğun yük yerine ortalama yük hizmet vermek için sağlanacak olduğunu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-121">Intermediating message producers and consumers with a queue means that the consuming application (the worker) only has to be provisioned to service an average load rather than a peak load.</span></span> <span data-ttu-id="4dba4-122">Sıra Derinliği büyür ve gelen Yük hacmi değiştikçe sözleşme.</span><span class="sxs-lookup"><span data-stu-id="4dba4-122">The depth of the queue will grow and contract as the incoming load varies.</span></span> <span data-ttu-id="4dba4-123">Bu, doğrudan para uygulama yükünü sunmak için gereken altyapı miktarı ile kaydeder.</span><span class="sxs-lookup"><span data-stu-id="4dba4-123">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span>

![Service Bus kuyrukları görüntü 2](./media/service-bus-create-queues/IC657162.gif)

### <a name="load-balancing"></a><span data-ttu-id="4dba4-125">Yük dengeleme</span><span class="sxs-lookup"><span data-stu-id="4dba4-125">Load balancing</span></span>
<span data-ttu-id="4dba4-126">Yük arttıkça çalışan kuyruktan okunmak üzere daha fazla çalışan işlemi eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-126">As the load increases, more worker processes can be added to read from the worker queue.</span></span> <span data-ttu-id="4dba4-127">Her ileti yalnızca bir çalışan işlemi tarafından işlenir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-127">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="4dba4-128">Ayrıca, çalışan bilgisayarlar işleme gücünü göre farklılık gösterse bile iletileri kendi maksimum hızında çeker gibi çalışan bilgisayarlar optimum kullanım için bu çekme tabanlı yük dengeleme sağlar.</span><span class="sxs-lookup"><span data-stu-id="4dba4-128">Furthermore, this pull-based load balancing allows for optimum usage of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="4dba4-129">Bu model, genellikle rakip tüketici düzeni olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="4dba4-129">This pattern is often termed the competing consumer pattern.</span></span>

![Service Bus kuyruklarını 3 görüntü](./media/service-bus-create-queues/IC657163.gif)

### <a name="loose-coupling"></a><span data-ttu-id="4dba4-131">Gevşek bağlantı</span><span class="sxs-lookup"><span data-stu-id="4dba4-131">Loose coupling</span></span>
<span data-ttu-id="4dba4-132">Message queuing ileti üreticileri ve tüketicileri arasında Orta kullanarak bileşenleri arasında bir iç gevşek bağlantı sağlar.</span><span class="sxs-lookup"><span data-stu-id="4dba4-132">Using message queuing to intermediate between message producers and consumers provides an intrinsic loose coupling between the components.</span></span> <span data-ttu-id="4dba4-133">Üreticileri ve tüketicileri birbirinden farkında değildir çünkü bir tüketici üretici üzerinde hiçbir etkisi olmadan yükseltilebilir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-133">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span> <span data-ttu-id="4dba4-134">Ayrıca, Mesajlaşma topolojisi mevcut uç noktalar etkilemeden gelişmesi.</span><span class="sxs-lookup"><span data-stu-id="4dba4-134">Furthermore, the messaging topology can evolve without affecting the existing endpoints.</span></span> <span data-ttu-id="4dba4-135">Biz Yayınla/Abone ol hakkında konuşurken Biz bu daha ele alacağız.</span><span class="sxs-lookup"><span data-stu-id="4dba4-135">We’ll discuss this more when we talk about publish/subscribe.</span></span>

## <a name="show-me-the-code"></a><span data-ttu-id="4dba4-136">Kod Göster</span><span class="sxs-lookup"><span data-stu-id="4dba4-136">Show me the code</span></span>
<span data-ttu-id="4dba4-137">Aşağıdaki bölümde, Service Bus bu uygulama oluşturmak için nasıl kullanılacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-137">The following section shows how to use Service Bus to build this application.</span></span>

### <a name="sign-up-for-an-azure-account"></a><span data-ttu-id="4dba4-138">Azure hesabı için kaydolun</span><span class="sxs-lookup"><span data-stu-id="4dba4-138">Sign up for an Azure account</span></span>
<span data-ttu-id="4dba4-139">Service Bus ile çalışmaya başlamak için bir Azure hesabınızın olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-139">You’ll need an Azure account in order to start working with Service Bus.</span></span> <span data-ttu-id="4dba4-140">Zaten bir yoksa, ücretsiz bir hesap için kaydolabilirsiniz [burada](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span><span class="sxs-lookup"><span data-stu-id="4dba4-140">If you do not already have one, you can sign up for a free account [here](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span></span>

### <a name="create-a-namespace"></a><span data-ttu-id="4dba4-141">Ad alanı oluşturma</span><span class="sxs-lookup"><span data-stu-id="4dba4-141">Create a namespace</span></span>
<span data-ttu-id="4dba4-142">Abonelik aldıktan sonra şunları yapabilirsiniz [hizmet ad alanı oluşturma](service-bus-create-namespace-portal.md).</span><span class="sxs-lookup"><span data-stu-id="4dba4-142">Once you have a subscription, you can [create a service namespace](service-bus-create-namespace-portal.md).</span></span> <span data-ttu-id="4dba4-143">Her ad alanı, Service Bus varlık kümesi için bir kapsam kapsayıcı görevi görür.</span><span class="sxs-lookup"><span data-stu-id="4dba4-143">Each namespace acts as a scoping container for a set of Service Bus entities.</span></span> <span data-ttu-id="4dba4-144">Yeni ad alanınızı tüm Service Bus hesaplarında benzersiz bir ad verin.</span><span class="sxs-lookup"><span data-stu-id="4dba4-144">Give your new namespace a unique name across all Service Bus accounts.</span></span> 

### <a name="install-the-nuget-package"></a><span data-ttu-id="4dba4-145">NuGet paket yüklemesi</span><span class="sxs-lookup"><span data-stu-id="4dba4-145">Install the NuGet package</span></span>
<span data-ttu-id="4dba4-146">Hizmet veri yolu ad alanını kullanmak için bir uygulama Service Bus derlemesine, özellikle Microsoft.ServiceBus.dll başvurmalıdır.</span><span class="sxs-lookup"><span data-stu-id="4dba4-146">To use the Service Bus namespace, an application must reference the Service Bus assembly, specifically Microsoft.ServiceBus.dll.</span></span> <span data-ttu-id="4dba4-147">Microsoft Azure SDK'sı bir parçası olarak bu derleme bulabilir ve yükleme şu adresten edinilebilir [Azure SDK'sını indirme sayfası](https://azure.microsoft.com/downloads/).</span><span class="sxs-lookup"><span data-stu-id="4dba4-147">You can find this assembly as part of the Microsoft Azure SDK, and the download is available at the [Azure SDK download page](https://azure.microsoft.com/downloads/).</span></span> <span data-ttu-id="4dba4-148">Ancak, [Service Bus NuGet paketi](https://www.nuget.org/packages/WindowsAzure.ServiceBus) Service Bus API'sini almanın ve uygulamanızı tüm Service Bus bağımlılıklarıyla yapılandırmanın en kolay yolu.</span><span class="sxs-lookup"><span data-stu-id="4dba4-148">However, the [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus) is the easiest way to get the Service Bus API and to configure your application with all of the Service Bus dependencies.</span></span>

### <a name="create-the-queue"></a><span data-ttu-id="4dba4-149">Kuyruk oluşturma</span><span class="sxs-lookup"><span data-stu-id="4dba4-149">Create the queue</span></span>
<span data-ttu-id="4dba4-150">Service Bus Mesajlaşma varlıkları (kuyruklar ve yayımlama/abonelik konuları) aracılığıyla gerçekleştirilir yönelik yönetim işlemlerini [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) sınıfı.</span><span class="sxs-lookup"><span data-stu-id="4dba4-150">Management operations for Service Bus messaging entities (queues and publish/subscribe topics) are performed via the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class.</span></span> <span data-ttu-id="4dba4-151">Service Bus kullanan bir [paylaşılan erişim imzası (SAS)](service-bus-sas.md) tabanlı güvenlik modeli.</span><span class="sxs-lookup"><span data-stu-id="4dba4-151">Service Bus uses a [Shared Access Signature (SAS)](service-bus-sas.md) based security model.</span></span> <span data-ttu-id="4dba4-152">[TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) sınıfı, bazı iyi bilinen belirteç sağlayıcılarını döndüren fabrikada yerleştirilen yöntemleri bir güvenlik belirteci sağlayıcısı gösterir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-152">The [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) class represents a security token provider with built-in factory methods returning some well-known token providers.</span></span> <span data-ttu-id="4dba4-153">Kullanacağız bir [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) SAS kimlik bilgilerini saklamak için yöntem.</span><span class="sxs-lookup"><span data-stu-id="4dba4-153">We’ll use a [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) method to hold the SAS credentials.</span></span> <span data-ttu-id="4dba4-154">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) örneği sonra Service Bus ad alanı ve belirteç sağlayıcı taban adresi ile yapılandırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="4dba4-154">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is then constructed with the base address of the Service Bus namespace and the token provider.</span></span>

<span data-ttu-id="4dba4-155">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) sınıfı oluşturmak, numaralandırır ve mesajlaşma varlıkları silmek için yöntemler sağlar.</span><span class="sxs-lookup"><span data-stu-id="4dba4-155">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="4dba4-156">Gösterir burada gösterilen kodu nasıl [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) örneği oluşturulur ve oluşturmak için kullanılan **DataCollectionQueue** sırası.</span><span class="sxs-lookup"><span data-stu-id="4dba4-156">The code that is shown here shows how the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is created and used to create the **DataCollectionQueue** queue.</span></span>

```csharp
Uri uri = ServiceBusEnvironment.CreateServiceUri("sb", 
                "test-blog", string.Empty);
string name = "RootManageSharedAccessKey";
string key = "abcdefghijklmopqrstuvwxyz";

TokenProvider tokenProvider = 
    TokenProvider.CreateSharedAccessSignatureTokenProvider(name, key);
NamespaceManager namespaceManager = 
    new NamespaceManager(uri, tokenProvider);
namespaceManager.CreateQueue("DataCollectionQueue");
```

<span data-ttu-id="4dba4-157">Vardır Not overloads [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) ayarlanmasına kuyruğun özelliklerini etkinleştirme yöntemi.</span><span class="sxs-lookup"><span data-stu-id="4dba4-157">Note that there are overloads of the [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method that enable properties of the queue to be tuned.</span></span> <span data-ttu-id="4dba4-158">Örneğin, kuyruğa gönderilen iletiler için varsayılan yaşam süresi (TTL) değerini ayarlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4dba4-158">For example, you can set the default time-to-live (TTL) value for messages sent to the queue.</span></span>

### <a name="send-messages-to-the-queue"></a><span data-ttu-id="4dba4-159">Kuyruğa ileti gönderme</span><span class="sxs-lookup"><span data-stu-id="4dba4-159">Send messages to the queue</span></span>
<span data-ttu-id="4dba4-160">Hizmet veri yolu varlıklar üzerinde çalıştırma işlemleri için; Örneğin, ileti gönderme ve alma, bir uygulama önce oluşturmanız gerekir bir [Eventhubclient](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) nesnesi.</span><span class="sxs-lookup"><span data-stu-id="4dba4-160">For run-time operations on Service Bus entities; for example, sending and receiving messages, an application must first create a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) object.</span></span> <span data-ttu-id="4dba4-161">Benzer şekilde [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) sınıfı, [Eventhubclient](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) örneği, hizmet ad alanı ve belirteç sağlayıcı temel adresinden oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="4dba4-161">Similar to the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class, the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance is created from the base address of the service namespace and the token provider.</span></span>

```csharp
 BrokeredMessage bm = new BrokeredMessage(salesData);
 bm.Label = "SalesReport";
 bm.Properties["StoreName"] = "Redmond";
 bm.Properties["MachineID"] = "POS_1";
```

<span data-ttu-id="4dba4-162">Gönderilen iletileri ve Service Bus alınan örnekleridir [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) sınıfı.</span><span class="sxs-lookup"><span data-stu-id="4dba4-162">Messages sent to, and received from Service Bus queues are instances of the [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) class.</span></span> <span data-ttu-id="4dba4-163">Bu sınıf bir standart özellikler kümesi içerir (gibi [etiket](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) ve [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), bir uygulama özellikleri tutmak için kullanılan bir sözlük ve rastgele uygulama verileri gövdesi içerir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-163">This class consists of a set of standard properties (such as [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) and [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), a dictionary that is used to hold application properties, and a body of arbitrary application data.</span></span> <span data-ttu-id="4dba4-164">Bir uygulama herhangi bir seri hale getirilebilir nesnesi geçirerek gövdesi ayarlayabilirsiniz (aşağıdaki örnekte, geçirir bir **SalesData** POS terminal durumundan satış verilerini temsil eden nesne), hangi kullanacak [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) nesneyi serileştirmek için.</span><span class="sxs-lookup"><span data-stu-id="4dba4-164">An application can set the body by passing in any serializable object (the following example passes in a **SalesData** object that represents the sales data from the POS terminal), which will use the [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) to serialize the object.</span></span> <span data-ttu-id="4dba4-165">Alternatif olarak, bir [akış](https://msdn.microsoft.com/library/system.io.stream.aspx) nesne sağlanabilir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-165">Alternatively, a [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx) object can be provided.</span></span>

<span data-ttu-id="4dba4-166">Bu örnekte belirli bir sıradaki iletiler göndermek için en kolay yolu **DataCollectionQueue**, kullanmaktır [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) oluşturmak için bir [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) doğrudan nesnesi gelen [Eventhubclient](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) örneği.</span><span class="sxs-lookup"><span data-stu-id="4dba4-166">The easiest way to send messages to a given queue, in our case the **DataCollectionQueue**, is to use [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) to create a [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) object directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance.</span></span>

```csharp
MessageSender sender = factory.CreateMessageSender("DataCollectionQueue");
sender.Send(bm);
```

### <a name="receiving-messages-from-the-queue"></a><span data-ttu-id="4dba4-167">Kuyruktan ileti alma</span><span class="sxs-lookup"><span data-stu-id="4dba4-167">Receiving messages from the queue</span></span>
<span data-ttu-id="4dba4-168">Kuyruktan iletileri almak için kullanabileceğiniz bir [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) doğrudan oluşturduğunuz nesne [Eventhubclient](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) kullanarak [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span><span class="sxs-lookup"><span data-stu-id="4dba4-168">To receive messages from the queue, you can use a [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) object which you create directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) using [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span></span> <span data-ttu-id="4dba4-169">İleti alıcılar, iki farklı modda çalışabilir: **ReceiveAndDelete** ve **PeekLock**.</span><span class="sxs-lookup"><span data-stu-id="4dba4-169">Message receivers can work in two different modes: **ReceiveAndDelete** and **PeekLock**.</span></span> <span data-ttu-id="4dba4-170">[ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) ileti alıcı oluşturulduğunda bir parametre olarak ayarlanmış [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) çağırın.</span><span class="sxs-lookup"><span data-stu-id="4dba4-170">The [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) is set when the message receiver is created, as a parameter to the [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) call.</span></span>

<span data-ttu-id="4dba4-171">Kullanırken **ReceiveAndDelete** modu, alma tek bir işlemdir; diğer bir deyişle, Service Bus isteği aldığında, iletiyi kullanılıyor olarak işaretler ve uygulamaya döndürür.</span><span class="sxs-lookup"><span data-stu-id="4dba4-171">When using the **ReceiveAndDelete** mode, the receive is a single-shot operation; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="4dba4-172">**ReceiveAndDelete** modu en basit modeldir ve, uygulama tolerans gerçekleşmesi için bir hata varsa bir ileti işlenmiyor senaryolarda en iyi şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="4dba4-172">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message if a failure were to occur.</span></span> <span data-ttu-id="4dba4-173">Bu durumu daha iyi anlamak için müşterinin bir alma isteği bildirdiğini ve bu isteğin işlenmeden çöktüğünü varsayın.</span><span class="sxs-lookup"><span data-stu-id="4dba4-173">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="4dba4-174">Service Bus iletiyi kullanılıyor olarak işaretlenmiş olduğundan, ne zaman iletileri tekrar, kullanmaya başlar ve uygulama yeniden başlatılmadan, kilitlenme önce kullanılan iletiyi atlamış olur.</span><span class="sxs-lookup"><span data-stu-id="4dba4-174">Since Service Bus marked the message as being consumed, when the application restarts and starts consuming messages again, it will have missed the message that was consumed before the crash.</span></span>

<span data-ttu-id="4dba4-175">İçinde **PeekLock** modu, alma, iletilere veremeyen uygulamaları desteklemenin mümkün kılar bir iki aşamalı işlemi haline gelir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-175">In **PeekLock** mode, the receive becomes a two-stage operation, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="4dba4-176">Service Bus isteği aldığında, kullanılacak sonraki iletiyi bulur, diğer tüketicilerin iletiyi almasını engellemek için kilitler ve uygulamaya döndürür.</span><span class="sxs-lookup"><span data-stu-id="4dba4-176">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers receiving it, and then returns it to the application.</span></span> <span data-ttu-id="4dba4-177">Uygulama iletiyi işlemeyi tamamladıktan sonra (veya iletiyi daha sonra işlemek üzere güvenli şekilde depoladıktan sonra) alınan iletide [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) yöntemini çağırarak alma işleminin ikinci aşamasını tamamlar.</span><span class="sxs-lookup"><span data-stu-id="4dba4-177">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="4dba4-178">Hizmet veri yolu gördüğünde [tam](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) çağrısı, iletiyi kullanılıyor olarak işaretler.</span><span class="sxs-lookup"><span data-stu-id="4dba4-178">When Service Bus sees the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) call, it marks the message as being consumed.</span></span>

<span data-ttu-id="4dba4-179">Diğer iki sonuçlar mümkündür.</span><span class="sxs-lookup"><span data-stu-id="4dba4-179">Two other outcomes are possible.</span></span> <span data-ttu-id="4dba4-180">İlk olarak, uygulama herhangi bir nedenden dolayı iletisi işleyemedi ise işleyememesi [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) alınan iletide (yerine [tam](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="4dba4-180">First, if the application is unable to process the message for some reason, it can call [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="4dba4-181">Bu iletinin kilidini açmak ve aynı tüketici veya başka bir Tamamlanıyor tüketici tarafından tekrar alınabilir kullanılabilir hale getirmek Service Bus neden olur.</span><span class="sxs-lookup"><span data-stu-id="4dba4-181">This causes Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another completing consumer.</span></span> <span data-ttu-id="4dba4-182">İkinci olarak, kilidi ile ilişkili bir zaman aşımı yoktur ve uygulama (örneğin, uygulama çökerse) hizmet veri yolu ileti kilidini açmak ve onu kilit zaman aşımı dolmadan önce iletiyi işleyemezse kullanılabilir olması yeniden alınan) temelde gerçekleştiren bir [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) işlemi varsayılan olarak).</span><span class="sxs-lookup"><span data-stu-id="4dba4-182">Second, there is a time-out associated with the lock and if the application cannot process the message before the lock time-out expires (for example, if the application crashes), then Service Bus will unlock the message and make it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="4dba4-183">Sonra uygulama çökerse, ileti önce işleme Not [tam](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) isteği yayınlandı, başlatıldığında ileti uygulamaya tekrar teslim edilir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-183">Note that if the application crashes after it processes the message but before the [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) request was issued, the message will be redelivered to the application when it restarts.</span></span> <span data-ttu-id="4dba4-184">Bu genellikle adlandırılır * en az bir kez * işleniyor.</span><span class="sxs-lookup"><span data-stu-id="4dba4-184">This is often termed *At Least Once * processing.</span></span> <span data-ttu-id="4dba4-185">Başka bir deyişle, her ileti en az bir kez işlenir ancak belirli durumlarda aynı ileti yeniden teslim.</span><span class="sxs-lookup"><span data-stu-id="4dba4-185">This means that each message will be processed at least once but in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="4dba4-186">Senaryo yinelenen işlemeyi kabul etmiyorsa ek mantık yinelemeleri algılamak için uygulamada gereklidir.</span><span class="sxs-lookup"><span data-stu-id="4dba4-186">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates.</span></span> <span data-ttu-id="4dba4-187">Bu temel sağlanabilir [MessageID](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) iletinin özelliği.</span><span class="sxs-lookup"><span data-stu-id="4dba4-187">This can be achieved based on the [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) property of the message.</span></span> <span data-ttu-id="4dba4-188">Bu özelliğin değeri teslimat denemelerinde.</span><span class="sxs-lookup"><span data-stu-id="4dba4-188">The value of this property remains constant across delivery attempts.</span></span> <span data-ttu-id="4dba4-189">Bu adlandırılır *tam olarak bir kez* işleme.</span><span class="sxs-lookup"><span data-stu-id="4dba4-189">This is termed *Exactly Once* processing.</span></span>

<span data-ttu-id="4dba4-190">Burada gösterilen kodu alan ve işleyen bir iletiyi kullanarak **PeekLock** yoksa varsayılan değer modu [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) değeri açıkça sağlanır.</span><span class="sxs-lookup"><span data-stu-id="4dba4-190">The code that is shown here receives and processes a message using the **PeekLock** mode, which is the default if no [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) value is explicitly provided.</span></span>

```csharp
MessageReceiver receiver = factory.CreateMessageReceiver("DataCollectionQueue");
BrokeredMessage receivedMessage = receiver.Receive();
try
{
    ProcessMessage(receivedMessage);
    receivedMessage.Complete();
}
catch (Exception e)
{
    receivedMessage.Abandon();
}
```

### <a name="use-the-queue-client"></a><span data-ttu-id="4dba4-191">Sıra istemcisini kullanın</span><span class="sxs-lookup"><span data-stu-id="4dba4-191">Use the queue client</span></span>
<span data-ttu-id="4dba4-192">Daha önce oluşturulan bu bölümdeki örnekleri [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) ve [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) doğrudan nesneleri [Eventhubclient](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) göndermek ve gelen iletileri almak için , sırasıyla sırası.</span><span class="sxs-lookup"><span data-stu-id="4dba4-192">The examples earlier in this section created [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) and [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objects directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) to send and receive messages from the queue, respectively.</span></span> <span data-ttu-id="4dba4-193">Alternatif bir yaklaşım kullanmaktır bir [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) destekleyen hem gönderme ve alma işlemlerinin oturumları gibi daha gelişmiş özellikleri yanı sıra nesnesi.</span><span class="sxs-lookup"><span data-stu-id="4dba4-193">An alternative approach is to use a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object, which supports both send and receive operations in addition to more advanced features, such as sessions.</span></span>

```csharp
QueueClient queueClient = factory.CreateQueueClient("DataCollectionQueue");
queueClient.Send(bm);

BrokeredMessage message = queueClient.Receive();

try
{
    ProcessMessage(message);
    message.Complete();
}
catch (Exception e)
{
    message.Abandon();
} 
```

## <a name="next-steps"></a><span data-ttu-id="4dba4-194">Sonraki adımlar</span><span class="sxs-lookup"><span data-stu-id="4dba4-194">Next steps</span></span>
<span data-ttu-id="4dba4-195">Sıraların öğrendiğinize göre bkz: [Service Bus konuları ve abonelikleri kullanan uygulamalar oluşturmak](service-bus-create-topics-subscriptions.md) Service Bus konuları ve abonelikleri Yayımla ve abone yeteneklerini kullanarak bu tartışma devam etmek için.</span><span class="sxs-lookup"><span data-stu-id="4dba4-195">Now that you've learned the basics of queues, see [Create applications that use Service Bus topics and subscriptions](service-bus-create-topics-subscriptions.md) to continue this discussion using the publish/subscribe capabilities of Service Bus topics and subscriptions.</span></span>

