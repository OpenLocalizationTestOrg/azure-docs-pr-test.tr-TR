---
title: "Azure Service Bus kuyrukları, konu başlıkları ve abonelikleri Mesajlaşma genel bakış | Microsoft Docs"
description: "Service Bus Mesajlaşma genel bakış."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: a306ced4-74e9-47c6-990a-d9c47efa31d5
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 06/28/2017
ms.author: sethm
ms.openlocfilehash: 00f9f38fbae028486270053dedb4df580a3f1a44
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/18/2017
---
# <a name="service-bus-queues-topics-and-subscriptions"></a><span data-ttu-id="2b174-103">Service Bus kuyrukları, konu başlıkları ve abonelikleri</span><span class="sxs-lookup"><span data-stu-id="2b174-103">Service Bus queues, topics, and subscriptions</span></span>

<span data-ttu-id="2b174-104">Microsoft Azure Service Bus güvenilir message queuing bulut tabanlı, ileti odaklı Ara teknolojilerini ve dayanıklı yayımlama/Mesajlaşma abonelik, bir kümesini destekler.</span><span class="sxs-lookup"><span data-stu-id="2b174-104">Microsoft Azure Service Bus supports a set of cloud-based, message-oriented middleware technologies including reliable message queuing and durable publish/subscribe messaging.</span></span> <span data-ttu-id="2b174-105">Bu "aracılı" Mesajlaşma işlevleri, ardından destek yayımlama-abone olma Mesajlaşma özellikleri, zamana bağlı ayırma ve Yük Dengeleme Service Bus doku Mesajlaşma kullanarak ayrılmış olarak düşünülebilir.</span><span class="sxs-lookup"><span data-stu-id="2b174-105">These "brokered" messaging capabilities can be thought of as decoupled messaging features that support publish-subscribe, temporal decoupling, and load balancing scenarios using the Service Bus messaging fabric.</span></span> <span data-ttu-id="2b174-106">Ayrılmış iletişim birçok avantaj sunar. Örneğin, sunucular ve istemciler gerektiğinde bağlantı kurabilir ve kendi işlemlerini zaman uyumsuz olarak gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="2b174-106">Decoupled communication has many advantages; for example, clients and servers can connect as needed and perform their operations in an asynchronous fashion.</span></span>

<span data-ttu-id="2b174-107">Hizmet veri yolundaki özünü Mesajlaşma özelliklerini Mesajlaşma varlıkları kuyruklar, konuları ve abonelikleri ve kuralları/eylemleri ' dir.</span><span class="sxs-lookup"><span data-stu-id="2b174-107">The messaging entities that form the core of the messaging capabilities in Service Bus are queues, topics and subscriptions, and rules/actions.</span></span>

## <a name="queues"></a><span data-ttu-id="2b174-108">Kuyruklar</span><span class="sxs-lookup"><span data-stu-id="2b174-108">Queues</span></span>

<span data-ttu-id="2b174-109">Kuyruklar teklif *ilk gelen, giden ilk* (FIFO yöntemine göre) ileti teslimi bir veya birden çok rakip tüketiciye.</span><span class="sxs-lookup"><span data-stu-id="2b174-109">Queues offer *First In, First Out* (FIFO) message delivery to one or more competing consumers.</span></span> <span data-ttu-id="2b174-110">Diğer bir deyişle, iletiler genellikle alınan ve hangi kuyruğa eklendikleri ve her ileti alındı ve yalnızca bir ileti tüketicisi tarafından işlenen bir düzende alıcılar tarafından işlenen beklenir.</span><span class="sxs-lookup"><span data-stu-id="2b174-110">That is, messages are typically expected to be received and processed by the receivers in the order in which they were added to the queue, and each message is received and processed by only one message consumer.</span></span> <span data-ttu-id="2b174-111">Kuyrukları kullanmanın önemli bir avantajı "zamana bağlı ayırma" uygulama bileşenlerinin elde etmektir.</span><span class="sxs-lookup"><span data-stu-id="2b174-111">A key benefit of using queues is to achieve "temporal decoupling" of application components.</span></span> <span data-ttu-id="2b174-112">İletileri işlemi kuyrukta depolandığından diğer bir deyişle, üreticiler (göndericiler) ve tüketicilerin (Alıcılar) aynı anda ileti alma ve gönderme gerekmez.</span><span class="sxs-lookup"><span data-stu-id="2b174-112">In other words, the producers (senders) and consumers (receivers) do not have to be sending and receiving messages at the same time, because messages are stored durably in the queue.</span></span> <span data-ttu-id="2b174-113">Ayrıca, üretici işlemek ve iletileri göndermek devam etmek için bir yanıt beklerken yok.</span><span class="sxs-lookup"><span data-stu-id="2b174-113">Furthermore, the producer does not have to wait for a reply from the consumer in order to continue to process and send messages.</span></span>

<span data-ttu-id="2b174-114">", Üreticilerin ve tüketicilerin iletileri farklı hızlarda gönderip almasına sağlayan Yük Dengeleme" bir avantaj ise.</span><span class="sxs-lookup"><span data-stu-id="2b174-114">A related benefit is "load leveling," which enables producers and consumers to send and receive messages at different rates.</span></span> <span data-ttu-id="2b174-115">Birçok uygulamada, sistem yükünün zaman içinde değişir; Bununla birlikte, her iş birimi için gereken işleme süresi genellikle sabittir.</span><span class="sxs-lookup"><span data-stu-id="2b174-115">In many applications, the system load varies over time; however, the processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="2b174-116">Aracılığıyla ileti üreticileri ve tüketicileri bir kuyruk, kullanıcı uygulamanın yalnızca ortalama yük yoğun yük yerine işlemek için kullanılacak olduğunu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="2b174-116">Intermediating message producers and consumers with a queue means that the consuming application only has to be provisioned to be able to handle average load instead of peak load.</span></span> <span data-ttu-id="2b174-117">Gelen yük hacmi değiştikçe kuyruğun derinliği artar ve daralır.</span><span class="sxs-lookup"><span data-stu-id="2b174-117">The depth of the queue grows and contracts as the incoming load varies.</span></span> <span data-ttu-id="2b174-118">Bu, doğrudan para uygulama yükünü sunmak için gereken altyapı miktarı ile kaydeder.</span><span class="sxs-lookup"><span data-stu-id="2b174-118">This directly saves money with regard to the amount of infrastructure required to service the application load.</span></span> <span data-ttu-id="2b174-119">Yük arttıkça kuyruktan okunmak üzere daha fazla çalışan işlemi eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="2b174-119">As the load increases, more worker processes can be added to read from the queue.</span></span> <span data-ttu-id="2b174-120">Her ileti yalnızca bir çalışan işlemi tarafından işlenir.</span><span class="sxs-lookup"><span data-stu-id="2b174-120">Each message is processed by only one of the worker processes.</span></span> <span data-ttu-id="2b174-121">Ayrıca, çalışan bilgisayarlar işleme gücünü göre farklılık gösterse bile iletileri kendi maksimum hızında çeker olarak çalışan bilgisayarlar için en iyi kullanımı bu çekme tabanlı yük dengeleme sağlar.</span><span class="sxs-lookup"><span data-stu-id="2b174-121">Furthermore, this pull-based load balancing allows for optimum use of the worker computers even if the worker computers differ with regard to processing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="2b174-122">Bu desen genellikle "tüketici rekabet" düzeni olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="2b174-122">This pattern is often termed the "competing consumer" pattern.</span></span>

<span data-ttu-id="2b174-123">İleti üreticileri ve tüketicileri arasında ara için kuyrukları kullanma bileşenleri arasındaki yapısında bir gevşek bağlantı sağlar.</span><span class="sxs-lookup"><span data-stu-id="2b174-123">Using queues to intermediate between message producers and consumers provides an inherent loose coupling between the components.</span></span> <span data-ttu-id="2b174-124">Üreticileri ve tüketicileri birbirinden farkında değildir çünkü bir tüketici üretici üzerinde hiçbir etkisi olmadan yükseltilebilir.</span><span class="sxs-lookup"><span data-stu-id="2b174-124">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on the producer.</span></span>

<span data-ttu-id="2b174-125">Bir kuyruk oluşturma çok adımlı bir işlemdir.</span><span class="sxs-lookup"><span data-stu-id="2b174-125">Creating a queue is a multi-step process.</span></span> <span data-ttu-id="2b174-126">Üzerinden Service Bus Mesajlaşma varlıkları (kuyruklar ve konu başlıkları) yönelik yönetim işlemlerini gerçekleştirmek [Microsoft.ServiceBus.NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) Service Bus ad alanı taban adresini sağlayarak oluşturulan sınıfı ve kullanıcı kimlik bilgileri.</span><span class="sxs-lookup"><span data-stu-id="2b174-126">You perform management operations for Service Bus messaging entities (both queues and topics) via the [Microsoft.ServiceBus.NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) class, which is constructed by supplying the base address of the Service Bus namespace and the user credentials.</span></span> <span data-ttu-id="2b174-127">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) oluşturmak, numaralandırır ve mesajlaşma varlıkları silmek için yöntemler sağlar.</span><span class="sxs-lookup"><span data-stu-id="2b174-127">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="2b174-128">Oluşturduktan sonra bir [Microsoft.ServiceBus.TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) nesnesinden SAS adını ve anahtar ve bir hizmet ad alanı Yönetim nesnesi, kullanabileceğiniz [Microsoft.ServiceBus.NamespaceManager.CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_)sırayı oluşturmak için yöntem.</span><span class="sxs-lookup"><span data-stu-id="2b174-128">After creating a [Microsoft.ServiceBus.TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) object from the SAS name and key, and a service namespace management object, you can use the [Microsoft.ServiceBus.NamespaceManager.CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method to create the queue.</span></span> <span data-ttu-id="2b174-129">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="2b174-129">For example:</span></span>

```csharp
// Create management credentials
TokenProvider credentials = TokenProvider.CreateSharedAccessSignatureTokenProvider(sasKeyName,sasKeyValue);
// Create namespace client
NamespaceManager namespaceClient = new NamespaceManager(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials);
```

<span data-ttu-id="2b174-130">Ardından, bağımsız değişken olarak Service Bus URI'si ile bir sıra nesnesi ve bir Mesajlaşma fabrikası oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2b174-130">You can then create a queue object and a messaging factory with the Service Bus URI as an argument.</span></span> <span data-ttu-id="2b174-131">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="2b174-131">For example:</span></span>

```csharp
QueueDescription myQueue;
myQueue = namespaceClient.CreateQueue("TestQueue");
MessagingFactory factory = MessagingFactory.Create(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials); 
QueueClient myQueueClient = factory.CreateQueueClient("TestQueue");
```

<span data-ttu-id="2b174-132">Sonra iletileri kuyruğa gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2b174-132">You can then send messages to the queue.</span></span> <span data-ttu-id="2b174-133">Örneğin, adında aracılı iletilerin listesini varsa `MessageList`, kodu aşağıdakine benzer görünür:</span><span class="sxs-lookup"><span data-stu-id="2b174-133">For example, if you have a list of brokered messages called `MessageList`, the code appears similar to the following:</span></span>

```csharp
for (int count = 0; count < 6; count++)
{
    var issue = MessageList[count];
    issue.Label = issue.Properties["IssueTitle"].ToString();
    myQueueClient.Send(issue);
}
```

<span data-ttu-id="2b174-134">Ardından iletileri sıradan aşağıdaki gibi alabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="2b174-134">You then receive messages from the queue as follows:</span></span>

```csharp
while ((message = myQueueClient.Receive(new TimeSpan(hours: 0, minutes: 0, seconds: 5))) != null)
    {
        Console.WriteLine(string.Format("Message received: {0}, {1}, {2}", message.SequenceNumber, message.Label, message.MessageId));
        message.Complete();

        Console.WriteLine("Processing message (sleeping...)");
        Thread.Sleep(1000);
    }
```

<span data-ttu-id="2b174-135">İçinde [ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode) modu, alma işlemi tek; diğer bir deyişle, Service Bus isteği aldığında, iletiyi kullanılıyor olarak işaretler ve uygulamaya döndürür.</span><span class="sxs-lookup"><span data-stu-id="2b174-135">In the [ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode) mode, the receive operation is single-shot; that is, when Service Bus receives the request, it marks the message as being consumed and returns it to the application.</span></span> <span data-ttu-id="2b174-136">**ReceiveAndDelete** modu en basit modeldir ve senaryoları uygulama içinde tolerans bir arıza olması durumunda bir ileti işlenirken değil en iyi şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="2b174-136">**ReceiveAndDelete** mode is the simplest model and works best for scenarios in which the application can tolerate not processing a message in the event of a failure.</span></span> <span data-ttu-id="2b174-137">Bu durumu daha iyi anlamak için müşterinin bir alma isteği bildirdiğini ve bu isteğin işlenmeden çöktüğünü varsayın.</span><span class="sxs-lookup"><span data-stu-id="2b174-137">To understand this, consider a scenario in which the consumer issues the receive request and then crashes before processing it.</span></span> <span data-ttu-id="2b174-138">Service Bus iletiyi uygulama yeniden başlatılıp iletileri tekrar kullanmaya başladığında olduğunda, kullanılıyor olarak işaretler çünkü çökmenin öncesinde kullanılan iletiyi atlamış olur.</span><span class="sxs-lookup"><span data-stu-id="2b174-138">Because Service Bus marks the message as being consumed, when the application restarts and begins consuming messages again, it will have missed the message that was consumed prior to the crash.</span></span>

<span data-ttu-id="2b174-139">İçinde [PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode) modu, alma işlemi hale iki aşamalı hangi, iletilere veremeyen uygulamaları desteklemenin mümkün kılar.</span><span class="sxs-lookup"><span data-stu-id="2b174-139">In [PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode) mode, the receive operation becomes two-stage, which makes it possible to support applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="2b174-140">Service Bus isteği aldığında, kullanılacak sonraki iletiyi bulur, diğer tüketicilerin iletiyi almasını engellemek için kilitler ve uygulamaya döndürür.</span><span class="sxs-lookup"><span data-stu-id="2b174-140">When Service Bus receives the request, it finds the next message to be consumed, locks it to prevent other consumers from receiving it, and then returns it to the application.</span></span> <span data-ttu-id="2b174-141">Uygulama iletiyi işlemeyi tamamladıktan sonra (veya iletiyi daha sonra işlemek üzere güvenli şekilde depoladıktan sonra) alınan iletide [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) yöntemini çağırarak alma işleminin ikinci aşamasını tamamlar.</span><span class="sxs-lookup"><span data-stu-id="2b174-141">After the application finishes processing the message (or stores it reliably for future processing), it completes the second stage of the receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on the received message.</span></span> <span data-ttu-id="2b174-142">Hizmet veri yolu gördüğünde **tam** çağrısı, iletiyi kullanılıyor olarak işaretler.</span><span class="sxs-lookup"><span data-stu-id="2b174-142">When Service Bus sees the **Complete** call, it marks the message as being consumed.</span></span>

<span data-ttu-id="2b174-143">Uygulama herhangi bir nedenden dolayı iletisi işleyemedi ise çağırabilirsiniz [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) alınan iletide yöntemi (yerine [tam](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="2b174-143">If the application is unable to process the message for some reason, it can call the [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) method on the received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="2b174-144">Bu iletinin kilidini açmak ve aynı tüketici veya başka bir rakip tüketici tarafından tekrar alınabilir kullanılabilir hale getirmek hizmet veri yolu sağlar.</span><span class="sxs-lookup"><span data-stu-id="2b174-144">This enables Service Bus to unlock the message and make it available to be received again, either by the same consumer or by another competing consumer.</span></span> <span data-ttu-id="2b174-145">İkincisi, kilidi ile ilişkili bir zaman aşımı yoktur ve (örneğin, uygulama çökerse) Service Bus iletinin kilidini açar ve kolaylaştırır kilit zaman aşımı dolmadan önce iletiyi işlemek uygulama başarısız olursa kullanılabilir olması yeniden alınan) temelde gerçekleştiren bir [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) işlemi varsayılan olarak).</span><span class="sxs-lookup"><span data-stu-id="2b174-145">Secondly, there is a timeout associated with the lock and if the application fails to process the message before the lock timeout expires (for example, if the application crashes), then Service Bus unlocks the message and makes it available to be received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="2b174-146">Uygulama ileti, ancak önce çökmesi durumunda, unutmayın **tam** isteği bildirilmeden, yeniden başlatıldığında ileti uygulamaya tekrar teslim.</span><span class="sxs-lookup"><span data-stu-id="2b174-146">Note that in the event that the application crashes after processing the message, but before the **Complete** request is issued, the message is redelivered to the application when it restarts.</span></span> <span data-ttu-id="2b174-147">Bu genellikle adlandırılır *en az bir kez* işleme; diğer bir deyişle, her ileti en az bir kez işlenir.</span><span class="sxs-lookup"><span data-stu-id="2b174-147">This is often called *At Least Once* processing; that is, each message is processed at least once.</span></span> <span data-ttu-id="2b174-148">Ancak, belirli durumlarda aynı ileti yeniden teslim edilebilir.</span><span class="sxs-lookup"><span data-stu-id="2b174-148">However, in certain situations the same message may be redelivered.</span></span> <span data-ttu-id="2b174-149">Senaryo yinelenen işlemeyi genişliğinin kullanılmasını sonra ek mantık göre elde edilebilir yinelemeleri algılamak için uygulamada gereklidir **MessageID** boyunca sabit kalır iletinin özelliği Teslim girişimleri.</span><span class="sxs-lookup"><span data-stu-id="2b174-149">If the scenario cannot tolerate duplicate processing, then additional logic is required in the application to detect duplicates which can be achieved based upon the **MessageId** property of the message, which remains constant across delivery attempts.</span></span> <span data-ttu-id="2b174-150">Bu olarak bilinir *tam olarak bir kez* işleme.</span><span class="sxs-lookup"><span data-stu-id="2b174-150">This is known as *Exactly Once* processing.</span></span>

## <a name="topics-and-subscriptions"></a><span data-ttu-id="2b174-151">Konular ve abonelikler</span><span class="sxs-lookup"><span data-stu-id="2b174-151">Topics and subscriptions</span></span>
<span data-ttu-id="2b174-152">Kuyruklar, her ileti tek bir tüketici tarafından işlenir aksine *konuları* ve *abonelikleri* iletişim, bir çok form sağladığınız bir *Yayımlama/abonelik* düzeni.</span><span class="sxs-lookup"><span data-stu-id="2b174-152">In contrast to queues, in which each message is processed by a single consumer, *topics* and *subscriptions* provide a one-to-many form of communication, in a *publish/subscribe* pattern.</span></span> <span data-ttu-id="2b174-153">Alıcılar çok fazla sayıda ölçekleme için yararlı, yayımlanan her ileti konuya kaydedilen her abonelik için kullanılabilir yapılır.</span><span class="sxs-lookup"><span data-stu-id="2b174-153">Useful for scaling to very large numbers of recipients, each published message is made available to each subscription registered with the topic.</span></span> <span data-ttu-id="2b174-154">İletiler konu başlığına gönderilen ve bir veya daha fazla ilişkili abonelik, bir abonelik başına temelinde ayarlanabilir filtre kuralları bağlı olarak teslim edilir.</span><span class="sxs-lookup"><span data-stu-id="2b174-154">Messages are sent to a topic and delivered to one or more associated subscriptions, depending on filter rules that can be set on a per-subscription basis.</span></span> <span data-ttu-id="2b174-155">Abonelikler ek filtreler almak istediği iletileri kısıtlamak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2b174-155">The subscriptions can use additional filters to restrict the messages that they want to receive.</span></span> <span data-ttu-id="2b174-156">İletileri gönderilir aynı şekilde konu kuyruğa gönderilmeden ancak iletileri alınmayan konusundan doğrudan.</span><span class="sxs-lookup"><span data-stu-id="2b174-156">Messages are sent to a topic in the same way they are sent to a queue, but messages are not received from the topic directly.</span></span> <span data-ttu-id="2b174-157">Bunun yerine, bunlar aboneliklerden alınır.</span><span class="sxs-lookup"><span data-stu-id="2b174-157">Instead, they are received from subscriptions.</span></span> <span data-ttu-id="2b174-158">Bir konu aboneliği konu başlığına gönderilen iletilerin kopyalarını alan sanal kuyruğa benzer.</span><span class="sxs-lookup"><span data-stu-id="2b174-158">A topic subscription resembles a virtual queue that receives copies of the messages that are sent to the topic.</span></span> <span data-ttu-id="2b174-159">İletileri bir abonelikten bir kuyruktan alınan şekilde aynı aldı.</span><span class="sxs-lookup"><span data-stu-id="2b174-159">Messages are received from a subscription identically to the way they are received from a queue.</span></span>

<span data-ttu-id="2b174-160">Karşılaştırma, aracılığıyla doğrudan bir konuya bir kuyruk iletisi göndererek işlevselliğini eşler ve bir abonelik için ileti alma işlevselliğini eşler.</span><span class="sxs-lookup"><span data-stu-id="2b174-160">By way of comparison, the message-sending functionality of a queue maps directly to a topic and its message-receiving functionality maps to a subscription.</span></span> <span data-ttu-id="2b174-161">Bunun yanı sıra, bu abonelik sıraları açısından bu bölümde daha önce açıklanan aynı düzenleri desteği anlamına gelir: Rakip tüketici, zamana bağlı ayırma, Yük Dengeleme ve Yük Dengeleme.</span><span class="sxs-lookup"><span data-stu-id="2b174-161">Among other things, this means that subscriptions support the same patterns described earlier in this section with regard to queues: competing consumer, temporal decoupling, load leveling, and load balancing.</span></span>

<span data-ttu-id="2b174-162">Bir konu oluşturma önceki bölümdeki örnekte gösterildiği gibi bir kuyruk oluşturmak için benzerdir.</span><span class="sxs-lookup"><span data-stu-id="2b174-162">Creating a topic is similar to creating a queue, as shown in the example in the previous section.</span></span> <span data-ttu-id="2b174-163">Hizmet URI'si oluşturmak ve ardından [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) ad alanı istemci oluşturmak için sınıfı.</span><span class="sxs-lookup"><span data-stu-id="2b174-163">Create the service URI, and then use the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class to create the namespace client.</span></span> <span data-ttu-id="2b174-164">Kullanarak bir konu sonra oluşturabilirsiniz [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_) yöntemi.</span><span class="sxs-lookup"><span data-stu-id="2b174-164">You can then create a topic using the [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_) method.</span></span> <span data-ttu-id="2b174-165">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="2b174-165">For example:</span></span>

```csharp
TopicDescription dataCollectionTopic = namespaceClient.CreateTopic("DataCollectionTopic");
```

<span data-ttu-id="2b174-166">Ardından, abonelikleri istendiği gibi ekleyin:</span><span class="sxs-lookup"><span data-stu-id="2b174-166">Next, add subscriptions as desired:</span></span>

```csharp
SubscriptionDescription myAgentSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Inventory");
SubscriptionDescription myAuditSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Dashboard");
```

<span data-ttu-id="2b174-167">Daha sonra bir konu istemci oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2b174-167">You can then create a topic client.</span></span> <span data-ttu-id="2b174-168">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="2b174-168">For example:</span></span>

```csharp
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider);
TopicClient myTopicClient = factory.CreateTopicClient(myTopic.Path)
```

<span data-ttu-id="2b174-169">İleti gönderen kullanarak göndermek ve önceki bölümde gösterildiği gibi konu gelen ve giden iletileri alacak.</span><span class="sxs-lookup"><span data-stu-id="2b174-169">Using the message sender, you can send and receive messages to and from the topic, as shown in the previous section.</span></span> <span data-ttu-id="2b174-170">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="2b174-170">For example:</span></span>

```csharp
foreach (BrokeredMessage message in messageList)
{
    myTopicClient.Send(message);
    Console.WriteLine(
    string.Format("Message sent: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

<span data-ttu-id="2b174-171">Benzer şekilde sıralar, ileti kullanarak bir abonelik alındığında bir [SubscriptionClient](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient) yerine Nesne bir [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) nesnesi.</span><span class="sxs-lookup"><span data-stu-id="2b174-171">Similar to queues, messages are received from a subscription using a [SubscriptionClient](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient) object instead of a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object.</span></span> <span data-ttu-id="2b174-172">Konu adı, abonelik ve (isteğe bağlı) alma modu adını parametre olarak geçirme abonelik istemci oluşturun.</span><span class="sxs-lookup"><span data-stu-id="2b174-172">Create the subscription client, passing the name of the topic, the name of the subscription, and (optionally) the receive mode as parameters.</span></span> <span data-ttu-id="2b174-173">Örneğin, **stok** abonelik:</span><span class="sxs-lookup"><span data-stu-id="2b174-173">For example, with the **Inventory** subscription:</span></span>

```csharp
// Create the subscription client
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider); 

SubscriptionClient agentSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Inventory", ReceiveMode.PeekLock);
SubscriptionClient auditSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Dashboard", ReceiveMode.ReceiveAndDelete); 

while ((message = agentSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Inventory...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
    message.Complete();
}          

// Create a receiver using ReceiveAndDelete mode
while ((message = auditSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Dashboard...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

### <a name="rules-and-actions"></a><span data-ttu-id="2b174-174">Kurallar ve eylemler</span><span class="sxs-lookup"><span data-stu-id="2b174-174">Rules and actions</span></span>
<span data-ttu-id="2b174-175">Birçok senaryoda belirli özelliklere sahip iletileri farklı şekillerde işlenmelidir.</span><span class="sxs-lookup"><span data-stu-id="2b174-175">In many scenarios, messages that have specific characteristics must be processed in different ways.</span></span> <span data-ttu-id="2b174-176">Bunu etkinleştirmek için bu özellikler istenilen ve bu özellikler için bazı değişiklikleri gerçekleştirin iletileri bulmak için abonelikleri yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2b174-176">To enable this, you can configure subscriptions to find messages that have desired properties and then perform certain modifications to those properties.</span></span> <span data-ttu-id="2b174-177">Hizmet veri yolu abonelikleri konu başlığına gönderilen tüm iletiler görürsünüz, ancak bu iletiler bir kısmı yalnızca sanal abonelik kuyruğuna kopyalayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2b174-177">While Service Bus subscriptions see all messages sent to the topic, you can only copy a subset of those messages to the virtual subscription queue.</span></span> <span data-ttu-id="2b174-178">Bu, abonelik filtreleri kullanılarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="2b174-178">This is accomplished using subscription filters.</span></span> <span data-ttu-id="2b174-179">Tür değişiklikler adlı *filtre eylemlerini*.</span><span class="sxs-lookup"><span data-stu-id="2b174-179">Such modifications are called *filter actions*.</span></span> <span data-ttu-id="2b174-180">Bir abonelik oluşturduğunuzda, Sistem özellikleri her iki ileti özellikleri üzerinde çalıştığı bir filtre ifadesi sağlayabilirsiniz (örneğin, **etiket**) ve özel uygulama özelliklerini (örneğin,  **StoreName**.) SQL filtre ifadesi bu durumda isteğe bağlıdır; bir SQL filtre ifadesi, bu abonelik için tüm iletiler bir abonelikte tanımlanan herhangi bir filtre işlem gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="2b174-180">When a subscription is created, you can supply a filter expression that operates on the properties of the message, both the system properties (for example, **Label**) and custom application properties (for example, **StoreName**.) The SQL filter expression is optional in this case; without a SQL filter expression, any filter action defined on a subscription will be performed on all the messages for that subscription.</span></span>

<span data-ttu-id="2b174-181">Önceki örneği, yalnızca'ten gelen iletileri Filtrele kullanarak **Store1**, Pano abonelik gibi oluşturursunuz:</span><span class="sxs-lookup"><span data-stu-id="2b174-181">Using the previous example, to filter messages coming only from **Store1**, you would create the Dashboard subscription as follows:</span></span>

```csharp
namespaceManager.CreateSubscription("IssueTrackingTopic", "Dashboard", new SqlFilter("StoreName = 'Store1'"));
```

<span data-ttu-id="2b174-182">Bu abonelik filtresi yerinde olan iletiler birlikte `StoreName` özelliğini `Store1` için sanal sırasına kopyalanır `Dashboard` abonelik.</span><span class="sxs-lookup"><span data-stu-id="2b174-182">With this subscription filter in place, only messages that have the `StoreName` property set to `Store1` are copied to the virtual queue for the `Dashboard` subscription.</span></span>

<span data-ttu-id="2b174-183">Olası filtre değerleri hakkında daha fazla bilgi için belgelerine bakın [SqlFilter](/dotnet/api/microsoft.servicebus.messaging.sqlfilter) ve [SqlRuleAction](/dotnet/api/microsoft.servicebus.messaging.sqlruleaction) sınıfları.</span><span class="sxs-lookup"><span data-stu-id="2b174-183">For more information about possible filter values, see the documentation for the [SqlFilter](/dotnet/api/microsoft.servicebus.messaging.sqlfilter) and [SqlRuleAction](/dotnet/api/microsoft.servicebus.messaging.sqlruleaction) classes.</span></span> <span data-ttu-id="2b174-184">Ayrıca bkz [aracılı Mesajlaşma: Gelişmiş filtreler](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749) ve [konu filtreleri](https://github.com/Azure-Samples/azure-servicebus-messaging-samples/tree/master/TopicFilters) örnekleri.</span><span class="sxs-lookup"><span data-stu-id="2b174-184">Also, see the [Brokered Messaging: Advanced Filters](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749) and [Topic Filters](https://github.com/Azure-Samples/azure-servicebus-messaging-samples/tree/master/TopicFilters) samples.</span></span>

## <a name="next-steps"></a><span data-ttu-id="2b174-185">Sonraki adımlar</span><span class="sxs-lookup"><span data-stu-id="2b174-185">Next steps</span></span>
<span data-ttu-id="2b174-186">Aşağıdaki konularda daha fazla bilgi ve Service Bus Mesajlaşma kullanma örnekleri Gelişmiş bakın.</span><span class="sxs-lookup"><span data-stu-id="2b174-186">See the following advanced topics for more information and examples of using Service Bus messaging.</span></span>

* [<span data-ttu-id="2b174-187">Service Bus mesajlaşma hizmetine genel bakış</span><span class="sxs-lookup"><span data-stu-id="2b174-187">Service Bus messaging overview</span></span>](service-bus-messaging-overview.md)
* [<span data-ttu-id="2b174-188">Service Bus aracılı mesajlaşma .NET eğitmeni</span><span class="sxs-lookup"><span data-stu-id="2b174-188">Service Bus brokered messaging .NET tutorial</span></span>](service-bus-brokered-tutorial-dotnet.md)
* [<span data-ttu-id="2b174-189">Service Bus aracılı Mesajlaşma REST Öğreticisi</span><span class="sxs-lookup"><span data-stu-id="2b174-189">Service Bus brokered messaging REST tutorial</span></span>](service-bus-brokered-tutorial-rest.md)
* [<span data-ttu-id="2b174-190">Konu başlığı filtreleri örneği</span><span class="sxs-lookup"><span data-stu-id="2b174-190">Topic Filters sample </span></span>](https://github.com/Azure/azure-service-bus/tree/master/samples/DotNet/Microsoft.ServiceBus.Messaging/TopicFilters)
* [<span data-ttu-id="2b174-191">Aracılı Mesajlaşma: Gelişmiş filtreleri örneği</span><span class="sxs-lookup"><span data-stu-id="2b174-191">Brokered Messaging: Advanced Filters sample</span></span>](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749)

