---
title: "Service Fabric Reliable Actors genel bakış | Microsoft Docs"
description: "Service Fabric Reliable Actors programlama modelini giriş."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: e89be04a0d6fe90a89e293e67d42f0204eb7000a
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/11/2017
---
# <a name="introduction-to-service-fabric-reliable-actors"></a><span data-ttu-id="32d96-103">Service Fabric Reliable Actors hizmetine giriş</span><span class="sxs-lookup"><span data-stu-id="32d96-103">Introduction to Service Fabric Reliable Actors</span></span>
<span data-ttu-id="32d96-104">Güvenilir aktörler dayalı bir çerçevedir Service Fabric uygulaması [sanal aktör](http://research.microsoft.com/en-us/projects/orleans/) düzeni.</span><span class="sxs-lookup"><span data-stu-id="32d96-104">Reliable Actors is a Service Fabric application framework based on the [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="32d96-105">Güvenilir aktörler API Service Fabric tarafından sağlanan ölçeklenebilirlik ve güvenilirlik garantileri üzerine kurulu bir tek iş parçacıklı programlama modeli sağlar.</span><span class="sxs-lookup"><span data-stu-id="32d96-105">The Reliable Actors API provides a single-threaded programming model built on the scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="32d96-106">Aktör nelerdir?</span><span class="sxs-lookup"><span data-stu-id="32d96-106">What are Actors?</span></span>
<span data-ttu-id="32d96-107">Bir oyuncu hesaplama ve tek iş parçacıklı yürütme durumuyla yalıtılmış, bağımsız bir birimdir.</span><span class="sxs-lookup"><span data-stu-id="32d96-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="32d96-108">[Aktör düzeni](https://en.wikipedia.org/wiki/Actor_model) eşzamanlı veya dağıtılmış sistemleri, aynı anda çok sayıda bu aktörler yürütün ve birbirlerine bağımsız olarak bir hesaplama modelidir.</span><span class="sxs-lookup"><span data-stu-id="32d96-108">The [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="32d96-109">Aktör birbirleri ile iletişim kurabilir ve daha fazla aktörler oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="32d96-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-to-use-reliable-actors"></a><span data-ttu-id="32d96-110">Reliable Actors kullanma zamanı</span><span class="sxs-lookup"><span data-stu-id="32d96-110">When to use Reliable Actors</span></span>
<span data-ttu-id="32d96-111">Service Fabric Reliable Actors aktör tasarım deseni uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="32d96-111">Service Fabric Reliable Actors is an implementation of the actor design pattern.</span></span> <span data-ttu-id="32d96-112">Tüm yazılım tasarım deseni gibi belirli bir desene kullanıp kullanmayacağınızı olsun veya olmasın bir yazılım tasarım üzerinde sorun göre yapılır karar düzeni sığar.</span><span class="sxs-lookup"><span data-stu-id="32d96-112">As with any software design pattern, the decision whether to use a specific pattern is made based on whether or not a software design problem fits the pattern.</span></span>

<span data-ttu-id="32d96-113">Aktör tasarım rağmen düzeni iyi bir dağıtılmış sistemler sorun ve senaryo düzeni ve uyguladığı framework kısıtlamaları göz önünde bulundurulmalıdır dikkatli bir sayıya uygun olamaz.</span><span class="sxs-lookup"><span data-stu-id="32d96-113">Although the actor design pattern can be a good fit to a number of distributed systems problems and scenarios, careful consideration of the constraints of the pattern and the framework implementing it must be made.</span></span> <span data-ttu-id="32d96-114">Genel bir yönerge olarak sorunu veya senaryo, model için aktör desen göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="32d96-114">As general guidance, consider the actor pattern to model your problem or scenario if:</span></span>

* <span data-ttu-id="32d96-115">Çok sayıda sorunu alanınızı içerir (binlerce veya daha fazla) küçük, bağımsız ve yalıtılmış birim durumu ve mantığı sayısı.</span><span class="sxs-lookup"><span data-stu-id="32d96-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="32d96-116">Dış bileşenlerinden aktörler kümesi boyunca durumu sorgulama dahil olmak üzere önemli etkileşim gerektirmeyen tek iş parçacıklı nesneleri birlikte çalışmak istediğiniz.</span><span class="sxs-lookup"><span data-stu-id="32d96-116">You want to work with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="32d96-117">Aktör örneklerinizi g/ç işlemleri vererek beklenmeyen gecikme ile arayanlar engellemez.</span><span class="sxs-lookup"><span data-stu-id="32d96-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="32d96-118">Service Fabric aktör</span><span class="sxs-lookup"><span data-stu-id="32d96-118">Actors in Service Fabric</span></span>
<span data-ttu-id="32d96-119">Service Fabric içinde aktörler Reliable Actors Framework'te uygulanır: üstünde bir aktör desen tabanlı uygulama altyapısıdır [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="32d96-119">In Service Fabric, actors are implemented in the Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="32d96-120">Yazdığınız her güvenilir aktör hizmeti aslında bir bölümlenmiş, durum bilgisi olan güvenilir hizmetidir.</span><span class="sxs-lookup"><span data-stu-id="32d96-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="32d96-121">Her aktör .NET türünün bir örneği bir .NET nesnesidir şekilde özdeş bir aktör türünün bir örneği olarak tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="32d96-121">Every actor is defined as an instance of an actor type, identical to the way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="32d96-122">Örneğin, bir hesap makinesi işlevselliğini hayata geçiren bir aktör türü olabilir ve çeşitli düğümlerde küme genelinde dağıtılan birçok aktörler türü olabilir.</span><span class="sxs-lookup"><span data-stu-id="32d96-122">For example, there may be an actor type that implements the functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="32d96-123">Her tür aktör aktör kimliği ile benzersiz olarak tanımlanır</span><span class="sxs-lookup"><span data-stu-id="32d96-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="32d96-124">Aktör yaşam süresi</span><span class="sxs-lookup"><span data-stu-id="32d96-124">Actor Lifetime</span></span>
<span data-ttu-id="32d96-125">Service Fabric aktör sanal, kendi ömürleri kendi bellek içi gösterimine bağlanmayan anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="32d96-125">Service Fabric actors are virtual, meaning that their lifetime is not tied to their in-memory representation.</span></span> <span data-ttu-id="32d96-126">Sonuç olarak, bunlar açıkça otomatik olarak oluşturulan veya yok gerekmez.</span><span class="sxs-lookup"><span data-stu-id="32d96-126">As a result, they do not need to be explicitly created or destroyed.</span></span> <span data-ttu-id="32d96-127">Reliable Actors çalışma zamanı bu aktör kimliği için bir istek alırsa aktör ilk zaman otomatik olarak etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="32d96-127">The Reliable Actors runtime automatically activates an actor the first time it receives a request for that actor ID.</span></span> <span data-ttu-id="32d96-128">Bir oyuncu bir süre kullanılmazsa Reliable Actors çalışma zamanı çöp-bellekteki nesne toplar.</span><span class="sxs-lookup"><span data-stu-id="32d96-128">If an actor is not used for a period of time, the Reliable Actors runtime garbage-collects the in-memory object.</span></span> <span data-ttu-id="32d96-129">Daha sonra yeniden etkinleştirilmesi gerekir, aktör'ın varlığı bilgisini de korur.</span><span class="sxs-lookup"><span data-stu-id="32d96-129">It will also maintain knowledge of the actor's existence should it need to be reactivated later.</span></span> <span data-ttu-id="32d96-130">Daha fazla ayrıntı için bkz: [aktör yaşam döngüsü ve atık toplama](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="32d96-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="32d96-131">Bu sanal aktör ömrü soyutlama sanal aktör modeli sonucunda bazı uyarılar gerçekleştirir ve hatta Reliable Actors uygulamaya bazen bu modelden farklılık göstermesi.</span><span class="sxs-lookup"><span data-stu-id="32d96-131">This virtual actor lifetime abstraction carries some caveats as a result of the virtual actor model, and in fact the Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="32d96-132">Bir oyuncu (oluşturulması için bir aktör nesne neden olan) otomatik olarak etkinleştirilir aktör kimliğini gönderilen bir ileti ilk kez</span><span class="sxs-lookup"><span data-stu-id="32d96-132">An actor is automatically activated (causing an actor object to be constructed) the first time a message is sent to its actor ID.</span></span> <span data-ttu-id="32d96-133">Belirli bir süre sonra toplanacak aktör nesnesidir.</span><span class="sxs-lookup"><span data-stu-id="32d96-133">After some period of time, the actor object is garbage collected.</span></span> <span data-ttu-id="32d96-134">Gelecekte, aktör kimliği yeniden kullanarak oluşturulması için yeni bir aktör nesne neden olur.</span><span class="sxs-lookup"><span data-stu-id="32d96-134">In the future, using the actor ID again, causes a new actor object to be constructed.</span></span> <span data-ttu-id="32d96-135">Nesne ömrü bir aktör'in durumunu outlives durum Yöneticisi'nde depolanan olduğunda.</span><span class="sxs-lookup"><span data-stu-id="32d96-135">An actor's state outlives the object's lifetime when stored in the state manager.</span></span>
* <span data-ttu-id="32d96-136">Aktör kimliği için herhangi bir aktör yöntemini çağırmadan bu aktör etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="32d96-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="32d96-137">Bu nedenle, çalışma zamanı tarafından dolaylı olarak adlandırılan kendi Oluşturucusu aktör türlerine sahip.</span><span class="sxs-lookup"><span data-stu-id="32d96-137">For this reason, actor types have their constructor called implicitly by the runtime.</span></span> <span data-ttu-id="32d96-138">Bu nedenle, parametreleri aktör'ın oluşturucuya hizmeti tarafından geçirilen ancak istemci kodu aktör tür oluşturucuya parametreleri geçiremezsiniz.</span><span class="sxs-lookup"><span data-stu-id="32d96-138">Therefore, client code cannot pass parameters to the actor type's constructor, although parameters may be passed to the actor's constructor by the service itself.</span></span> <span data-ttu-id="32d96-139">Sonucu aktör başlatma parametreleri istemciden gerektiriyorsa aktörler kısmen başlatılmış bir durumda diğer yöntemleri, üzerine denir zamana göre oluşturulması, ' dir.</span><span class="sxs-lookup"><span data-stu-id="32d96-139">The result is that actors may be constructed in a partially-initialized state by the time other methods are called on it, if the actor requires initialization parameters from the client.</span></span> <span data-ttu-id="32d96-140">İstemci bir aktör etkinleştirme için tek giriş noktası yok.</span><span class="sxs-lookup"><span data-stu-id="32d96-140">There is no single entry point for the activation of an actor from the client.</span></span>
* <span data-ttu-id="32d96-141">Reliable Actors örtülü olarak aktör nesneleri oluştursanız da; açıkça bir aktör ve durumu silme becerisine sahip.</span><span class="sxs-lookup"><span data-stu-id="32d96-141">Although Reliable Actors implicitly create actor objects; you do have the ability to explicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="32d96-142">Dağıtım ve yük devretme</span><span class="sxs-lookup"><span data-stu-id="32d96-142">Distribution and failover</span></span>
<span data-ttu-id="32d96-143">Ölçeklenebilirlik ve güvenilirlik sağlamak için Service Fabric aktör küme genelinde dağıtır ve otomatik olarak onları başarısız düğümlerden gerektiği gibi sağlıklı olanlara geçirir.</span><span class="sxs-lookup"><span data-stu-id="32d96-143">To provide scalability and reliability, Service Fabric distributes actors throughout the cluster and automatically migrates them from failed nodes to healthy ones as required.</span></span> <span data-ttu-id="32d96-144">Bu bir üzerinden soyutlamadır bir [bölümlenmiş, durum bilgisi olan güvenilir hizmet](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="32d96-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="32d96-145">Dağıtım, ölçeklenebilirlik, güvenilirlik ve otomatik yük devretme tümüdür aktörler içinde çalıştıran olgu, durum bilgisi olan güvenilir bir hizmet olarak adlandırılan sağlanan *aktör hizmeti*.</span><span class="sxs-lookup"><span data-stu-id="32d96-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of the fact that actors are running inside a stateful Reliable Service called the *Actor Service*.</span></span>

<span data-ttu-id="32d96-146">Aktör aktör hizmeti bölümleri arasında dağıtılır ve bu bölümler bir Service Fabric kümesindeki düğümler arasında dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="32d96-146">Actors are distributed across the partitions of the Actor Service, and those partitions are distributed across the nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="32d96-147">Her bir hizmet bölümü aktörler kümesini içerir.</span><span class="sxs-lookup"><span data-stu-id="32d96-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="32d96-148">Service Fabric, dağıtım ve hizmet bölümlerini Yük Devretmesini yönetir.</span><span class="sxs-lookup"><span data-stu-id="32d96-148">Service Fabric manages distribution and failover of the service partitions.</span></span>

<span data-ttu-id="32d96-149">Örneğin, üç düğümü varsayılan aktör bölüm yerleştirme kullanılarak dağıtılan dokuz bölümleri olan bir aktör hizmeti thusly dağıtılmış:</span><span class="sxs-lookup"><span data-stu-id="32d96-149">For example, an actor service with nine partitions deployed to three nodes using the default actor partition placement would be distributed thusly:</span></span>

![Güvenilir aktörler dağıtım][2]

<span data-ttu-id="32d96-151">Aktör Framework sizin için bölüm düzeni ve anahtar aralığı ayarlarını yönetir.</span><span class="sxs-lookup"><span data-stu-id="32d96-151">The Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="32d96-152">Bu, bazı seçenekleri basitleştirir ancak ayrıca bazı önem taşır:</span><span class="sxs-lookup"><span data-stu-id="32d96-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="32d96-153">Güvenilir hizmetler, bölümleme düzeni, (bölümleme aralığı kullanırken) anahtar aralığı seçin ve sayısı bölüm olanak verir.</span><span class="sxs-lookup"><span data-stu-id="32d96-153">Reliable Services allows you to choose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="32d96-154">Güvenilir aktörler (Tekdüzen Int64 düzeni) bölümleme aralığı için sınırlı ve tam Int64 anahtar aralığı kullanın gerektirir.</span><span class="sxs-lookup"><span data-stu-id="32d96-154">Reliable Actors is restricted to the range partitioning scheme (the uniform Int64 scheme) and requires you use the full Int64 key range.</span></span>
* <span data-ttu-id="32d96-155">Varsayılan olarak, aktörler rastgele Tekdüzen dağıtımlarında kaynaklanan bölümlere yerleştirilir.</span><span class="sxs-lookup"><span data-stu-id="32d96-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="32d96-156">Aktör rastgele yerleştirildiğinden aktör işlemleri ağ iletişimi, seri hale getirme ve seri durumundan çıkarma gecikme süresi ve ek yükü yansıtılmasını yöntemi çağrısı verileri de dahil olmak üzere her zaman gerektirecektir beklenmelidir.</span><span class="sxs-lookup"><span data-stu-id="32d96-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="32d96-157">Gelişmiş senaryolar Int64 aktör belirli bölümlere eşlemek kimlikleri kullanarak denetim aktör bölüm yerleştirme için mümkündür.</span><span class="sxs-lookup"><span data-stu-id="32d96-157">In advanced scenarios, it is possible to control actor partition placement by using Int64 actor IDs that map to specific partitions.</span></span> <span data-ttu-id="32d96-158">Ancak, bunun bölümler böylece aktörler dengesiz bir dağıtım sonuçlanabilir.</span><span class="sxs-lookup"><span data-stu-id="32d96-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="32d96-159">Aktör hizmetleri nasıl bölümlenir üzerinde daha fazla bilgi için bkz [kavramları aktörleri bölümleme](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="32d96-159">For more information on how actor services are partitioned, refer to [partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="32d96-160">Aktör iletişimi</span><span class="sxs-lookup"><span data-stu-id="32d96-160">Actor communication</span></span>
<span data-ttu-id="32d96-161">Aktör etkileşimleri arabirimini uygulayan aktör ve aynı arabirimi aracılığıyla bir aktör için bir proxy alır istemci tarafından paylaşılan bir arabirim tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="32d96-161">Actor interactions are defined in an interface that is shared by the actor that implements the interface, and the client that gets a proxy to an actor via the same interface.</span></span> <span data-ttu-id="32d96-162">Bu arabirimi gerçekleştiren yöntemleri zaman uyumsuz olarak çağırmak için kullanıldığından, arabirimdeki her yöntem görev döndürme olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="32d96-162">Because this interface is used to invoke actor methods asynchronously, every method on the interface must be Task-returning.</span></span>

<span data-ttu-id="32d96-163">Yöntem çağrılarını ve yanıtlarını sonuçta ağ isteklerine kümede, bu nedenle bağımsız değişkenler neden ve döndürmeleri görevleri sonuç türleri platform tarafından Serileştirilebilir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="32d96-163">Method invocations and their responses ultimately result in network requests across the cluster, so the arguments and the result types of the tasks that they return must be serializable by the platform.</span></span> <span data-ttu-id="32d96-164">Özellikle, olmalıdır [veri sözleşmesi seri hale getirilebilir](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="32d96-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="the-actor-proxy"></a><span data-ttu-id="32d96-165">Aktör proxy</span><span class="sxs-lookup"><span data-stu-id="32d96-165">The actor proxy</span></span>
<span data-ttu-id="32d96-166">Reliable Actors İstemcisi API aktör örneği aktör istemci arasında iletişimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="32d96-166">The Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="32d96-167">Bir oyuncu ile iletişim kurmak için bir istemci aktör arabirimini uygulayan bir aktör proxy nesnesi oluşturur.</span><span class="sxs-lookup"><span data-stu-id="32d96-167">To communicate with an actor, a client creates an actor proxy object that implements the actor interface.</span></span> <span data-ttu-id="32d96-168">İstemci, proxy nesnesinin yöntemlerde çağırarak aktör ile etkileşime girer.</span><span class="sxs-lookup"><span data-stu-id="32d96-168">The client interacts with the actor by invoking methods on the proxy object.</span></span> <span data-ttu-id="32d96-169">Aktör proxy istemci aktör ve aktör aktör iletişimi için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="32d96-169">The actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on the actor. If an actor with the given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="32d96-170">Aktör proxy nesnesi oluşturmak için kullanılan bilgileri iki parça aktör kimliği ve uygulama adı olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="32d96-170">Note that the two pieces of information used to create the actor proxy object are the actor ID and the application name.</span></span> <span data-ttu-id="32d96-171">Uygulama adı tanımlayan sırada gerçekleşen kimliği aktör benzersiz olarak tanımlayan [Service Fabric uygulaması](service-fabric-reliable-actors-platform.md#application-model) aktör dağıtıldığı.</span><span class="sxs-lookup"><span data-stu-id="32d96-171">The actor ID uniquely identifies the actor, while the application name identifies the [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where the actor is deployed.</span></span>

<span data-ttu-id="32d96-172">`ActorProxy`(C#) / `ActorProxyBase`istemci tarafında (Java) sınıfı Kimliğine göre aktör bulun ve bir iletişim kanalı ile açmak için gerekli çözümlemesi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="32d96-172">The `ActorProxy`(C#) / `ActorProxyBase`(Java) class on the client side performs the necessary resolution to locate the actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="32d96-173">İletişim hataları ve yük devretme durumunda aktör bulmak için de deneme.</span><span class="sxs-lookup"><span data-stu-id="32d96-173">It also retries to locate the actor in the cases of communication failures and failovers.</span></span> <span data-ttu-id="32d96-174">Sonuç olarak, ileti teslimi, aşağıdaki özelliklere sahiptir:</span><span class="sxs-lookup"><span data-stu-id="32d96-174">As a result, message delivery has the following characteristics:</span></span>

* <span data-ttu-id="32d96-175">İleti teslimi en iyi çaba olur.</span><span class="sxs-lookup"><span data-stu-id="32d96-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="32d96-176">Aktör aynı istemciden yinelenen iletileri alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="32d96-176">Actors may receive duplicate messages from the same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="32d96-177">Eşzamanlılık</span><span class="sxs-lookup"><span data-stu-id="32d96-177">Concurrency</span></span>
<span data-ttu-id="32d96-178">Reliable Actors çalışma zamanı aktör yöntemleri erişmek için bir basit Aç tabanlı erişim modeli sağlar.</span><span class="sxs-lookup"><span data-stu-id="32d96-178">The Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="32d96-179">Başka bir deyişle, birden fazla iş parçacığı dilediğiniz zaman içinde aktör nesnenin kod etkin olabilir.</span><span class="sxs-lookup"><span data-stu-id="32d96-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="32d96-180">Veri erişimi için eşitleme mekanizmaları için gerekli olduğu Aç tabanlı erişim eşzamanlı sistemleri büyük ölçüde basitleştirir.</span><span class="sxs-lookup"><span data-stu-id="32d96-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="32d96-181">Ayrıca, sistemleri için özel hususlar her aktör örneğinin ile tek iş parçacıklı erişim yapısı tasarlanmalıdır anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="32d96-181">It also means systems must be designed with special considerations for the single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="32d96-182">Bir tek aktör örneği aynı anda birden fazla isteği işleyemiyor.</span><span class="sxs-lookup"><span data-stu-id="32d96-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="32d96-183">Eş zamanlı istekleri işlemek üzere bekleniyorsa aktör örneği bir işleme performans sorunu neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="32d96-183">An actor instance can cause a throughput bottleneck if it is expected to handle concurrent requests.</span></span>
* <span data-ttu-id="32d96-184">Bir dış istek aktörler birine aynı anda yapılır sırada iki aktörler arasında döngüsel bir istek varsa aktörler birbirine kilitlenme.</span><span class="sxs-lookup"><span data-stu-id="32d96-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made to one of the actors simultaneously.</span></span> <span data-ttu-id="32d96-185">Aktör çalışma zamanı otomatik olarak aktör çağrılarını zaman aşımına ve olası kilitlenme durumlarda kesmek için çağıran bir özel durum.</span><span class="sxs-lookup"><span data-stu-id="32d96-185">The actor runtime will automatically time out on actor calls and throw an exception to the caller to interrupt possible deadlock situations.</span></span>

![Güvenilir aktörler iletişim][3]

#### <a name="turn-based-access"></a><span data-ttu-id="32d96-187">Bırakma tabanlı erişim</span><span class="sxs-lookup"><span data-stu-id="32d96-187">Turn-based access</span></span>
<span data-ttu-id="32d96-188">Aktör yöntemi isteğine yanıt olarak bir diğer aktörler veya istemciler tam olarak yürütülmesini veya tam olarak yürütülmesini bir dönüş oluşur bir [Zamanlayıcı/anımsatıcı](service-fabric-reliable-actors-timers-reminders.md) geri çağırma.</span><span class="sxs-lookup"><span data-stu-id="32d96-188">A turn consists of the complete execution of an actor method in response to a request from other actors or clients, or the complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="32d96-189">Bu yöntem ve geri aramalar zaman uyumsuz olmasına karşın, aktörler çalışma zamanı bunları Interleave değil.</span><span class="sxs-lookup"><span data-stu-id="32d96-189">Even though these methods and callbacks are asynchronous, the Actors runtime does not interleave them.</span></span> <span data-ttu-id="32d96-190">Yeni bir dönüş izin verilmeden önce bir dönüş tam olarak tamamlanmış olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="32d96-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="32d96-191">Diğer bir deyişle, şu anda yürütülen bir aktör yöntemi veya Zamanlayıcı/anımsatıcı geri bir yöntem için yeni bir çağrı önce tam olarak tamamlanmış olmalıdır veya geri çağırma izin verilir.</span><span class="sxs-lookup"><span data-stu-id="32d96-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call to a method or callback is allowed.</span></span> <span data-ttu-id="32d96-192">Bir yöntem veya geri çağırma yürütme yönteminden döndürülen veya geri çağırma ve yöntem veya geri çağırma tarafından döndürülen görev tamamlandı tamamlandı olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="32d96-192">A method or callback is considered to have finished if the execution has returned from the method or callback and the task returned by the method or callback has finished.</span></span> <span data-ttu-id="32d96-193">Bu o Aç tabanlı eşzamanlılık bile farklı yöntemler, zamanlayıcılar ve geri aramalar arasında dikkate değer vurgulayan olur.</span><span class="sxs-lookup"><span data-stu-id="32d96-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="32d96-194">Aktör çalışma zamanı bir dönüş başlangıcını ve Aç sonunda kilidin açılması aktör başına kilit alınırken tarafından Aç tabanlı eşzamanlılık zorlar.</span><span class="sxs-lookup"><span data-stu-id="32d96-194">The Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at the beginning of a turn and releasing the lock at the end of the turn.</span></span> <span data-ttu-id="32d96-195">Bu nedenle, dönüş tabanlı eşzamanlılık aktör başına temelinde arasında değil aktörler zorlanır.</span><span class="sxs-lookup"><span data-stu-id="32d96-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="32d96-196">Aynı anda aktör yöntemleri ve Zamanlayıcı/anımsatıcı geri aramalar adına farklı aktörler yürütebilir.</span><span class="sxs-lookup"><span data-stu-id="32d96-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="32d96-197">Aşağıdaki örnek, yukarıdaki kavramları göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="32d96-197">The following example illustrates the above concepts.</span></span> <span data-ttu-id="32d96-198">İki zaman uyumsuz yöntemleri uygulayan bir aktör türü göz önünde bulundurun (örneğin, *Method1* ve *Method2*), bir Zamanlayıcı ve bir anımsatıcı.</span><span class="sxs-lookup"><span data-stu-id="32d96-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="32d96-199">Aşağıdaki diyagramda iki aktörler adına bu yöntemlere ve geri aramalar yürütülmesi için bir zaman çizelgesi örneği gösterilmektedir (*ActorId1* ve *ActorId2*) bu aktör türüne ait.</span><span class="sxs-lookup"><span data-stu-id="32d96-199">The diagram below shows an example of a timeline for the execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong to this actor type.</span></span>

![Güvenilir aktörler çalışma zamanı Aç tabanlı eşzamanlılık ve erişim][1]

<span data-ttu-id="32d96-201">Bu diyagramda, bu kuralları aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="32d96-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="32d96-202">Her dikey çizgi belirli aktör adına bir yöntem ya da bir geri çağırma yürütme mantıksal akışı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="32d96-202">Each vertical line shows the logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="32d96-203">Dikey her satırda işaretlenmiş olaylar kronolojik sırada eskiler yeni olayların ile oluşur.</span><span class="sxs-lookup"><span data-stu-id="32d96-203">The events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="32d96-204">Farklı renk farklı aktörler için karşılık gelen zaman çizelgeleri için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="32d96-204">Different colors are used for timelines corresponding to different actors.</span></span>
* <span data-ttu-id="32d96-205">Vurgulama aktör başına kilit bir yöntem veya geri çağırma adına tutulduğu süreyi belirtmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="32d96-205">Highlighting is used to indicate the duration for which the per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="32d96-206">Dikkate alınması gereken bazı önemli noktalar:</span><span class="sxs-lookup"><span data-stu-id="32d96-206">Some important points to consider:</span></span>

* <span data-ttu-id="32d96-207">Sırada *Method1* adına yürütüyor *ActorId2* istemci isteğine yanıt olarak *xyz789*, başka bir istemci isteği (*abc123*) ulaşan de gerektirir *Method1* tarafından yürütülecek *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="32d96-207">While *Method1* is executing on behalf of *ActorId2* in response to client request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* to be executed by *ActorId2*.</span></span> <span data-ttu-id="32d96-208">Ancak, ikinci yürütülmesi *Method1* önceki yürütme tamamlanana kadar başlamaz.</span><span class="sxs-lookup"><span data-stu-id="32d96-208">However, the second execution of *Method1* does not begin until the prior execution has finished.</span></span> <span data-ttu-id="32d96-209">Benzer şekilde, bir anımsatıcı kayıtlı tarafından *ActorId2* sırasında ateşlenir *Method1* istemci isteğine yanıt olarak yürütülmekte olan *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="32d96-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response to client request *xyz789*.</span></span> <span data-ttu-id="32d96-210">Yalnızca her iki yürütmeleri sonra anımsatıcı geri çağırma yürütülen *Method1* tamamlandığından.</span><span class="sxs-lookup"><span data-stu-id="32d96-210">The reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="32d96-211">Tüm bu olduğu için zorlanan Aç tabanlı eşzamanlılık nedeniyle *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="32d96-211">All of this is due to turn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="32d96-212">Benzer şekilde, bırakma tabanlı eşzamanlılık ayrıca için zorunlu *ActorId1*, yürütme işlemi tarafından gösterildiği gibi *Method1*, *Method2*ve adınaZamanlayıcıgeri *ActorId1* seri biçimde olmuyor.</span><span class="sxs-lookup"><span data-stu-id="32d96-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by the execution of *Method1*, *Method2*, and the timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="32d96-213">Yürütülmesi *Method1* adına *ActorId1* adına yürütülmesinin ile çakışıyor *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="32d96-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="32d96-214">Bırakma tabanlı eşzamanlılık yalnızca bir aktör içinde arasında değil aktörler zorlanır olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="32d96-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="32d96-215">Bazı yöntemi/geri çağırma yürütmeleri `Task`(C#) / `CompletableFuture`(Java) tarafından yöntemi/geri araması bitirdiğinde metodu döndükten sonra döndürdü.</span><span class="sxs-lookup"><span data-stu-id="32d96-215">In some of the method/callback executions, the `Task`(C#) / `CompletableFuture`(Java) returned by the method/callback finishes after the method returns.</span></span> <span data-ttu-id="32d96-216">Bazı bazılarında zaman uyumsuz işlem zaten yöntemi/geri çağırma döndürür zamanına göre bitirdi.</span><span class="sxs-lookup"><span data-stu-id="32d96-216">In some others, the asynchronous operation has already finished by the time the method/callback returns.</span></span> <span data-ttu-id="32d96-217">Her iki durumda da, yalnızca hem yöntemi/geri döndürür ve zaman uyumsuz işlemi tamamlandıktan sonra aktör başına kilit yayımlanır.</span><span class="sxs-lookup"><span data-stu-id="32d96-217">In both cases, the per-actor lock is released only after both the method/callback returns and the asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="32d96-218">Yeniden giriş</span><span class="sxs-lookup"><span data-stu-id="32d96-218">Reentrancy</span></span>
<span data-ttu-id="32d96-219">Aktör çalışma zamanı yeniden giriş varsayılan olarak izin verir.</span><span class="sxs-lookup"><span data-stu-id="32d96-219">The Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="32d96-220">Bu olması durumunda bir aktör yöntemi anlamına gelir *aktör A* bir yöntemi çağırır *aktör B*, sırayla çağıran başka bir yöntem üzerinde *aktör A*, yöntem çalışmasına izin verilip.</span><span class="sxs-lookup"><span data-stu-id="32d96-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed to run.</span></span> <span data-ttu-id="32d96-221">Aynı mantıksal çağrı zincirine bağlam parçası olduğundan bu değildir.</span><span class="sxs-lookup"><span data-stu-id="32d96-221">This is because it is part of the same logical call-chain context.</span></span> <span data-ttu-id="32d96-222">Tüm Zamanlayıcı ve anımsatıcı çağrıları yeni mantıksal çağrısı bağlamla başlatın.</span><span class="sxs-lookup"><span data-stu-id="32d96-222">All timer and reminder calls start with the new logical call context.</span></span> <span data-ttu-id="32d96-223">Bkz: [Reliable Actors yeniden giriş](service-fabric-reliable-actors-reentrancy.md) daha fazla ayrıntı için.</span><span class="sxs-lookup"><span data-stu-id="32d96-223">See the [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="32d96-224">Eşzamanlılık garanti kapsamı</span><span class="sxs-lookup"><span data-stu-id="32d96-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="32d96-225">Aktör çalışma zamanı bu yöntemleri çağırma olduğu denetlediği durumlarda bu eşzamanlılık garantileri sağlar.</span><span class="sxs-lookup"><span data-stu-id="32d96-225">The Actors runtime provides these concurrency guarantees in situations where it controls the invocation of these methods.</span></span> <span data-ttu-id="32d96-226">Örneğin, Zamanlayıcı ve anımsatıcı geri aramalar yanı sıra, bir istemci isteğine yanıt olarak gerçekleştirilen yöntem çağrılarına için bu garantileri sağlar.</span><span class="sxs-lookup"><span data-stu-id="32d96-226">For example, it provides these guarantees for the method invocations that are done in response to a client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="32d96-227">Ancak, aktör kodu doğrudan aktörler çalışma zamanı tarafından sağlanan mekanizmaları dışında bu yöntemleri çağırırsa, çalışma zamanı eşzamanlılık garanti sağlayamaz.</span><span class="sxs-lookup"><span data-stu-id="32d96-227">However, if the actor code directly invokes these methods outside of the mechanisms provided by the Actors runtime, then the runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="32d96-228">Örneğin, aktör yöntemler tarafından döndürülen görev ile ilişkili değil bazı görev bağlamında yöntemi çağrıldıysa, çalışma zamanı eşzamanlılık garanti sağlayamaz.</span><span class="sxs-lookup"><span data-stu-id="32d96-228">For example, if the method is invoked in the context of some task that is not associated with the task returned by the actor methods, then the runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="32d96-229">Aktör, kendi oluşturduğu akıştan yöntemi çağrıldıysa, çalışma zamanı da eşzamanlılık garanti sağlayamaz.</span><span class="sxs-lookup"><span data-stu-id="32d96-229">If the method is invoked from a thread that the actor creates on its own, then the runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="32d96-230">Bu nedenle, arka plan işlemleri gerçekleştirmek için aktörler kullanması gereken [aktör zamanlayıcılar ve aktör anımsatıcıları](service-fabric-reliable-actors-timers-reminders.md) Aç tabanlı eşzamanlılık saygılı olun.</span><span class="sxs-lookup"><span data-stu-id="32d96-230">Therefore, to perform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="32d96-231">Sonraki adımlar</span><span class="sxs-lookup"><span data-stu-id="32d96-231">Next steps</span></span>
* <span data-ttu-id="32d96-232">İlk Reliable Actors hizmetiniz oluşturarak başlayın:</span><span class="sxs-lookup"><span data-stu-id="32d96-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="32d96-233">.NET üzerinde Reliable Actors ile çalışmaya başlama</span><span class="sxs-lookup"><span data-stu-id="32d96-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="32d96-234">Üzerinde Java Reliable Actors ile çalışmaya başlama</span><span class="sxs-lookup"><span data-stu-id="32d96-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
