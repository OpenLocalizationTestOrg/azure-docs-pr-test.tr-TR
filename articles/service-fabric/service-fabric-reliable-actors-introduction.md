---
title: "aaaService doku güvenilir aktörler genel bakış | Microsoft Docs"
description: "Giriş toohello Service Fabric Reliable Actors programlama modeli."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: ab010cbf936c6cf723b3d453ef95a9bf51f76c95
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/06/2017
---
# <a name="introduction-tooservice-fabric-reliable-actors"></a><span data-ttu-id="7910f-103">Giriş tooService doku Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="7910f-103">Introduction tooService Fabric Reliable Actors</span></span>
<span data-ttu-id="7910f-104">Güvenilir aktörler üzerinde hello dayalı bir çerçevedir Service Fabric uygulaması [sanal aktör](http://research.microsoft.com/en-us/projects/orleans/) düzeni.</span><span class="sxs-lookup"><span data-stu-id="7910f-104">Reliable Actors is a Service Fabric application framework based on hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="7910f-105">Merhaba güvenilir aktörler API Service Fabric tarafından sağlanan hello ölçeklenebilirlik ve güvenilirlik garantileri üzerine kurulu bir tek iş parçacıklı programlama modeli sağlar.</span><span class="sxs-lookup"><span data-stu-id="7910f-105">hello Reliable Actors API provides a single-threaded programming model built on hello scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="7910f-106">Aktör nelerdir?</span><span class="sxs-lookup"><span data-stu-id="7910f-106">What are Actors?</span></span>
<span data-ttu-id="7910f-107">Bir oyuncu hesaplama ve tek iş parçacıklı yürütme durumuyla yalıtılmış, bağımsız bir birimdir.</span><span class="sxs-lookup"><span data-stu-id="7910f-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="7910f-108">Merhaba [aktör düzeni](https://en.wikipedia.org/wiki/Actor_model) eşzamanlı veya dağıtılmış sistemleri, aynı anda çok sayıda bu aktörler yürütün ve birbirlerine bağımsız olarak bir hesaplama modelidir.</span><span class="sxs-lookup"><span data-stu-id="7910f-108">hello [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="7910f-109">Aktör birbirleri ile iletişim kurabilir ve daha fazla aktörler oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7910f-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-toouse-reliable-actors"></a><span data-ttu-id="7910f-110">Zaman toouse Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="7910f-110">When toouse Reliable Actors</span></span>
<span data-ttu-id="7910f-111">Service Fabric Reliable Actors hello aktör tasarım deseni uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="7910f-111">Service Fabric Reliable Actors is an implementation of hello actor design pattern.</span></span> <span data-ttu-id="7910f-112">Tüm yazılım tasarım deseni gibi hello düzeni toouse belirli bir desene olup yapılan olsun veya olmasın bir yazılım tasarım üzerinde sorun dayalı hello karar sığar.</span><span class="sxs-lookup"><span data-stu-id="7910f-112">As with any software design pattern, hello decision whether toouse a specific pattern is made based on whether or not a software design problem fits hello pattern.</span></span>

<span data-ttu-id="7910f-113">Merhaba aktör tasarım deseni dağıtılmış sistemlerin sorunları ve senaryoları, dikkat hello düzeni ve hello framework hale getirilmesi gereken uygulama hello kısıtlamaları iyi uygun tooa sayısı olabilse de.</span><span class="sxs-lookup"><span data-stu-id="7910f-113">Although hello actor design pattern can be a good fit tooa number of distributed systems problems and scenarios, careful consideration of hello constraints of hello pattern and hello framework implementing it must be made.</span></span> <span data-ttu-id="7910f-114">Genel bir yönerge olarak hello aktör düzeni toomodel sorun veya senaryoyu göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="7910f-114">As general guidance, consider hello actor pattern toomodel your problem or scenario if:</span></span>

* <span data-ttu-id="7910f-115">Çok sayıda sorunu alanınızı içerir (binlerce veya daha fazla) küçük, bağımsız ve yalıtılmış birim durumu ve mantığı sayısı.</span><span class="sxs-lookup"><span data-stu-id="7910f-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="7910f-116">Dış bileşenlerinden aktörler kümesi boyunca durumu sorgulama dahil olmak üzere önemli etkileşim gerektirmeyen tek iş parçacıklı nesnelerle toowork istiyor.</span><span class="sxs-lookup"><span data-stu-id="7910f-116">You want toowork with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="7910f-117">Aktör örneklerinizi g/ç işlemleri vererek beklenmeyen gecikme ile arayanlar engellemez.</span><span class="sxs-lookup"><span data-stu-id="7910f-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="7910f-118">Service Fabric aktör</span><span class="sxs-lookup"><span data-stu-id="7910f-118">Actors in Service Fabric</span></span>
<span data-ttu-id="7910f-119">Service Fabric içinde aktörler hello Reliable Actors framework uygulanır: üstünde bir aktör desen tabanlı uygulama altyapısıdır [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="7910f-119">In Service Fabric, actors are implemented in hello Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="7910f-120">Yazdığınız her güvenilir aktör hizmeti aslında bir bölümlenmiş, durum bilgisi olan güvenilir hizmetidir.</span><span class="sxs-lookup"><span data-stu-id="7910f-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="7910f-121">Her aktör aktör türünün bir örneği tanımlanır, aynı toohello .NET nesnesi .NET türünün bir örneği yoludur.</span><span class="sxs-lookup"><span data-stu-id="7910f-121">Every actor is defined as an instance of an actor type, identical toohello way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="7910f-122">Örneğin, bir hesap makinesi hello işlevselliğini uygulayan bir aktör türü olabilir ve çeşitli düğümlerde küme genelinde dağıtılan birçok aktörler türü olabilir.</span><span class="sxs-lookup"><span data-stu-id="7910f-122">For example, there may be an actor type that implements hello functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="7910f-123">Her tür aktör aktör kimliği ile benzersiz olarak tanımlanır</span><span class="sxs-lookup"><span data-stu-id="7910f-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="7910f-124">Aktör yaşam süresi</span><span class="sxs-lookup"><span data-stu-id="7910f-124">Actor Lifetime</span></span>
<span data-ttu-id="7910f-125">Service Fabric aktör sanal, kendi ömürleri bağlı tootheir bellek içi temsili olmadığından emin anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="7910f-125">Service Fabric actors are virtual, meaning that their lifetime is not tied tootheir in-memory representation.</span></span> <span data-ttu-id="7910f-126">Sonuç olarak, açıkça oluşturulan veya tahrip toobe gerekmez.</span><span class="sxs-lookup"><span data-stu-id="7910f-126">As a result, they do not need toobe explicitly created or destroyed.</span></span> <span data-ttu-id="7910f-127">Merhaba Reliable Actors çalışma zamanı aktör hello bu aktör kimliği için bir istek alırsa ilk kez otomatik olarak etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="7910f-127">hello Reliable Actors runtime automatically activates an actor hello first time it receives a request for that actor ID.</span></span> <span data-ttu-id="7910f-128">Bir oyuncu bir süre kullanılmazsa hello Reliable Actors çalışma zamanı çöp-hello bellekteki nesne toplar.</span><span class="sxs-lookup"><span data-stu-id="7910f-128">If an actor is not used for a period of time, hello Reliable Actors runtime garbage-collects hello in-memory object.</span></span> <span data-ttu-id="7910f-129">Daha sonra yeniden toobe ihtiyacınız olursa, hello aktör'ın varlığı bilgisi de korur.</span><span class="sxs-lookup"><span data-stu-id="7910f-129">It will also maintain knowledge of hello actor's existence should it need toobe reactivated later.</span></span> <span data-ttu-id="7910f-130">Daha fazla ayrıntı için bkz: [aktör yaşam döngüsü ve atık toplama](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="7910f-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="7910f-131">Bu sanal aktör ömrü soyutlama hello sanal aktör modeli sonucunda bazı uyarılar gerçekleştirir ve hatta hello Reliable Actors uygulama bazen bu modelden farklılık göstermesi.</span><span class="sxs-lookup"><span data-stu-id="7910f-131">This virtual actor lifetime abstraction carries some caveats as a result of hello virtual actor model, and in fact hello Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="7910f-132">Bir oyuncu (bir aktör oluşturulan nesne toobe neden) otomatik olarak etkinleştirilir hello tooits aktör kimliği gönderilen bir ileti ilk kez</span><span class="sxs-lookup"><span data-stu-id="7910f-132">An actor is automatically activated (causing an actor object toobe constructed) hello first time a message is sent tooits actor ID.</span></span> <span data-ttu-id="7910f-133">Belirli bir süre sonra toplanacak hello aktör nesnesidir.</span><span class="sxs-lookup"><span data-stu-id="7910f-133">After some period of time, hello actor object is garbage collected.</span></span> <span data-ttu-id="7910f-134">Hello hello aktör kimliği kullanarak yeniden, gelecekteki yeni aktör oluşturulan nesne toobe neden olur.</span><span class="sxs-lookup"><span data-stu-id="7910f-134">In hello future, using hello actor ID again, causes a new actor object toobe constructed.</span></span> <span data-ttu-id="7910f-135">Bir aktör'in durumunu hello nesnesinin ömrü outlives hello durum Yöneticisi'nde depolanan olduğunda.</span><span class="sxs-lookup"><span data-stu-id="7910f-135">An actor's state outlives hello object's lifetime when stored in hello state manager.</span></span>
* <span data-ttu-id="7910f-136">Aktör kimliği için herhangi bir aktör yöntemini çağırmadan bu aktör etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="7910f-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="7910f-137">Bu nedenle, aktör türlerini örtük olarak hello çalışma zamanı tarafından adlı kendi oluşturucuya sahip.</span><span class="sxs-lookup"><span data-stu-id="7910f-137">For this reason, actor types have their constructor called implicitly by hello runtime.</span></span> <span data-ttu-id="7910f-138">Bu nedenle, istemci kodu parametreleri toohello aktör'ın Oluşturucusu hello hizmeti tarafından kendisine geçirilen ancak parametreleri toohello aktör türünün Oluşturucusu geçiremezsiniz.</span><span class="sxs-lookup"><span data-stu-id="7910f-138">Therefore, client code cannot pass parameters toohello actor type's constructor, although parameters may be passed toohello actor's constructor by hello service itself.</span></span> <span data-ttu-id="7910f-139">Merhaba hello aktör başlatma parametreleri hello istemciden gerektiriyorsa aktörler kısmen başlatılmış bir durumda diğer yöntemleri, üzerine denir hello zamana göre oluşturulması, sonucudur.</span><span class="sxs-lookup"><span data-stu-id="7910f-139">hello result is that actors may be constructed in a partially-initialized state by hello time other methods are called on it, if hello actor requires initialization parameters from hello client.</span></span> <span data-ttu-id="7910f-140">Bir oyuncu hello istemciden hello etkinleştirilmesi için tek giriş noktası yok.</span><span class="sxs-lookup"><span data-stu-id="7910f-140">There is no single entry point for hello activation of an actor from hello client.</span></span>
* <span data-ttu-id="7910f-141">Reliable Actors örtülü olarak aktör nesneleri oluştursanız da; hello özelliği tooexplicitly bir aktör silip durumuna sahip.</span><span class="sxs-lookup"><span data-stu-id="7910f-141">Although Reliable Actors implicitly create actor objects; you do have hello ability tooexplicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="7910f-142">Dağıtım ve yük devretme</span><span class="sxs-lookup"><span data-stu-id="7910f-142">Distribution and failover</span></span>
<span data-ttu-id="7910f-143">tooprovide ölçeklenebilirlik ve güvenilirlik, Service Fabric aktör hello küme boyunca ve otomatik olarak dağıtır bunları gerektiği gibi başarısız düğümlerin toohealthy olanları gelen geçirir.</span><span class="sxs-lookup"><span data-stu-id="7910f-143">tooprovide scalability and reliability, Service Fabric distributes actors throughout hello cluster and automatically migrates them from failed nodes toohealthy ones as required.</span></span> <span data-ttu-id="7910f-144">Bu bir üzerinden soyutlamadır bir [bölümlenmiş, durum bilgisi olan güvenilir hizmet](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="7910f-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="7910f-145">Dağıtım, ölçeklenebilirlik, güvenilirlik ve otomatik yük devretme tüm sağlanan aktörler bir durum bilgisi olan güvenilir hello adlı hizmeti içinde çalışan hello olgu, *aktör hizmeti*.</span><span class="sxs-lookup"><span data-stu-id="7910f-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of hello fact that actors are running inside a stateful Reliable Service called hello *Actor Service*.</span></span>

<span data-ttu-id="7910f-146">Aktör hello aktör hizmeti hello bölümleri arasında dağıtılır ve bu bölümler bir Service Fabric kümesindeki hello düğümler arasında dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="7910f-146">Actors are distributed across hello partitions of hello Actor Service, and those partitions are distributed across hello nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="7910f-147">Her bir hizmet bölümü aktörler kümesini içerir.</span><span class="sxs-lookup"><span data-stu-id="7910f-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="7910f-148">Service Fabric, dağıtım ve yük devretme hello hizmet bölümlerinin yönetir.</span><span class="sxs-lookup"><span data-stu-id="7910f-148">Service Fabric manages distribution and failover of hello service partitions.</span></span>

<span data-ttu-id="7910f-149">Örneğin, bir aktör hizmeti dokuz bölümleri olan hello varsayılan aktör bölüm yerleştirme kullanarak düğümler thusly dağıtılmış toothree dağıtılan:</span><span class="sxs-lookup"><span data-stu-id="7910f-149">For example, an actor service with nine partitions deployed toothree nodes using hello default actor partition placement would be distributed thusly:</span></span>

![Güvenilir aktörler dağıtım][2]

<span data-ttu-id="7910f-151">Merhaba aktör Framework sizin için bölüm düzeni ve anahtar aralığı ayarlarını yönetir.</span><span class="sxs-lookup"><span data-stu-id="7910f-151">hello Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="7910f-152">Bu, bazı seçenekleri basitleştirir ancak ayrıca bazı önem taşır:</span><span class="sxs-lookup"><span data-stu-id="7910f-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="7910f-153">Bölüm sayısı ve güvenilir hizmetler toochoose bölümleme düzeni (bölümleme aralığı kullanırken) anahtar aralığı sağlar.</span><span class="sxs-lookup"><span data-stu-id="7910f-153">Reliable Services allows you toochoose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="7910f-154">Güvenilir aktörler kısıtlı toohello aralığı bölümleme düzeni (Merhaba Tekdüzen Int64 düzeni) ve hello tam Int64 anahtar aralığını kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="7910f-154">Reliable Actors is restricted toohello range partitioning scheme (hello uniform Int64 scheme) and requires you use hello full Int64 key range.</span></span>
* <span data-ttu-id="7910f-155">Varsayılan olarak, aktörler rastgele Tekdüzen dağıtımlarında kaynaklanan bölümlere yerleştirilir.</span><span class="sxs-lookup"><span data-stu-id="7910f-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="7910f-156">Aktör rastgele yerleştirildiğinden aktör işlemleri ağ iletişimi, seri hale getirme ve seri durumundan çıkarma gecikme süresi ve ek yükü yansıtılmasını yöntemi çağrısı verileri de dahil olmak üzere her zaman gerektirecektir beklenmelidir.</span><span class="sxs-lookup"><span data-stu-id="7910f-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="7910f-157">Gelişmiş senaryolar, olası toocontrol aktör bölüm yerleştirme Int64 aktör toospecific bölümleri eşleme kimlikleri kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="7910f-157">In advanced scenarios, it is possible toocontrol actor partition placement by using Int64 actor IDs that map toospecific partitions.</span></span> <span data-ttu-id="7910f-158">Ancak, bunun bölümler böylece aktörler dengesiz bir dağıtım sonuçlanabilir.</span><span class="sxs-lookup"><span data-stu-id="7910f-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="7910f-159">Aktör hizmetleri nasıl bölümlenir daha fazla bilgi için çok başvuran[kavramları aktörleri bölümleme](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="7910f-159">For more information on how actor services are partitioned, refer too[partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="7910f-160">Aktör iletişimi</span><span class="sxs-lookup"><span data-stu-id="7910f-160">Actor communication</span></span>
<span data-ttu-id="7910f-161">Aktör etkileşimleri hello arabirimini uygulayan hello aktör ve bir proxy tooan aktör hello aracılığıyla alır hello istemci tarafından paylaşılan bir arabirim tanımlanmış aynı arabirimi.</span><span class="sxs-lookup"><span data-stu-id="7910f-161">Actor interactions are defined in an interface that is shared by hello actor that implements hello interface, and hello client that gets a proxy tooan actor via hello same interface.</span></span> <span data-ttu-id="7910f-162">Bu arabirim kullanılan tooinvoke aktör yöntemleri zaman uyumsuz olarak olduğundan, hello arabirimdeki her yöntem görev döndürme olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="7910f-162">Because this interface is used tooinvoke actor methods asynchronously, every method on hello interface must be Task-returning.</span></span>

<span data-ttu-id="7910f-163">Sonuçta yöntem çağrılarını ve yanıtlarını hello küme, bunu hello bağımsız değişkenleri ve dönüş hello platformu tarafından seri hale getirilebilir olmaları gerekir, hello görevlerin hello sonuç türleri arasında ağ isteklerine neden.</span><span class="sxs-lookup"><span data-stu-id="7910f-163">Method invocations and their responses ultimately result in network requests across hello cluster, so hello arguments and hello result types of hello tasks that they return must be serializable by hello platform.</span></span> <span data-ttu-id="7910f-164">Özellikle, olmalıdır [veri sözleşmesi seri hale getirilebilir](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="7910f-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="hello-actor-proxy"></a><span data-ttu-id="7910f-165">Merhaba aktör proxy</span><span class="sxs-lookup"><span data-stu-id="7910f-165">hello actor proxy</span></span>
<span data-ttu-id="7910f-166">Merhaba Reliable Actors istemci API aktör örneği aktör istemci arasında iletişimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="7910f-166">hello Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="7910f-167">toocommunicate bir aktör ile bir istemci hello aktör arabirimini uygulayan bir aktör proxy nesnesi oluşturur.</span><span class="sxs-lookup"><span data-stu-id="7910f-167">toocommunicate with an actor, a client creates an actor proxy object that implements hello actor interface.</span></span> <span data-ttu-id="7910f-168">Merhaba istemci hello proxy nesnesi üzerinde bildirilecekse yöntemlerle hello aktör ile etkileşime girer.</span><span class="sxs-lookup"><span data-stu-id="7910f-168">hello client interacts with hello actor by invoking methods on hello proxy object.</span></span> <span data-ttu-id="7910f-169">Merhaba aktör proxy istemci aktör ve aktör aktör iletişimi için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="7910f-169">hello actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="7910f-170">Merhaba iki parça bilgi toocreate hello aktör proxy nesnesi kullanılan Not: hello aktör kimliği ve hello uygulama adı.</span><span class="sxs-lookup"><span data-stu-id="7910f-170">Note that hello two pieces of information used toocreate hello actor proxy object are hello actor ID and hello application name.</span></span> <span data-ttu-id="7910f-171">Merhaba aktör kimliği hello uygulama adı hello tanımlayan sırada hello aktör benzersiz olarak tanımlayan [Service Fabric uygulaması](service-fabric-reliable-actors-platform.md#application-model) hello aktör dağıtıldığı.</span><span class="sxs-lookup"><span data-stu-id="7910f-171">hello actor ID uniquely identifies hello actor, while hello application name identifies hello [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where hello actor is deployed.</span></span>

<span data-ttu-id="7910f-172">Merhaba `ActorProxy`(C#) / `ActorProxyBase`(Java) sınıfı hello istemci tarafında hello gerekli çözümleme toolocate hello aktör Kimliğine göre gerçekleştirir ve bir iletişim kanalı ile açın.</span><span class="sxs-lookup"><span data-stu-id="7910f-172">hello `ActorProxy`(C#) / `ActorProxyBase`(Java) class on hello client side performs hello necessary resolution toolocate hello actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="7910f-173">İletişim hataları ve yük devretme işlemlerini hello durumlarda toolocate hello aktör yeniden dener.</span><span class="sxs-lookup"><span data-stu-id="7910f-173">It also retries toolocate hello actor in hello cases of communication failures and failovers.</span></span> <span data-ttu-id="7910f-174">Sonuç olarak, ileti teslimi hello aşağıdaki özelliklere sahiptir:</span><span class="sxs-lookup"><span data-stu-id="7910f-174">As a result, message delivery has hello following characteristics:</span></span>

* <span data-ttu-id="7910f-175">İleti teslimi en iyi çaba olur.</span><span class="sxs-lookup"><span data-stu-id="7910f-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="7910f-176">Aktör hello yinelenen iletileri alabilirsiniz aynı istemci.</span><span class="sxs-lookup"><span data-stu-id="7910f-176">Actors may receive duplicate messages from hello same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="7910f-177">Eşzamanlılık</span><span class="sxs-lookup"><span data-stu-id="7910f-177">Concurrency</span></span>
<span data-ttu-id="7910f-178">Merhaba Reliable Actors çalışma zamanı aktör yöntemleri erişmek için bir basit Aç tabanlı erişim modeli sağlar.</span><span class="sxs-lookup"><span data-stu-id="7910f-178">hello Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="7910f-179">Başka bir deyişle, birden fazla iş parçacığı dilediğiniz zaman içinde aktör nesnenin kod etkin olabilir.</span><span class="sxs-lookup"><span data-stu-id="7910f-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="7910f-180">Veri erişimi için eşitleme mekanizmaları için gerekli olduğu Aç tabanlı erişim eşzamanlı sistemleri büyük ölçüde basitleştirir.</span><span class="sxs-lookup"><span data-stu-id="7910f-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="7910f-181">Ayrıca, sistemleri için özel hususlar her aktör örneğinin ile Merhaba tek iş parçacıklı erişim yapısı tasarlanmalıdır anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="7910f-181">It also means systems must be designed with special considerations for hello single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="7910f-182">Bir tek aktör örneği aynı anda birden fazla isteği işleyemiyor.</span><span class="sxs-lookup"><span data-stu-id="7910f-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="7910f-183">Beklenen toohandle eşzamanlı istek ise aktör örneği bir işleme performans sorunu neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="7910f-183">An actor instance can cause a throughput bottleneck if it is expected toohandle concurrent requests.</span></span>
* <span data-ttu-id="7910f-184">Bir dış istek hello aktör tooone aynı anda yapılan sırada iki aktörler arasında döngüsel bir istek varsa aktörler birbirine kilitlenme.</span><span class="sxs-lookup"><span data-stu-id="7910f-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made tooone of hello actors simultaneously.</span></span> <span data-ttu-id="7910f-185">Merhaba aktör çalışma zamanı otomatik olarak zaman aşımına aktör çağırır ve olası kilitlenme durumlarda bir özel durum toohello arayan toointerrupt atar.</span><span class="sxs-lookup"><span data-stu-id="7910f-185">hello actor runtime will automatically time out on actor calls and throw an exception toohello caller toointerrupt possible deadlock situations.</span></span>

![Güvenilir aktörler iletişim][3]

#### <a name="turn-based-access"></a><span data-ttu-id="7910f-187">Bırakma tabanlı erişim</span><span class="sxs-lookup"><span data-stu-id="7910f-187">Turn-based access</span></span>
<span data-ttu-id="7910f-188">Bir dönüş hello tam olarak yürütülmesini diğer aktörler veya istemciler yanıt tooa isteği aktör yönteminde veya hello tam olarak yürütülmesini oluşur bir [Zamanlayıcı/anımsatıcı](service-fabric-reliable-actors-timers-reminders.md) geri çağırma.</span><span class="sxs-lookup"><span data-stu-id="7910f-188">A turn consists of hello complete execution of an actor method in response tooa request from other actors or clients, or hello complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="7910f-189">Bu yöntem ve geri aramalar zaman uyumsuz olmasına karşın, hello aktörler çalışma zamanı bunları Interleave değil.</span><span class="sxs-lookup"><span data-stu-id="7910f-189">Even though these methods and callbacks are asynchronous, hello Actors runtime does not interleave them.</span></span> <span data-ttu-id="7910f-190">Yeni bir dönüş izin verilmeden önce bir dönüş tam olarak tamamlanmış olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="7910f-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="7910f-191">Diğer bir deyişle, şu anda yürütülen bir aktör yöntemi veya Zamanlayıcı/anımsatıcı geri önce yeni bir çağrı tooa yöntemi tam olarak tamamlanmış olmalıdır veya geri çağırma izin verilir.</span><span class="sxs-lookup"><span data-stu-id="7910f-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call tooa method or callback is allowed.</span></span> <span data-ttu-id="7910f-192">Bir yöntem veya geri çağırma toohave tamamlanmış hello yürütme hello yönteminden döndürülen veya hello yöntemi veya geri çağırma tarafından döndürülen geri çağırma ve hello görevi tamamlandı olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="7910f-192">A method or callback is considered toohave finished if hello execution has returned from hello method or callback and hello task returned by hello method or callback has finished.</span></span> <span data-ttu-id="7910f-193">Bu o Aç tabanlı eşzamanlılık bile farklı yöntemler, zamanlayıcılar ve geri aramalar arasında dikkate değer vurgulayan olur.</span><span class="sxs-lookup"><span data-stu-id="7910f-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="7910f-194">Aktör başına kilit bir dönüş hello başında alınırken tarafından Hello aktörler çalışma zamanı Aç tabanlı eşzamanlılık zorunlu kılan ve hello hello sonunda hello kilidi serbest bırakma.</span><span class="sxs-lookup"><span data-stu-id="7910f-194">hello Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at hello beginning of a turn and releasing hello lock at hello end of hello turn.</span></span> <span data-ttu-id="7910f-195">Bu nedenle, dönüş tabanlı eşzamanlılık aktör başına temelinde arasında değil aktörler zorlanır.</span><span class="sxs-lookup"><span data-stu-id="7910f-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="7910f-196">Aynı anda aktör yöntemleri ve Zamanlayıcı/anımsatıcı geri aramalar adına farklı aktörler yürütebilir.</span><span class="sxs-lookup"><span data-stu-id="7910f-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="7910f-197">Aşağıdaki örneğine hello kavramları yukarıda hello gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="7910f-197">hello following example illustrates hello above concepts.</span></span> <span data-ttu-id="7910f-198">İki zaman uyumsuz yöntemleri uygulayan bir aktör türü göz önünde bulundurun (örneğin, *Method1* ve *Method2*), bir Zamanlayıcı ve bir anımsatıcı.</span><span class="sxs-lookup"><span data-stu-id="7910f-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="7910f-199">Merhaba diyagrama iki aktörler adına bu yöntemleri ve geri aramalar hello yürütme için bir zaman çizelgesi örneği gösterir (*ActorId1* ve *ActorId2*) toothis aktör türü ait.</span><span class="sxs-lookup"><span data-stu-id="7910f-199">hello diagram below shows an example of a timeline for hello execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong toothis actor type.</span></span>

![Güvenilir aktörler çalışma zamanı Aç tabanlı eşzamanlılık ve erişim][1]

<span data-ttu-id="7910f-201">Bu diyagramda, bu kuralları aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="7910f-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="7910f-202">Her dikey çizgi hello mantıksal akışını bir yöntem ya da bir geri çağırma belirli aktör adına gösterir.</span><span class="sxs-lookup"><span data-stu-id="7910f-202">Each vertical line shows hello logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="7910f-203">Merhaba olaylar dikey her satırda işaretlenmiş kronolojik sırada eskiler yeni olayların ile oluşur.</span><span class="sxs-lookup"><span data-stu-id="7910f-203">hello events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="7910f-204">Farklı renk zaman çizelgelerini karşılık gelen toodifferent aktörler için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="7910f-204">Different colors are used for timelines corresponding toodifferent actors.</span></span>
* <span data-ttu-id="7910f-205">Vurgulama hangi hello için yöntemi veya geri çağırma adına aktör başına kilit tutulur kullanılan tooindicate hello süresi geçen süredir.</span><span class="sxs-lookup"><span data-stu-id="7910f-205">Highlighting is used tooindicate hello duration for which hello per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="7910f-206">Bazı önemli noktalar tooconsider:</span><span class="sxs-lookup"><span data-stu-id="7910f-206">Some important points tooconsider:</span></span>

* <span data-ttu-id="7910f-207">Sırada *Method1* adına yürütüyor *ActorId2* yanıt tooclient isteğinde *xyz789*, başka bir istemci isteği (*abc123*) ulaşan de gerektirir *Method1* tarafından yürütülen toobe *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="7910f-207">While *Method1* is executing on behalf of *ActorId2* in response tooclient request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* toobe executed by *ActorId2*.</span></span> <span data-ttu-id="7910f-208">Ancak, ikinci yürütülmesi hello *Method1* hello önceki yürütme tamamlanana kadar başlamaz.</span><span class="sxs-lookup"><span data-stu-id="7910f-208">However, hello second execution of *Method1* does not begin until hello prior execution has finished.</span></span> <span data-ttu-id="7910f-209">Benzer şekilde, bir anımsatıcı kayıtlı tarafından *ActorId2* sırasında ateşlenir *Method1* yanıt tooclient istekte yürütülen *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="7910f-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response tooclient request *xyz789*.</span></span> <span data-ttu-id="7910f-210">Merhaba anımsatıcı geri çağırma yalnızca her iki yürütmeleri sonra yürütülür *Method1* tamamlandığından.</span><span class="sxs-lookup"><span data-stu-id="7910f-210">hello reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="7910f-211">Tüm bu olduğu için zorlanan tooturn tabanlı eşzamanlılık son *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="7910f-211">All of this is due tooturn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="7910f-212">Benzer şekilde, bırakma tabanlı eşzamanlılık ayrıca için zorunlu *ActorId1*tarafından hello yürütülmesi gösterildiği gibi *Method1*, *Method2*, ve Zamanlayıcı geri adına hello *ActorId1* seri biçimde olmuyor.</span><span class="sxs-lookup"><span data-stu-id="7910f-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by hello execution of *Method1*, *Method2*, and hello timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="7910f-213">Yürütülmesi *Method1* adına *ActorId1* adına yürütülmesinin ile çakışıyor *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="7910f-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="7910f-214">Bırakma tabanlı eşzamanlılık yalnızca bir aktör içinde arasında değil aktörler zorlanır olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="7910f-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="7910f-215">Bazı hello yöntemi/geri çağırma yürütmeleri hello `Task`(C#) / `CompletableFuture`(Java) hello metodu döndükten sonra hello yöntemi/geri araması bitirdiğinde tarafından döndürülen.</span><span class="sxs-lookup"><span data-stu-id="7910f-215">In some of hello method/callback executions, hello `Task`(C#) / `CompletableFuture`(Java) returned by hello method/callback finishes after hello method returns.</span></span> <span data-ttu-id="7910f-216">Bazı bazılarında hello zaman uyumsuz işlem zaten hello yöntemi/geri döndürür hello zamanına göre bitirdi.</span><span class="sxs-lookup"><span data-stu-id="7910f-216">In some others, hello asynchronous operation has already finished by hello time hello method/callback returns.</span></span> <span data-ttu-id="7910f-217">Her iki durumda da, yalnızca iki hello yöntemi/geri döndürür ve hello zaman uyumsuz işlemi tamamlandıktan sonra hello aktör başına kilit yayımlanır.</span><span class="sxs-lookup"><span data-stu-id="7910f-217">In both cases, hello per-actor lock is released only after both hello method/callback returns and hello asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="7910f-218">Yeniden giriş</span><span class="sxs-lookup"><span data-stu-id="7910f-218">Reentrancy</span></span>
<span data-ttu-id="7910f-219">Merhaba aktörler çalışma zamanı yeniden giriş varsayılan olarak izin verir.</span><span class="sxs-lookup"><span data-stu-id="7910f-219">hello Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="7910f-220">Bu olması durumunda bir aktör yöntemi anlamına gelir *aktör A* bir yöntemi çağırır *aktör B*, sırayla çağıran başka bir yöntem üzerinde *aktör A*, yöntem toorun izin verilir.</span><span class="sxs-lookup"><span data-stu-id="7910f-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed toorun.</span></span> <span data-ttu-id="7910f-221">Merhaba parçası olduğundan bu olduğu aynı mantıksal çağrı zincirine bağlamı.</span><span class="sxs-lookup"><span data-stu-id="7910f-221">This is because it is part of hello same logical call-chain context.</span></span> <span data-ttu-id="7910f-222">Tüm Zamanlayıcı ve anımsatıcı çağrıları hello yeni mantıksal çağrı içeriği ile başlatın.</span><span class="sxs-lookup"><span data-stu-id="7910f-222">All timer and reminder calls start with hello new logical call context.</span></span> <span data-ttu-id="7910f-223">Merhaba bkz [Reliable Actors yeniden giriş](service-fabric-reliable-actors-reentrancy.md) daha fazla ayrıntı için.</span><span class="sxs-lookup"><span data-stu-id="7910f-223">See hello [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="7910f-224">Eşzamanlılık garanti kapsamı</span><span class="sxs-lookup"><span data-stu-id="7910f-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="7910f-225">Merhaba aktörler çalışma zamanı bu eşzamanlılık garantiler burada bu yöntemlerin hello çağırma denetimleri durumlarda sağlar.</span><span class="sxs-lookup"><span data-stu-id="7910f-225">hello Actors runtime provides these concurrency guarantees in situations where it controls hello invocation of these methods.</span></span> <span data-ttu-id="7910f-226">Örneğin, Zamanlayıcı ve anımsatıcı geri aramalar yanı sıra, yanıt tooa istemci isteğinde bitti hello yöntem çağrılarına için bu garantileri sağlar.</span><span class="sxs-lookup"><span data-stu-id="7910f-226">For example, it provides these guarantees for hello method invocations that are done in response tooa client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="7910f-227">Ancak, Hello aktör kodu doğrudan hello mekanizmaları hello aktörler çalışma zamanı tarafından sağlanan dışında bu yöntemleri çağırırsa, hello çalışma zamanı eşzamanlılık garanti sağlayamaz.</span><span class="sxs-lookup"><span data-stu-id="7910f-227">However, if hello actor code directly invokes these methods outside of hello mechanisms provided by hello Actors runtime, then hello runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="7910f-228">Örneğin, hello aktör yöntemleri tarafından döndürülen hello görev ile ilişkili değil bazı görev hello bağlamında Hello yöntemi çağrıldıysa hello çalışma zamanı eşzamanlılık garanti sağlayamaz.</span><span class="sxs-lookup"><span data-stu-id="7910f-228">For example, if hello method is invoked in hello context of some task that is not associated with hello task returned by hello actor methods, then hello runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="7910f-229">Bir iş parçacığından Hello yöntemi çağrıldıysa bu hello aktör, kendi oluşturur, ardından hello çalışma zamanı da eşzamanlılık garanti sağlayamaz.</span><span class="sxs-lookup"><span data-stu-id="7910f-229">If hello method is invoked from a thread that hello actor creates on its own, then hello runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="7910f-230">Aktörler tooperform arka plan işlemleri, bu nedenle, kullanmalısınız [aktör zamanlayıcılar ve aktör anımsatıcıları](service-fabric-reliable-actors-timers-reminders.md) Aç tabanlı eşzamanlılık saygılı olun.</span><span class="sxs-lookup"><span data-stu-id="7910f-230">Therefore, tooperform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="7910f-231">Sonraki adımlar</span><span class="sxs-lookup"><span data-stu-id="7910f-231">Next steps</span></span>
* <span data-ttu-id="7910f-232">İlk Reliable Actors hizmetiniz oluşturarak başlayın:</span><span class="sxs-lookup"><span data-stu-id="7910f-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="7910f-233">.NET üzerinde Reliable Actors ile çalışmaya başlama</span><span class="sxs-lookup"><span data-stu-id="7910f-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="7910f-234">Üzerinde Java Reliable Actors ile çalışmaya başlama</span><span class="sxs-lookup"><span data-stu-id="7910f-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
