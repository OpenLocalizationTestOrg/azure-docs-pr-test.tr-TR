---
title: "Entity Framework ile esnek veritabanı istemci kitaplığı kullanılarak | Microsoft Docs"
description: "Esnek veritabanı istemci kitaplığı ve Entity Framework veritabanları kodlama için kullanın"
services: sql-database
documentationcenter: 
manager: jhubbard
author: torsteng
editor: 
ms.assetid: b9c3065b-cb92-41be-aa7f-deba23e7e159
ms.service: sql-database
ms.custom: scale out apps
ms.workload: sql-database
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 03/06/2017
ms.author: torsteng
ms.openlocfilehash: 2f0bff394c1e11a270cb324be5a1a45e9e531d7f
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/11/2017
---
# <a name="elastic-database-client-library-with-entity-framework"></a><span data-ttu-id="e530b-103">Entity Framework ile esnek veritabanı istemci kitaplığı</span><span class="sxs-lookup"><span data-stu-id="e530b-103">Elastic Database client library with Entity Framework</span></span>
<span data-ttu-id="e530b-104">Bu belge, Entity Framework uygulamada bütünleştirmek için gereken değişiklikleri gösterir. [esnek veritabanı araçlarını](sql-database-elastic-scale-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="e530b-104">This document shows the changes in an Entity Framework application that are needed to integrate with the [Elastic Database tools](sql-database-elastic-scale-introduction.md).</span></span> <span data-ttu-id="e530b-105">Oluşturma üzerinde odak noktasıdır [parça eşleme Yönetim](sql-database-elastic-scale-shard-map-management.md) ve [veri bağımlı yönlendirme](sql-database-elastic-scale-data-dependent-routing.md) Entity Framework **Code First** yaklaşım.</span><span class="sxs-lookup"><span data-stu-id="e530b-105">The focus is on composing [shard map management](sql-database-elastic-scale-shard-map-management.md) and [data-dependent routing](sql-database-elastic-scale-data-dependent-routing.md) with the Entity Framework **Code First** approach.</span></span> <span data-ttu-id="e530b-106">[İlk - yeni veritabanı kod](http://msdn.microsoft.com/data/jj193542.aspx) öğretici EF için bu belge boyunca çalışan bizim örnek olarak hizmet verir.</span><span class="sxs-lookup"><span data-stu-id="e530b-106">The [Code First - New Database](http://msdn.microsoft.com/data/jj193542.aspx) tutorial for EF serves as our running example throughout this document.</span></span> <span data-ttu-id="e530b-107">Bu belge ile birlikte gelen örnek kod, esnek veritabanı araçlarını Visual Studio kod örnekleri örnekleri kümesi parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="e530b-107">The sample code accompanying this document is part of elastic database tools' set of samples in the Visual Studio Code Samples.</span></span>

## <a name="downloading-and-running-the-sample-code"></a><span data-ttu-id="e530b-108">Yükleme ve örnek kodu çalıştırma</span><span class="sxs-lookup"><span data-stu-id="e530b-108">Downloading and Running the Sample Code</span></span>
<span data-ttu-id="e530b-109">Bu makale için kod karşıdan yüklemek için:</span><span class="sxs-lookup"><span data-stu-id="e530b-109">To download the code for this article:</span></span>

* <span data-ttu-id="e530b-110">Visual Studio 2012 veya üzeri gereklidir.</span><span class="sxs-lookup"><span data-stu-id="e530b-110">Visual Studio 2012 or later is required.</span></span> 
* <span data-ttu-id="e530b-111">Karşıdan [Azure SQL - Entity Framework tümleştirme örneği için esnek DB Araçları](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba) MSDN'den.</span><span class="sxs-lookup"><span data-stu-id="e530b-111">Download the [Elastic DB Tools for Azure SQL - Entity Framework Integration sample](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba) from MSDN.</span></span> <span data-ttu-id="e530b-112">Örnek seçtiğiniz bir konuma ayıklayın.</span><span class="sxs-lookup"><span data-stu-id="e530b-112">Unzip the sample to a location of your choosing.</span></span>
* <span data-ttu-id="e530b-113">Visual Studio’yu çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="e530b-113">Start Visual Studio.</span></span> 
* <span data-ttu-id="e530b-114">Visual Studio'da Aç proje/çözüm dosyasını seçin ->.</span><span class="sxs-lookup"><span data-stu-id="e530b-114">In Visual Studio, select File -> Open Project/Solution.</span></span> 
* <span data-ttu-id="e530b-115">İçinde **Proje Aç** iletişim kutusunda, indirdiğiniz örnek gidin ve seçin **EntityFrameworkCodeFirst.sln** örneği açın.</span><span class="sxs-lookup"><span data-stu-id="e530b-115">In the **Open Project** dialog, navigate to the sample you downloaded and select **EntityFrameworkCodeFirst.sln** to open the sample.</span></span> 

<span data-ttu-id="e530b-116">Örneği çalıştırmak için Azure SQL veritabanı'nda üç boş veritabanları oluşturmanız gerekir:</span><span class="sxs-lookup"><span data-stu-id="e530b-116">To run the sample, you need to create three empty databases in Azure SQL Database:</span></span>

* <span data-ttu-id="e530b-117">Parça eşleme Manager veritabanı</span><span class="sxs-lookup"><span data-stu-id="e530b-117">Shard Map Manager database</span></span>
* <span data-ttu-id="e530b-118">Parça 1 veritabanı</span><span class="sxs-lookup"><span data-stu-id="e530b-118">Shard 1 database</span></span>
* <span data-ttu-id="e530b-119">Parça 2 veritabanı</span><span class="sxs-lookup"><span data-stu-id="e530b-119">Shard 2 database</span></span>

<span data-ttu-id="e530b-120">Bu veritabanları oluşturduktan sonra yer tutucu doldurun **Program.cs** Azure SQL veritabanı sunucunuzun adını, veritabanı adları ve veritabanlarına bağlanmak için kimlik bilgileriniz ile.</span><span class="sxs-lookup"><span data-stu-id="e530b-120">Once you have created these databases, fill in the place holders in **Program.cs** with your Azure SQL DB server name, the database names and your credentials to connect to the databases.</span></span> <span data-ttu-id="e530b-121">Visual Studio çözümü oluşturun.</span><span class="sxs-lookup"><span data-stu-id="e530b-121">Build the solution in Visual Studio.</span></span> <span data-ttu-id="e530b-122">Visual Studio gerekli NuGet paketlerini esnek veritabanı istemci kitaplığı için Entity Framework ve geçici oluşturma işleminin bir parçası olarak işleme hata indirir.</span><span class="sxs-lookup"><span data-stu-id="e530b-122">Visual Studio will download the required NuGet packages for the elastic database client library, Entity Framework, and Transient Fault handling as part of the build process.</span></span> <span data-ttu-id="e530b-123">NuGet paketleri geri çözümünüz için etkinleştirildiğinden emin olun.</span><span class="sxs-lookup"><span data-stu-id="e530b-123">Make sure that restoring NuGet packages is enabled for your solution.</span></span> <span data-ttu-id="e530b-124">Visual Studio Çözüm Gezgini'nde çözüme sağ tıklayarak bu ayarı etkinleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e530b-124">You can enable this setting by right-clicking on the solution file in the Visual Studio Solution Explorer.</span></span> 

## <a name="entity-framework-workflows"></a><span data-ttu-id="e530b-125">Entity Framework iş akışları</span><span class="sxs-lookup"><span data-stu-id="e530b-125">Entity Framework workflows</span></span>
<span data-ttu-id="e530b-126">Entity Framework geliştiriciler aşağıdaki dört iş uygulamaları geliştirmek ve uygulama nesneleri kalıcılığını sağlamak için birini kullanır:</span><span class="sxs-lookup"><span data-stu-id="e530b-126">Entity Framework developers rely on one of the following four workflows to build applications and to ensure persistence for application objects:</span></span> 

* <span data-ttu-id="e530b-127">**(Yeni veritabanı) ilk kod**: EF Geliştirici uygulama kodunda modeli oluşturur ve ardından EF veritabanı ondan oluşturur.</span><span class="sxs-lookup"><span data-stu-id="e530b-127">**Code First (New Database)**: The EF developer creates the model in the application code and then EF generates the database from it.</span></span> 
* <span data-ttu-id="e530b-128">**İlk (var olan veritabanı) kod**: Geliştirici model uygulama kodunu oluşturmak varolan bir veritabanından EF olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="e530b-128">**Code First (Existing Database)**: The developer lets EF generate the application code for the model from an existing database.</span></span>
* <span data-ttu-id="e530b-129">**Model ilk**: Geliştirici model EF Designer'da ve ardından EF modelden veritabanı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="e530b-129">**Model First**: The developer creates the model in the EF designer and then EF creates the database from the model.</span></span>
* <span data-ttu-id="e530b-130">**Veritabanı ilk**: varolan bir veritabanını modelden gerçekleştirip tooling EF Geliştirici kullanır.</span><span class="sxs-lookup"><span data-stu-id="e530b-130">**Database First**: The developer uses EF tooling to infer the model from an existing database.</span></span> 

<span data-ttu-id="e530b-131">Bu yaklaşım veritabanı bağlantılarını ve veritabanı şeması bir uygulama için şeffaf bir şekilde yönetmek için DbContext sınıfını kullanır.</span><span class="sxs-lookup"><span data-stu-id="e530b-131">All these approaches rely on the DbContext class to transparently manage database connections and database schema for an application.</span></span> <span data-ttu-id="e530b-132">Belgenin sonraki bölümlerinde daha ayrıntılı bağlantı oluşturma üzerinde denetim farklı düzeylerde DbContext temel sınıfından farklı oluşturucular izin aşağıdakiler ele alınacaktır olarak önyükleme ve şema oluşturma veritabanı.</span><span class="sxs-lookup"><span data-stu-id="e530b-132">As we will discuss in more detail later in the document, different constructors on the DbContext base class allow for different levels of control over connection creation, database bootstrapping and schema creation.</span></span> <span data-ttu-id="e530b-133">Öncelikle veri bağımlı yönlendirme arabirimlerini bağlantı yönetimi özellikleriyle EF tarafından sağlanan veritabanı bağlantı yönetimi kestiği olgu zorluklar esnek veritabanı istemci kitaplığı tarafından kaynaklanır.</span><span class="sxs-lookup"><span data-stu-id="e530b-133">Challenges arise primarily from the fact that the database connection management provided by EF intersects with the connection management capabilities of the data dependent routing interfaces provided by the elastic database client library.</span></span> 

## <a name="elastic-database-tools-assumptions"></a><span data-ttu-id="e530b-134">Varsayımlar esnek veritabanı araçları</span><span class="sxs-lookup"><span data-stu-id="e530b-134">Elastic database tools assumptions</span></span>
<span data-ttu-id="e530b-135">Terim tanımları için bkz: [esnek veritabanı araçlarını sözlüğü](sql-database-elastic-scale-glossary.md).</span><span class="sxs-lookup"><span data-stu-id="e530b-135">For term definitions, see [Elastic Database tools glossary](sql-database-elastic-scale-glossary.md).</span></span>

<span data-ttu-id="e530b-136">Esnek veritabanı istemci kitaplığı ile uygulama verilerinizi shardlets adlı Bölüm tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="e530b-136">With elastic database client library, you define partitions of your application data called shardlets.</span></span> <span data-ttu-id="e530b-137">Shardlets bir parçalama anahtar tarafından tanımlanır ve belirli veritabanlarına eşleştirilir.</span><span class="sxs-lookup"><span data-stu-id="e530b-137">Shardlets are identified by a sharding key and are mapped to specific databases.</span></span> <span data-ttu-id="e530b-138">Bir uygulama gerekli tüm veritabanı ve yeterli kapasitesi veya geçerli iş gereksinimlerini verilen performans sağlamak için shardlets dağıtmak olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e530b-138">An application may have as many databases as needed and distribute the shardlets to provide enough capacity or performance given current business requirements.</span></span> <span data-ttu-id="e530b-139">Parçalama anahtar değerlerin veritabanlarına esnek veritabanı istemci API tarafından sağlanan bir parça eşleme tarafından depolanır.</span><span class="sxs-lookup"><span data-stu-id="e530b-139">The mapping of sharding key values to the databases is stored by a shard map provided by the elastic database client APIs.</span></span> <span data-ttu-id="e530b-140">Bu özellik diyoruz **parça eşleme Yönetim**, veya kısaca SMM.</span><span class="sxs-lookup"><span data-stu-id="e530b-140">We call this capability **Shard Map Management**, or SMM for short.</span></span> <span data-ttu-id="e530b-141">Parça eşleme, ayrıca bir parçalama anahtar taşımak istekleri için veritabanı bağlantılarını aracısı olarak görev yapar.</span><span class="sxs-lookup"><span data-stu-id="e530b-141">The shard map also serves as the broker of database connections for requests that carry a sharding key.</span></span> <span data-ttu-id="e530b-142">Biz bu özelliği başvurmak **veri bağımlı yönlendirme**.</span><span class="sxs-lookup"><span data-stu-id="e530b-142">We refer to this capability as **data-dependent routing**.</span></span> 

<span data-ttu-id="e530b-143">Parça eşleme Yöneticisi kullanıcıları tutarsız görünümleri eşzamanlı shardlet management işlemleri (örneğin, verileri bir parça diğerine yerini değiştirme) gerçekleştiği yüklendiğinde oluşabilecek shardlet verilerini korur.</span><span class="sxs-lookup"><span data-stu-id="e530b-143">The shard map manager protects users from inconsistent views into shardlet data that can occur when concurrent shardlet management operations (such as relocating data from one shard to another) are happening.</span></span> <span data-ttu-id="e530b-144">Bunu yapmak için parça eşlemeleri veritabanı bağlantılarını bir uygulama için İstemci Kitaplığı Aracısı tarafından yönetiliyor.</span><span class="sxs-lookup"><span data-stu-id="e530b-144">To do so, the shard maps managed by the client library broker the database connections for an application.</span></span> <span data-ttu-id="e530b-145">Bu bağlantı için oluşturulan shardlet parça yönetim işlemlerini etkileyebilir olduğunda otomatik olarak bir veritabanı bağlantısı sonlandırılamadı parça eşleme işlevselliği sağlar.</span><span class="sxs-lookup"><span data-stu-id="e530b-145">This allows the shard map functionality to automatically kill a database connection when shard management operations could impact the shardlet that the connection has been created for.</span></span> <span data-ttu-id="e530b-146">Mevcut bir veritabanı varlığını denetlemek için yeni bağlantı oluşturma gibi EF'ın işlevlerini bazıları ile tümleştirmek bu yaklaşım gerekir.</span><span class="sxs-lookup"><span data-stu-id="e530b-146">This approach needs to integrate with some of EF’s functionality, such as creating new connections from an existing one to check for database existence.</span></span> <span data-ttu-id="e530b-147">Genel olarak, bizim gözlem güvenilir bir şekilde EF için güvenli bir şekilde kopyalanıp kapalı veritabanı bağlantıları için yalnızca iş standart DbContext oluşturucular çalıştığını olmuştur.</span><span class="sxs-lookup"><span data-stu-id="e530b-147">In general, our observation has been that the standard DbContext constructors only work reliably for closed database connections that can safely be cloned for EF work.</span></span> <span data-ttu-id="e530b-148">Esnek veritabanı tasarım ilkesini bunun yerine yalnızca açık bağlantıları Aracısı sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="e530b-148">The design principle of elastic database instead is to only broker opened connections.</span></span> <span data-ttu-id="e530b-149">Bir istemci kitaplığı tarafından EF DbContext vermekten önce aracılı bağlantı kesiliyor bu sorunu çözebilir düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e530b-149">One might think that closing a connection brokered by the client library before handing it over to the EF DbContext may solve this issue.</span></span> <span data-ttu-id="e530b-150">Ancak, bağlantı kesiliyor ve yeniden açın EF bağlı olan bir kitaplık tarafından gerçekleştirilen doğrulama ve tutarlılık denetimleri sağlamlığın gerisinde kalır.</span><span class="sxs-lookup"><span data-stu-id="e530b-150">However, by closing the connection and relying on EF to re-open it, one foregoes the validation and consistency checks performed by the library.</span></span> <span data-ttu-id="e530b-151">EF, geçişler işlevi, bu bağlantıları ancak, temel alınan veritabanı şeması uygulamaya saydam bir şekilde yönetmek için kullanır.</span><span class="sxs-lookup"><span data-stu-id="e530b-151">The migrations functionality in EF, however, uses these connections to manage the underlying database schema in a way that is transparent to the application.</span></span> <span data-ttu-id="e530b-152">İdeal olarak, korur ve tüm bu özellikler esnek veritabanı istemci kitaplığı ve EF aynı uygulamada birleştirmek isteriz.</span><span class="sxs-lookup"><span data-stu-id="e530b-152">Ideally, we would like to retain and combine all these capabilities from both the elastic database client library and EF in the same application.</span></span> <span data-ttu-id="e530b-153">Aşağıdaki bölümde, bu özellikleri ve gereksinimleri daha ayrıntılı açıklanır.</span><span class="sxs-lookup"><span data-stu-id="e530b-153">The following section discusses these properties and requirements in more detail.</span></span> 

## <a name="requirements"></a><span data-ttu-id="e530b-154">Gereksinimler</span><span class="sxs-lookup"><span data-stu-id="e530b-154">Requirements</span></span>
<span data-ttu-id="e530b-155">Esnek veritabanı istemci kitaplığı ve Entity Framework API'leri ile çalışırken, aşağıdaki özellikleri korumak istiyor:</span><span class="sxs-lookup"><span data-stu-id="e530b-155">When working with both the elastic database client library and Entity Framework APIs, we want to retain the following properties:</span></span> 

* <span data-ttu-id="e530b-156">**Genişleme**: eklemek veya uygulamanın parçalı uygulama kapasite gereksinimlerini karşılamak için gerekli olarak veri katmanından veritabanlarını kaldırmak için.</span><span class="sxs-lookup"><span data-stu-id="e530b-156">**Scale-out**: To add or remove databases from the data tier of the sharded application as necessary for the capacity demands of the application.</span></span> <span data-ttu-id="e530b-157">Bu denetim üzerinden anlamına gelir oluşturulması ve veritabanları ve esnek veritabanı parça kullanarak silinmesini veritabanları ve shardlets eşlemelerini yönetmek için manager API'leri eşleyin.</span><span class="sxs-lookup"><span data-stu-id="e530b-157">This means control over the the creation and deletion of databases and using the elastic database shard map manager APIs to manage databases, and mappings of shardlets.</span></span> 
* <span data-ttu-id="e530b-158">**Tutarlılık**: uygulama parçalama kullanır ve veri bağımlı yönlendirme yeteneklerini istemci kitaplığını kullanır.</span><span class="sxs-lookup"><span data-stu-id="e530b-158">**Consistency**: The application employs sharding, and uses the data dependent routing capabilities of the client library.</span></span> <span data-ttu-id="e530b-159">Bozulma veya yanlış sorgu sonuçları önlemek için bağlantılar parça eşleme Yöneticisi aracılığıyla aracılı.</span><span class="sxs-lookup"><span data-stu-id="e530b-159">To avoid corruption or wrong query results, connections are brokered through the shard map manager.</span></span> <span data-ttu-id="e530b-160">Bu ayrıca doğrulama ve tutarlılık korur.</span><span class="sxs-lookup"><span data-stu-id="e530b-160">This also retains validation and consistency.</span></span>
* <span data-ttu-id="e530b-161">**İlk kod**: EF'ın kod ilk kip kolaylık korumak için.</span><span class="sxs-lookup"><span data-stu-id="e530b-161">**Code First**: To retain the convenience of EF’s code first paradigm.</span></span> <span data-ttu-id="e530b-162">Code First içinde uygulama sınıflarda saydam temel alınan veritabanı yapılarını eşlenir.</span><span class="sxs-lookup"><span data-stu-id="e530b-162">In Code First, classes in the application are mapped transparently to the underlying database structures.</span></span> <span data-ttu-id="e530b-163">Uygulama kodu birçok yönüyle temel alınan veritabanı işleme, söz konusu maske DbSets ile etkileşim kurar.</span><span class="sxs-lookup"><span data-stu-id="e530b-163">The application code interacts with DbSets that mask most aspects involved in the underlying database processing.</span></span>
* <span data-ttu-id="e530b-164">**Şema**: Entity Framework ilk veritabanı şeması oluşturma ve sonraki şema evrimi geçişleri üzerinden işler.</span><span class="sxs-lookup"><span data-stu-id="e530b-164">**Schema**: Entity Framework handles initial database schema creation and subsequent schema evolution through migrations.</span></span> <span data-ttu-id="e530b-165">Veri geliştikçe yeteneklere koruyarak uygulamanızı uyarlama kolaydır.</span><span class="sxs-lookup"><span data-stu-id="e530b-165">By retaining these capabilities, adapting your app is easy as the data evolves.</span></span> 

<span data-ttu-id="e530b-166">Aşağıdaki kılavuz esnek veritabanı araçlarını kullanarak Code First uygulamalar için bu gereksinimleri karşılamak nasıl bildirir.</span><span class="sxs-lookup"><span data-stu-id="e530b-166">The following guidance instructs how to satisfy these requirements for Code First applications using elastic database tools.</span></span> 

## <a name="data-dependent-routing-using-ef-dbcontext"></a><span data-ttu-id="e530b-167">Veri bağımlı yönlendirme EF DbContext kullanma</span><span class="sxs-lookup"><span data-stu-id="e530b-167">Data dependent routing using EF DbContext</span></span>
<span data-ttu-id="e530b-168">Entity Framework veritabanı bağlantılarıyla genellikle alt sınıflarının yönetilen **DbContext**.</span><span class="sxs-lookup"><span data-stu-id="e530b-168">Database connections with Entity Framework are typically managed through subclasses of **DbContext**.</span></span> <span data-ttu-id="e530b-169">Bu alt sınıflarından türetme tarafından oluşturma **DbContext**.</span><span class="sxs-lookup"><span data-stu-id="e530b-169">Create these subclasses by deriving from **DbContext**.</span></span> <span data-ttu-id="e530b-170">Burada, tanımlarsınız, **DbSets** CLR nesnesi, uygulamanız için veritabanı yedeği koleksiyonları uygulayın.</span><span class="sxs-lookup"><span data-stu-id="e530b-170">This is where you define your **DbSets** that implement the database-backed collections of CLR objects for your application.</span></span> <span data-ttu-id="e530b-171">Veri bağımlı yönlendirme bağlamında, biz diğer EF kodu ilk uygulama senaryoları için mutlaka tutmayın çeşitli yararlı özelliklerini tanımlayabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="e530b-171">In the context of data dependent routing, we can identify several helpful properties that do not necessarily hold for other EF code first application scenarios:</span></span> 

* <span data-ttu-id="e530b-172">Veritabanı zaten var ve esnek veritabanı parça eşlemesinde kaydedildi.</span><span class="sxs-lookup"><span data-stu-id="e530b-172">The database already exists and has been registered in the elastic database shard map.</span></span> 
* <span data-ttu-id="e530b-173">Uygulama şeması (aşağıda açıklanmıştır) veritabanı için zaten dağıtılmış.</span><span class="sxs-lookup"><span data-stu-id="e530b-173">The schema of the application has already been deployed to the database (explained below).</span></span> 
* <span data-ttu-id="e530b-174">Veri bağımlı yönlendirme bağlantıları veritabanı tarafından parça eşleme aracılı.</span><span class="sxs-lookup"><span data-stu-id="e530b-174">Data-dependent routing connections to the database are brokered by the shard map.</span></span> 

<span data-ttu-id="e530b-175">Tümleştirmek için **DbContexts** veri bağımlı genişleme için Yönlendirme:</span><span class="sxs-lookup"><span data-stu-id="e530b-175">To integrate **DbContexts** with data-dependent routing for scale-out:</span></span>

1. <span data-ttu-id="e530b-176">Parça eşleme Yöneticisi'nin esnek veritabanı istemci arabirimleri aracılığıyla fiziksel veritabanı bağlantıları oluşturma,</span><span class="sxs-lookup"><span data-stu-id="e530b-176">Create physical database connections through the elastic database client interfaces of the shard map manager,</span></span> 
2. <span data-ttu-id="e530b-177">Bağlantı ile kaydırma **DbContext** alt sınıfı</span><span class="sxs-lookup"><span data-stu-id="e530b-177">Wrap the connection with the **DbContext** subclass</span></span>
3. <span data-ttu-id="e530b-178">İçine bağlantı geçirmek **DbContext** temel sınıflar EF tarafında tüm işleme olacağını da emin olun.</span><span class="sxs-lookup"><span data-stu-id="e530b-178">Pass the connection down into the **DbContext** base classes to ensure all the processing on the EF side happens as well.</span></span> 

<span data-ttu-id="e530b-179">Aşağıdaki kod örneği, bu yaklaşım gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="e530b-179">The following code example illustrates this approach.</span></span> <span data-ttu-id="e530b-180">(Ayrıca bu kodu eşlik eden Visual Studio projesinde '.)</span><span class="sxs-lookup"><span data-stu-id="e530b-180">(This code is also in the accompanying Visual Studio project)</span></span>

    public class ElasticScaleContext<T> : DbContext
    {
    public DbSet<Blog> Blogs { get; set; }
    …

        // C'tor for data dependent routing. This call will open a validated connection 
        // routed to the proper shard by the shard map manager. 
        // Note that the base class c'tor call will fail for an open connection
        // if migrations need to be done and SQL credentials are used. This is the reason for the 
        // separation of c'tors into the data-dependent routing case (this c'tor) and the internal c'tor for new shards.
        public ElasticScaleContext(ShardMap shardMap, T shardingKey, string connectionStr)
            : base(CreateDDRConnection(shardMap, shardingKey, connectionStr), 
            true /* contextOwnsConnection */)
        {
        }

        // Only static methods are allowed in calls into base class c'tors.
        private static DbConnection CreateDDRConnection(
        ShardMap shardMap, 
        T shardingKey, 
        string connectionStr)
        {
            // No initialization
            Database.SetInitializer<ElasticScaleContext<T>>(null);

            // Ask shard map to broker a validated connection for the given key
            SqlConnection conn = shardMap.OpenConnectionForKey<T>
                                (shardingKey, connectionStr, ConnectionOptions.Validate);
            return conn;
        }    

## <a name="main-points"></a><span data-ttu-id="e530b-181">Ana noktaları</span><span class="sxs-lookup"><span data-stu-id="e530b-181">Main points</span></span>
* <span data-ttu-id="e530b-182">Varsayılan Oluşturucu DbContext alt yeni oluşturucuyu değiştirir</span><span class="sxs-lookup"><span data-stu-id="e530b-182">A new constructor replaces the default constructor in the DbContext subclass</span></span> 
* <span data-ttu-id="e530b-183">Yeni Oluşturucusu veri bağımlı esnek veritabanı istemci kitaplığı yönlendirme için gerekli olan bağımsız değişkenler alır:</span><span class="sxs-lookup"><span data-stu-id="e530b-183">The new constructor takes the arguments that are required for data dependent routing through elastic database client library:</span></span>
  
  * <span data-ttu-id="e530b-184">veri bağımlı yönlendirme arabirimlerini erişmek için parça eşleme</span><span class="sxs-lookup"><span data-stu-id="e530b-184">the shard map to access the data-dependent routing interfaces,</span></span>
  * <span data-ttu-id="e530b-185">shardlet tanımlamak için parçalama anahtarı</span><span class="sxs-lookup"><span data-stu-id="e530b-185">the sharding key to identify the shardlet,</span></span>
  * <span data-ttu-id="e530b-186">Parça veri bağımlı yönlendirme bağlantısı için kimlik bilgileri ile bir bağlantı dizesi.</span><span class="sxs-lookup"><span data-stu-id="e530b-186">a connection string with the credentials for the data-dependent routing connection to the shard.</span></span> 
* <span data-ttu-id="e530b-187">Taban sınıf oluşturucu çağrısı veri bağımlı yönlendirme için gerekli tüm adımları gerçekleştirir statik bir yönteme bir detour alır.</span><span class="sxs-lookup"><span data-stu-id="e530b-187">The call to the base class constructor takes a detour into a static method that performs all the steps necessary for data-dependent routing.</span></span> 
  
  * <span data-ttu-id="e530b-188">Esnek veritabanı istemci arabirimlerin OpenConnectionForKey çağrısı, açık bir bağlantı kurmak için parça haritada kullanır.</span><span class="sxs-lookup"><span data-stu-id="e530b-188">It uses the OpenConnectionForKey call of the elastic database client interfaces on the shard map to establish an open connection.</span></span>
  * <span data-ttu-id="e530b-189">Parça eşlemesi belirtilen parçalama anahtar shardlet tutan parça açık bağlantısı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="e530b-189">The shard map creates the open connection to the shard that holds the shardlet for the given sharding key.</span></span>
  * <span data-ttu-id="e530b-190">Bu açık bağlantı geri bu bağlantının otomatik olarak yeni bir bağlantı oluşturmak EF yapmasına izin vermek yerine EF tarafından kullanılacak olduğunu belirtmek için DbContext temel sınıf oluşturucusunun geçirilir.</span><span class="sxs-lookup"><span data-stu-id="e530b-190">This open connection is passed back to the base class constructor of DbContext to indicate that this connection is to be used by EF instead of letting EF create a new connection automatically.</span></span> <span data-ttu-id="e530b-191">Böylece parça eşleme yönetim işlemleri altında tutarlılığı garanti edebilir bu şekilde bağlantı esnek veritabanı istemci API tarafından etiketlendiği.</span><span class="sxs-lookup"><span data-stu-id="e530b-191">This way the connection has been tagged by the elastic database client API so that it can guarantee consistency under shard map management operations.</span></span>

<span data-ttu-id="e530b-192">Varsayılan Oluşturucu, kodunuzda yerine, bir DbContext alt için yeni bir oluşturucu kullanın.</span><span class="sxs-lookup"><span data-stu-id="e530b-192">Use the new constructor for your DbContext subclass instead of the default constructor in your code.</span></span> <span data-ttu-id="e530b-193">Örnek aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="e530b-193">Here is an example:</span></span> 

    // Create and save a new blog.

    Console.Write("Enter a name for a new blog: "); 
    var name = Console.ReadLine(); 

    using (var db = new ElasticScaleContext<int>( 
                            sharding.ShardMap,  
                            tenantId1,  
                            connStrBldr.ConnectionString)) 
    { 
        var blog = new Blog { Name = name }; 
        db.Blogs.Add(blog); 
        db.SaveChanges(); 

        // Display all Blogs for tenant 1 
        var query = from b in db.Blogs 
                    orderby b.Name 
                    select b; 
     … 
    }

<span data-ttu-id="e530b-194">Yeni Oluşturucusu değeri tarafından tanımlanan shardlet verilerini tutan parça bağlantı açar **tenantid1**.</span><span class="sxs-lookup"><span data-stu-id="e530b-194">The new constructor opens the connection to the shard that holds the data for the shardlet identified by the value of **tenantid1**.</span></span> <span data-ttu-id="e530b-195">Kodda **kullanarak** blok erişimi değişmeden kalır **DbSet** için parça EF kullanarak Web günlükleri için **tenantid1**.</span><span class="sxs-lookup"><span data-stu-id="e530b-195">The code in the **using** block stays unchanged to access the **DbSet** for blogs using EF on the shard for **tenantid1**.</span></span> <span data-ttu-id="e530b-196">Kullanarak kod bloğu için gibi tüm veritabanı işlemleri için bir parça şimdi kapsamındaki bu semantiğini değiştirir nerede **tenantid1** tutulur.</span><span class="sxs-lookup"><span data-stu-id="e530b-196">This changes semantics for the code in the using block such that all database operations are now scoped to the one shard where **tenantid1** is kept.</span></span> <span data-ttu-id="e530b-197">Örneğin, bir LINQ sorgusu bloglar üzerinden **DbSet** yalnızca üzerinde geçerli parça depolanan bloglar, ancak diğer parça üzerinde depolanan olanları döndürür.</span><span class="sxs-lookup"><span data-stu-id="e530b-197">For instance, a LINQ query over the blogs **DbSet** would only return blogs stored on the current shard, but not the ones stored on other shards.</span></span>  

#### <a name="transient-faults-handling"></a><span data-ttu-id="e530b-198">Geçici hataları işleme</span><span class="sxs-lookup"><span data-stu-id="e530b-198">Transient faults handling</span></span>
<span data-ttu-id="e530b-199">Microsoft Patterns & yöntemler takım yayımlanan [geçici hata işleme uygulama blok](https://msdn.microsoft.com/library/dn440719.aspx).</span><span class="sxs-lookup"><span data-stu-id="e530b-199">The Microsoft Patterns & Practices team published the [The Transient Fault Handling Application Block](https://msdn.microsoft.com/library/dn440719.aspx).</span></span> <span data-ttu-id="e530b-200">Kitaplık esnek ölçek istemci kitaplığı EF ile birlikte kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e530b-200">The library is used with elastic scale client library in combination with EF.</span></span> <span data-ttu-id="e530b-201">Ancak, geçici bir özel durumla burada biz böylece biz tweaked oluşturucuları kullanarak herhangi bir yeni bağlantı denemesi yapılan yeni oluşturucusunun sonra geçici bir hata kullanıldığından emin olabilirsiniz bir yere döndürdüğünden emin olun.</span><span class="sxs-lookup"><span data-stu-id="e530b-201">However, ensure that any transient exception returns to a place where we can ensure that the new constructor is being used after a transient fault so that any new connection attempt is made using the constructors we have tweaked.</span></span> <span data-ttu-id="e530b-202">Aksi takdirde doğru parça bağlantı garanti edilmez ve parça eşleme değişiklikler oldukça bağlantının korunacağı hiçbir garanti vermediğini vardır.</span><span class="sxs-lookup"><span data-stu-id="e530b-202">Otherwise, a connection to the correct shard is not guaranteed, and there are no assurances the connection is maintained as changes to the shard map occur.</span></span> 

<span data-ttu-id="e530b-203">Aşağıdaki kod örneği nasıl bir SQL yeniden deneme ilkesi yeni kullanılabileceğini gösterir **DbContext** alt sınıf oluşturucular:</span><span class="sxs-lookup"><span data-stu-id="e530b-203">The following code sample illustrates how a SQL retry policy can be used around the new **DbContext** subclass constructors:</span></span> 

    SqlDatabaseUtils.SqlRetryPolicy.ExecuteAction(() => 
    { 
        using (var db = new ElasticScaleContext<int>( 
                                sharding.ShardMap,  
                                tenantId1,  
                                connStrBldr.ConnectionString)) 
            { 
                    var blog = new Blog { Name = name }; 
                    db.Blogs.Add(blog); 
                    db.SaveChanges(); 
            … 
            } 
        }); 

<span data-ttu-id="e530b-204">**SqlDatabaseUtils.SqlRetryPolicy** Yukarıdaki kod olarak tanımlanan bir **SqlDatabaseTransientErrorDetectionStrategy** bir yeniden deneme sayısı 10 ve 5 saniye ile yeniden denemeler arasındaki süre bekleyin.</span><span class="sxs-lookup"><span data-stu-id="e530b-204">**SqlDatabaseUtils.SqlRetryPolicy** in the code above is defined as a **SqlDatabaseTransientErrorDetectionStrategy** with a retry count of 10, and 5 seconds wait time between retries.</span></span> <span data-ttu-id="e530b-205">Bu yaklaşım EF ve kullanıcı tarafından başlatılan işlemleri için yönergeler benzer (bkz [yeniden deneniyor yürütme stratejileri (veya sonraki sürümleri EF6) kısıtlamalarla](http://msdn.microsoft.com/data/dn307226).</span><span class="sxs-lookup"><span data-stu-id="e530b-205">This approach is similar to the guidance for EF and user-initiated transactions (see [Limitations with Retrying Execution Strategies (EF6 onwards)](http://msdn.microsoft.com/data/dn307226).</span></span> <span data-ttu-id="e530b-206">Her iki durumlarda uygulama programı geçici özel durumu döndüren kapsam denetimleri gerektirir: esnek veritabanı istemci kitaplığı kullanan işlem yeniden veya (gösterildiği gibi) uygun Oluşturucusu bağlamından yeniden oluşturun.</span><span class="sxs-lookup"><span data-stu-id="e530b-206">Both situations require that the application program controls the scope to which the transient exception returns: to either reopen the transaction, or (as shown) recreate the context from the proper constructor that uses the elastic database client library.</span></span>

<span data-ttu-id="e530b-207">Burada geçici özel durumlar bize geri kapsamında olması denetlemek için gereken ayrıca yerleşik kullanımını önleyen **SqlAzureExecutionStrategy** EF ile birlikte gelir.</span><span class="sxs-lookup"><span data-stu-id="e530b-207">The need to control where transient exceptions take us back in scope also precludes the use of the built-in **SqlAzureExecutionStrategy** that comes with EF.</span></span> <span data-ttu-id="e530b-208">**SqlAzureExecutionStrategy** bir bağlantıyı yeniden, ancak kullanmaz **OpenConnectionForKey** ve bu nedenle bir parçası olarak gerçekleştirilen tüm doğrulama atlama **OpenConnectionForKey**çağırın.</span><span class="sxs-lookup"><span data-stu-id="e530b-208">**SqlAzureExecutionStrategy** would reopen a connection but not use **OpenConnectionForKey** and therefore bypass all the validation that is performed as part of the **OpenConnectionForKey** call.</span></span> <span data-ttu-id="e530b-209">Bunun yerine, yerleşik kod örneğini kullanan **DefaultExecutionStrategy** EF ile de gelir.</span><span class="sxs-lookup"><span data-stu-id="e530b-209">Instead, the code sample uses the built-in **DefaultExecutionStrategy** that also comes with EF.</span></span> <span data-ttu-id="e530b-210">Tersine **SqlAzureExecutionStrategy**, doğru geçici hata işleme yeniden deneme ilkesi ile birlikte çalışır.</span><span class="sxs-lookup"><span data-stu-id="e530b-210">As opposed to **SqlAzureExecutionStrategy**, it works correctly in combination with the retry policy from Transient Fault Handling.</span></span> <span data-ttu-id="e530b-211">Yürütme ilkesini ayarlama **ElasticScaleDbConfiguration** sınıfı.</span><span class="sxs-lookup"><span data-stu-id="e530b-211">The execution policy is set in the **ElasticScaleDbConfiguration** class.</span></span> <span data-ttu-id="e530b-212">Kullanmamaya karar Not **DefaultSqlExecutionStrategy** kullanmak için önerdiği beri **SqlAzureExecutionStrategy** geçici özel durumlar oluşursa - hangi neden yanlış davranışa açıklandığı gibi.</span><span class="sxs-lookup"><span data-stu-id="e530b-212">Note that we decided not to use **DefaultSqlExecutionStrategy** since it suggests to use **SqlAzureExecutionStrategy** if transient exceptions occur - which would lead to wrong behavior as discussed.</span></span> <span data-ttu-id="e530b-213">EF ve farklı yeniden deneme ilkeleri hakkında daha fazla bilgi için bkz: [EF bağlantı dayanıklılığı](http://msdn.microsoft.com/data/dn456835.aspx).</span><span class="sxs-lookup"><span data-stu-id="e530b-213">For more information on the different retry policies and EF, see [Connection Resiliency in EF](http://msdn.microsoft.com/data/dn456835.aspx).</span></span>     

#### <a name="constructor-rewrites"></a><span data-ttu-id="e530b-214">Oluşturucu yeniden yazmalar</span><span class="sxs-lookup"><span data-stu-id="e530b-214">Constructor rewrites</span></span>
<span data-ttu-id="e530b-215">Yukarıdaki kod örnekleri Entity Framework ile yönlendirme bağımlı veri kullanmak için uygulamanız için gereken varsayılan oluşturucusu yeniden yazar gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="e530b-215">The code examples above illustrate the default constructor re-writes required for your application in order to use  data dependent routing with the Entity Framework.</span></span> <span data-ttu-id="e530b-216">Aşağıdaki tabloda bu yaklaşımı diğer oluşturucular genelleştirir.</span><span class="sxs-lookup"><span data-stu-id="e530b-216">The following table generalizes this approach to other constructors.</span></span> 

| <span data-ttu-id="e530b-217">Geçerli Oluşturucusu</span><span class="sxs-lookup"><span data-stu-id="e530b-217">Current Constructor</span></span> | <span data-ttu-id="e530b-218">Verileri yeniden Oluşturucusu</span><span class="sxs-lookup"><span data-stu-id="e530b-218">Rewritten Constructor for data</span></span> | <span data-ttu-id="e530b-219">Temel Oluşturucusu</span><span class="sxs-lookup"><span data-stu-id="e530b-219">Base Constructor</span></span> | <span data-ttu-id="e530b-220">Notlar</span><span class="sxs-lookup"><span data-stu-id="e530b-220">Notes</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="e530b-221">MyContext()</span><span class="sxs-lookup"><span data-stu-id="e530b-221">MyContext()</span></span> |<span data-ttu-id="e530b-222">ElasticScaleContext (ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="e530b-222">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="e530b-223">DbContext (DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="e530b-223">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="e530b-224">Bağlantı bir işlev parça eşleme ve veri bağımlı yönlendirme anahtarı olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e530b-224">The connection needs to be a function of the shard map and the data-dependent routing key.</span></span> <span data-ttu-id="e530b-225">Parça eşleme Bağlantı Aracısı kullanın ve atlama otomatik bağlantı oluşturma EF işlemi yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e530b-225">You need to by-pass automatic connection creation by EF and instead use the shard map to broker the connection.</span></span> |
| <span data-ttu-id="e530b-226">MyContext(string)</span><span class="sxs-lookup"><span data-stu-id="e530b-226">MyContext(string)</span></span> |<span data-ttu-id="e530b-227">ElasticScaleContext (ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="e530b-227">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="e530b-228">DbContext (DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="e530b-228">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="e530b-229">Bağlantı parça eşleme ve veri bağımlı yönlendirme anahtarı bir işlevdir.</span><span class="sxs-lookup"><span data-stu-id="e530b-229">The connection is a function of the shard map and the data-dependent routing key.</span></span> <span data-ttu-id="e530b-230">Sabit veritabanı adı veya bağlantı dizesi çalışmazlar parça eşleme tarafından atlama doğrulama.</span><span class="sxs-lookup"><span data-stu-id="e530b-230">A fixed database name or connection string will not work as they by-pass validation by the shard map.</span></span> |
| <span data-ttu-id="e530b-231">MyContext(DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="e530b-231">MyContext(DbCompiledModel)</span></span> |<span data-ttu-id="e530b-232">ElasticScaleContext (ShardMap, TKey, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="e530b-232">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="e530b-233">DbContext (DbConnection, DbCompiledModel, Boole)</span><span class="sxs-lookup"><span data-stu-id="e530b-233">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="e530b-234">Bağlantı verilen parça eşleme ve parçalama anahtarı için sağlanan modeliyle oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e530b-234">The connection will get created for the given shard map and sharding key with the model provided.</span></span> <span data-ttu-id="e530b-235">Derlenmiş modeli temel c'tor geçirilecektir.</span><span class="sxs-lookup"><span data-stu-id="e530b-235">The compiled model will be passed on to the base c’tor.</span></span> |
| <span data-ttu-id="e530b-236">MyContext (DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="e530b-236">MyContext(DbConnection, bool)</span></span> |<span data-ttu-id="e530b-237">ElasticScaleContext (ShardMap, TKey, Boole)</span><span class="sxs-lookup"><span data-stu-id="e530b-237">ElasticScaleContext(ShardMap, TKey, bool)</span></span> |<span data-ttu-id="e530b-238">DbContext (DbConnection, bool)</span><span class="sxs-lookup"><span data-stu-id="e530b-238">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="e530b-239">Bağlantı parça eşleme ve anahtar olayla gerekiyor.</span><span class="sxs-lookup"><span data-stu-id="e530b-239">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="e530b-240">(Bu girişi zaten parça eşleme ve anahtarı kullanmadığı sürece) bir giriş olarak sağlanamaz.</span><span class="sxs-lookup"><span data-stu-id="e530b-240">It cannot be provided as an input (unless that input was already using the shard map and the key).</span></span> <span data-ttu-id="e530b-241">Boolean geçirilir.</span><span class="sxs-lookup"><span data-stu-id="e530b-241">The Boolean will be passed on.</span></span> |
| <span data-ttu-id="e530b-242">MyContext (dize, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="e530b-242">MyContext(string, DbCompiledModel)</span></span> |<span data-ttu-id="e530b-243">ElasticScaleContext (ShardMap, TKey, DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="e530b-243">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="e530b-244">DbContext (DbConnection, DbCompiledModel, Boole)</span><span class="sxs-lookup"><span data-stu-id="e530b-244">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="e530b-245">Bağlantı parça eşleme ve anahtar olayla gerekiyor.</span><span class="sxs-lookup"><span data-stu-id="e530b-245">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="e530b-246">(Bu giriş parça eşleme ve anahtarı kullanmadığı sürece) bir giriş olarak sağlanamaz.</span><span class="sxs-lookup"><span data-stu-id="e530b-246">It cannot be provided as an input (unless that input was using the shard map and the key).</span></span> <span data-ttu-id="e530b-247">Derlenmiş modeli geçirilir.</span><span class="sxs-lookup"><span data-stu-id="e530b-247">The compiled model will be passed on.</span></span> |
| <span data-ttu-id="e530b-248">MyContext (ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="e530b-248">MyContext(ObjectContext, bool)</span></span> |<span data-ttu-id="e530b-249">ElasticScaleContext (ShardMap, TKey, ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="e530b-249">ElasticScaleContext(ShardMap, TKey, ObjectContext, bool)</span></span> |<span data-ttu-id="e530b-250">DbContext (ObjectContext, bool)</span><span class="sxs-lookup"><span data-stu-id="e530b-250">DbContext(ObjectContext, bool)</span></span> |<span data-ttu-id="e530b-251">Herhangi bir giriş olarak geçirilen ObjectContext bağlantısında esnek ölçek tarafından yönetilen bir bağlantıya yeniden yönlendirilmiş olduğundan emin olmak yeni Oluşturucusu gerekir.</span><span class="sxs-lookup"><span data-stu-id="e530b-251">The new constructor needs to ensure that any connection in the ObjectContext passed as an input is re-routed to a connection managed by Elastic Scale.</span></span> <span data-ttu-id="e530b-252">ObjectContexts hakkında ayrıntılı bilgi, bu belgenin kapsamında değildir.</span><span class="sxs-lookup"><span data-stu-id="e530b-252">A detailed discussion of ObjectContexts is beyond the scope of this document.</span></span> |
| <span data-ttu-id="e530b-253">MyContext (DbConnection, DbCompiledModel, Boole)</span><span class="sxs-lookup"><span data-stu-id="e530b-253">MyContext(DbConnection, DbCompiledModel,bool)</span></span> |<span data-ttu-id="e530b-254">ElasticScaleContext (ShardMap, TKey, DbCompiledModel, bool)</span><span class="sxs-lookup"><span data-stu-id="e530b-254">ElasticScaleContext(ShardMap, TKey, DbCompiledModel, bool)</span></span> |<span data-ttu-id="e530b-255">DbContext (DbConnection, DbCompiledModel, bool);</span><span class="sxs-lookup"><span data-stu-id="e530b-255">DbContext(DbConnection, DbCompiledModel, bool);</span></span> |<span data-ttu-id="e530b-256">Bağlantı parça eşleme ve anahtar olayla gerekiyor.</span><span class="sxs-lookup"><span data-stu-id="e530b-256">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="e530b-257">(Bu girişi zaten parça eşleme ve anahtarı kullanmadığı sürece) bir giriş olarak bağlantı sağlanamaz.</span><span class="sxs-lookup"><span data-stu-id="e530b-257">The connection cannot be provided as an input (unless that input was already using the shard map and the key).</span></span> <span data-ttu-id="e530b-258">Model ve Boolean temel sınıf oluşturucu geçirilir.</span><span class="sxs-lookup"><span data-stu-id="e530b-258">Model and Boolean are passed on to the base class constructor.</span></span> |

## <a name="shard-schema-deployment-through-ef-migrations"></a><span data-ttu-id="e530b-259">EF geçişler aracılığıyla parça şema dağıtımı</span><span class="sxs-lookup"><span data-stu-id="e530b-259">Shard schema deployment through EF migrations</span></span>
<span data-ttu-id="e530b-260">Otomatik şema, Entity Framework tarafından sağlanan bir kolaylık yönetimidir.</span><span class="sxs-lookup"><span data-stu-id="e530b-260">Automatic schema management is a convenience provided by the Entity Framework.</span></span> <span data-ttu-id="e530b-261">Esnek veritabanı araçlarını kullanarak uygulamaları bağlamında veritabanları parçalı uygulamaya eklendiğinde otomatik olarak yeni oluşturulan parça şemaya sağlamak üzere bu özellikten korumak istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="e530b-261">In the context of applications using elastic database tools, we want to retain this capability to automatically provision the schema to newly created shards when databases are added to the sharded application.</span></span> <span data-ttu-id="e530b-262">EF kullanan parçalı uygulamalar için veri katmanı kapasitesini artırmak için birincil kullanım durumdur.</span><span class="sxs-lookup"><span data-stu-id="e530b-262">The primary use case is to increase capacity at the data tier for sharded applications using EF.</span></span> <span data-ttu-id="e530b-263">Şema Yönetimi için EF'in özellikleri güvenmek EF üzerinde oluşturulmuş parçalı bir uygulama ile veritabanı yönetim çaba azaltır.</span><span class="sxs-lookup"><span data-stu-id="e530b-263">Relying on EF’s capabilities for schema management reduces the database administration effort with a sharded application built on EF.</span></span> 

<span data-ttu-id="e530b-264">Şema dağıtımı EF geçişler aracılığıyla en iyi şekilde çalışır **açılmamış bağlantıları**.</span><span class="sxs-lookup"><span data-stu-id="e530b-264">Schema deployment through EF migrations works best on **unopened connections**.</span></span> <span data-ttu-id="e530b-265">Bu senaryo için veri bağımlı aksine esnek veritabanı istemci API tarafından sağlanan bağlantısı açıldı güvenen gönderiyor.</span><span class="sxs-lookup"><span data-stu-id="e530b-265">This is in contrast to the scenario for data dependent routing that relies on the opened connection provided by the elastic database client API.</span></span> <span data-ttu-id="e530b-266">Başka bir fark tutarlılık gereksinimdir: eşzamanlı parça eşleme işleme karşı korumak tüm veri bağımlı yönlendirme bağlantılarında tutarlılığını sağlamak için daha fazla tercih sırasında bu ilk ile ilgili bir sorun değildir şema dağıtım yeni bir veritabanı Parça eşlemesinde kayıtlı değil henüz ve shardlets tutmak için ayrılmamış henüz vardır.</span><span class="sxs-lookup"><span data-stu-id="e530b-266">Another difference is the consistency requirement: While desirable to ensure consistency for all data-dependent routing connections to protect against concurrent shard map manipulation, it is not a concern with initial schema deployment to a new database that has not yet been registered in the shard map, and not yet been allocated to hold shardlets.</span></span> <span data-ttu-id="e530b-267">Biz, bu nedenle veri bağımlı yönlendirme bu senaryoları için normal veritabanı bağlantılarında güvenebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e530b-267">We can therefore rely on regular database connections for this scenarios, as opposed to data-dependent routing.</span></span>  

<span data-ttu-id="e530b-268">Bu, bir yaklaşım nerede EF geçişler aracılığıyla şema dağıtımın sıkı şekilde yeni bir veritabanı kaydını ile uygulamanın parça eşlemesindeki bir parça olarak bağlı yol açar.</span><span class="sxs-lookup"><span data-stu-id="e530b-268">This leads to an approach where schema deployment through EF migrations is tightly coupled with the registration of the new database as a shard in the application’s shard map.</span></span> <span data-ttu-id="e530b-269">Bu, aşağıdaki önkoşulların üzerinde dayanır:</span><span class="sxs-lookup"><span data-stu-id="e530b-269">This relies on the following prerequisites:</span></span> 

* <span data-ttu-id="e530b-270">Veritabanı zaten oluşturuldu.</span><span class="sxs-lookup"><span data-stu-id="e530b-270">The database has already been created.</span></span> 
* <span data-ttu-id="e530b-271">Veritabanı boş - kullanıcı şeması yok ve hiçbir kullanıcı verileri tutar.</span><span class="sxs-lookup"><span data-stu-id="e530b-271">The database is empty - it holds no user schema and no user data.</span></span>
* <span data-ttu-id="e530b-272">Veritabanı, esnek veritabanı istemci API'leri veri bağımlı yönlendirme için henüz erişilemiyor.</span><span class="sxs-lookup"><span data-stu-id="e530b-272">The database cannot yet be accessed through the elastic database client APIs for data-dependent routing.</span></span> 

<span data-ttu-id="e530b-273">Bu önkoşulları yerine getirilince, bir normal oluşturabilir açılmamış **SqlConnection** EF geçişler şema dağıtımı için devre dışı tetiklersiniz için.</span><span class="sxs-lookup"><span data-stu-id="e530b-273">With these prerequisites in place, we can create a regular un-opened **SqlConnection** to kick off EF migrations for schema deployment.</span></span> <span data-ttu-id="e530b-274">Aşağıdaki kod örneği, bu yaklaşım gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="e530b-274">The following code sample illustrates this approach.</span></span> 

        // Enter a new shard - i.e. an empty database - to the shard map, allocate a first tenant to it  
        // and kick off EF intialization of the database to deploy schema 

        public void RegisterNewShard(string server, string database, string connStr, int key) 
        { 

            Shard shard = this.ShardMap.CreateShard(new ShardLocation(server, database)); 

            SqlConnectionStringBuilder connStrBldr = new SqlConnectionStringBuilder(connStr); 
            connStrBldr.DataSource = server; 
            connStrBldr.InitialCatalog = database; 

            // Go into a DbContext to trigger migrations and schema deployment for the new shard. 
            // This requires an un-opened connection. 
            using (var db = new ElasticScaleContext<int>(connStrBldr.ConnectionString)) 
            { 
                // Run a query to engage EF migrations 
                (from b in db.Blogs 
                    select b).Count(); 
            } 

            // Register the mapping of the tenant to the shard in the shard map. 
            // After this step, data-dependent routing on the shard map can be used 

            this.ShardMap.CreatePointMapping(key, shard); 
        } 


<span data-ttu-id="e530b-275">Bu örnek yöntemi gösterilir **RegisterNewShard** parça parça eşlemesinde kaydeder, şemanın EF geçişler aracılığıyla dağıtır ve parça parçalama anahtarına eşlemesi depolar.</span><span class="sxs-lookup"><span data-stu-id="e530b-275">This sample shows the method **RegisterNewShard** that registers the shard in the shard map, deploys the schema through EF migrations, and stores a mapping of a sharding key to the shard.</span></span> <span data-ttu-id="e530b-276">Bir oluşturucusuna dayanır **DbContext** bir alt kümesi (**ElasticScaleContext** örnekteki), bir SQL bağlantı dizesi giriş olarak alır.</span><span class="sxs-lookup"><span data-stu-id="e530b-276">It relies on a constructor of the **DbContext** subclass (**ElasticScaleContext** in the sample) that takes a SQL connection string as input.</span></span> <span data-ttu-id="e530b-277">Bu oluşturucu doğrudan İleri aşağıdaki örnekte gösterildiği gibi koddur:</span><span class="sxs-lookup"><span data-stu-id="e530b-277">The code of this constructor is straight-forward, as the following example shows:</span></span> 

        // C'tor to deploy schema and migrations to a new shard 
        protected internal ElasticScaleContext(string connectionString) 
            : base(SetInitializerForConnection(connectionString)) 
        { 
        } 

        // Only static methods are allowed in calls into base class c'tors 
        private static string SetInitializerForConnection(string connnectionString) 
        { 
            // We want existence checks so that the schema can get deployed 
            Database.SetInitializer<ElasticScaleContext<T>>( 
        new CreateDatabaseIfNotExists<ElasticScaleContext<T>>()); 

            return connnectionString; 
        } 

<span data-ttu-id="e530b-278">Bir taban sınıftan devralınan Oluşturucusu sürümünü kullanmış olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e530b-278">One might have used the version of the constructor inherited from the base class.</span></span> <span data-ttu-id="e530b-279">Ancak EF varsayılan Başlatıcı bağlanırken kullanıldığından emin olmak kod gerekiyor.</span><span class="sxs-lookup"><span data-stu-id="e530b-279">But the code needs to ensure that the default initializer for EF is used when connecting.</span></span> <span data-ttu-id="e530b-280">Bu nedenle kısa saptıran statik yöntemiyle bağlantı dizesiyle temel sınıf oluşturucu içine çağırmadan önce.</span><span class="sxs-lookup"><span data-stu-id="e530b-280">Hence the short detour into the static method before calling into the base class constructor with the connection string.</span></span> <span data-ttu-id="e530b-281">Parça kaydını farklı uygulama etki alanı ya da EF Başlatıcı ayarlarını çakışmasını emin olmak için işlem çalışması gerektiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="e530b-281">Note that the registration of shards should run in a different app domain or process to ensure that the initializer settings for EF do not conflict.</span></span> 

## <a name="limitations"></a><span data-ttu-id="e530b-282">Sınırlamalar</span><span class="sxs-lookup"><span data-stu-id="e530b-282">Limitations</span></span>
<span data-ttu-id="e530b-283">Bu belgede özetlenen yaklaşımlar birkaç sınırlama oluşturulmasını gerektirir:</span><span class="sxs-lookup"><span data-stu-id="e530b-283">The approaches outlined in this document entail a couple of limitations:</span></span> 

* <span data-ttu-id="e530b-284">Kullanan EF uygulamaları **LocalDb** esnek veritabanı istemci kitaplığı kullanmadan önce normal bir SQL Server veritabanına geçirmek önce gerekir.</span><span class="sxs-lookup"><span data-stu-id="e530b-284">EF applications that use **LocalDb** first need to migrate to a regular SQL Server database before using elastic database client library.</span></span> <span data-ttu-id="e530b-285">Esnek ölçeklendirme ile parçalama aracılığıyla bir uygulama ölçeğini mümkün değil **LocalDb**.</span><span class="sxs-lookup"><span data-stu-id="e530b-285">Scaling out an application through sharding with Elastic Scale is not possible with **LocalDb**.</span></span> <span data-ttu-id="e530b-286">Geliştirme hala kullanabileceğinizi unutmayın **LocalDb**.</span><span class="sxs-lookup"><span data-stu-id="e530b-286">Note that development can still use **LocalDb**.</span></span> 
* <span data-ttu-id="e530b-287">Veritabanı şema değişiklikleri kapsıyor değişiklikleri uygulamaya tüm parça EF geçişleri geçmeniz.</span><span class="sxs-lookup"><span data-stu-id="e530b-287">Any changes to the application that imply database schema changes need to go through EF migrations on all shards.</span></span> <span data-ttu-id="e530b-288">Bu belge için örnek kod, bunun nasıl yapılacağı gösterilmemiştir.</span><span class="sxs-lookup"><span data-stu-id="e530b-288">The sample code for this document does not demonstrate how to do this.</span></span> <span data-ttu-id="e530b-289">Tüm parça yinelemek için ConnectionString parametresiyle Update-Database kullanmayı düşünün; veya Update-Database kullanarak bekleyen geçiş T-SQL komut dosyasını ayıklamak komut dosyası seçeneği ve T-SQL betiği, parça uygulayın.</span><span class="sxs-lookup"><span data-stu-id="e530b-289">Consider using Update-Database with a ConnectionString parameter to iterate over all shards; or extract the T-SQL script for the pending migration using Update-Database with the -Script option and apply the T-SQL script to your shards.</span></span>  
* <span data-ttu-id="e530b-290">Bir istek göz önüne alındığında, tüm veritabanı işleme içinde yer alır, tek bir parça istek tarafından sağlanan parçalama anahtarı tarafından tanımlandığı gibi varsayılır.</span><span class="sxs-lookup"><span data-stu-id="e530b-290">Given a request, it is assumed that all of its database processing is contained within a single shard as identified by the sharding key provided by the request.</span></span> <span data-ttu-id="e530b-291">Ancak, bu varsayım her zaman true tutmaz.</span><span class="sxs-lookup"><span data-stu-id="e530b-291">However, this assumption does not always hold true.</span></span> <span data-ttu-id="e530b-292">Örneğin, ne zaman bir parçalama anahtarı kullanılabilir hale getirmek mümkündür değil.</span><span class="sxs-lookup"><span data-stu-id="e530b-292">For example, when it is not possible to make a sharding key available.</span></span> <span data-ttu-id="e530b-293">Bu sorunu çözmek için istemci kitaplığı sağlayan **MultiShardQuery** birkaç parça sorgulama için bir bağlantı Özet uygulayan sınıf.</span><span class="sxs-lookup"><span data-stu-id="e530b-293">To address this, the client library provides the **MultiShardQuery** class that implements a connection abstraction for querying over several shards.</span></span> <span data-ttu-id="e530b-294">Kullanmayı öğrenme **MultiShardQuery** EF ile birlikte bu belgenin kapsamında değildir</span><span class="sxs-lookup"><span data-stu-id="e530b-294">Learning to use the **MultiShardQuery** in combination with EF is beyond the scope of this document</span></span>

## <a name="conclusion"></a><span data-ttu-id="e530b-295">Sonuç</span><span class="sxs-lookup"><span data-stu-id="e530b-295">Conclusion</span></span>
<span data-ttu-id="e530b-296">Bu belgede özetlenen adımları, Oluşturucular, yeniden düzenleme yönlendirme bağımlı veriler için esnek veritabanı istemci kitaplığının yetenek EF uygulamaları kullanabilir **DbContext** EF uygulamada kullanılan alt sınıflar.</span><span class="sxs-lookup"><span data-stu-id="e530b-296">Through the steps outlined in this document, EF applications can use the elastic database client library's capability for data dependent routing by refactoring constructors of the **DbContext** subclasses used in the EF application.</span></span> <span data-ttu-id="e530b-297">Bu yerlerin gerekli değişiklikler bu sınırlar nerede **DbContext** sınıflar zaten mevcut.</span><span class="sxs-lookup"><span data-stu-id="e530b-297">This limits the  changes required to those places where **DbContext** classes already exist.</span></span> <span data-ttu-id="e530b-298">Ayrıca, EF uygulamaları yeni parça parça eşlemesindeki eşlemeleri ve gerekli EF geçişler kayıt ile çağırma adımları birleştirerek otomatik şema dağıtımından yararlanmaya devam edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e530b-298">In addition, EF applications can continue to benefit from automatic schema deployment by combining the steps that invoke the necessary EF migrations with the registration of new shards and mappings in the shard map.</span></span> 

[!INCLUDE [elastic-scale-include](../../includes/elastic-scale-include.md)]

<!--Image references-->
[1]: ./media/sql-database-elastic-scale-use-entity-framework-applications-visual-studio/sample.png
